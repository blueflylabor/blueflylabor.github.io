<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>计算机组成原理虚拟存储器页式段式和段页式 | lyyourc</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/favicon.ico">
  
<link rel="stylesheet" href="/css/app.css">

  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/atom.xml">rss</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/">计算机组成原理虚拟存储器页式段式和段页式</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">十月 06 2019</p>
  </section>

  <section class="article-entry">
    <h1>虚拟存储器·页式·段式·段页式</h1>
<p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>
用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>
实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>
<ul>
<li>实地址 = 主存页号 + 页内字地址</li>
<li>虚地址 = 虚存页号 + 页内字地址</li>
<li>辅存地址 = 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>
</ul>
<p>CPU使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>
<ul>
<li>在内存，通过地址变换，CPU可直接访问主存指示的数据单元</li>
<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>
</ul>
<h2 id="页式虚拟存储器">页式虚拟存储器</h2>
<p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong></p>
<h3 id="页表">页表</h3>
<p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>有效位</td>
<td>脏位</td>
<td>引用位</td>
<td>物理页</td>
</tr>
</tbody>
</table>
<ul>
<li>有效位（装入位）：表示对应页是否在主存</li>
<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>
<li>引用位（使用位）：配合替换算法进行设置</li>
</ul>
<p>CPU运行指令时，虚地址转实地址：</p>
<ul>
<li>页表基址寄存器存放进程的页表首地址</li>
<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>
<li>装入位为1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>
<li>装入位为0，说明缺页，需要操作系统进行缺页处理</li>
</ul>
<h3 id="快表-TLB">快表(TLB)</h3>
<p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>
快表通常采用组相联或全相联方式</p>
<table>
<thead>
<tr>
<th>t</th>
<th>r</th>
<th>p</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记</td>
<td>有效位</td>
<td>实页号</td>
</tr>
</tbody>
</table>
<h3 id="具有TLB和Cache的多级存储系统">具有TLB和Cache的多级存储系统</h3>
<p>三种缺失的情况</p>
<table>
<thead>
<tr>
<th></th>
<th>TLB</th>
<th>Page</th>
<th>Cache</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>命中</td>
<td>命中</td>
<td>命中</td>
<td>TLB命中则Page一定命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>2</td>
<td>命中</td>
<td>命中</td>
<td>缺失</td>
<td>TLB命中则Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>3</td>
<td>缺失</td>
<td>命中</td>
<td>命中</td>
<td>TLB缺失但Page可能命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>4</td>
<td>缺失</td>
<td>命中</td>
<td>缺失</td>
<td>TLB缺失但Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>5</td>
<td>缺失</td>
<td>缺失</td>
<td>缺失</td>
<td>TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache</td>
</tr>
</tbody>
</table>
<h2 id="段式虚拟存储器">段式虚拟存储器</h2>
<p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>段号</td>
<td>段首地址</td>
<td>装入位</td>
<td>段长</td>
</tr>
</tbody>
</table>
<p>CPU访存时：</p>
<ul>
<li>根据段号与段表基地址拼接成对应的段表行</li>
<li>根据段表行的装入位判断是否调入内存</li>
<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址</li>
</ul>
<h2 id="段页式虚拟存储器">段页式虚拟存储器</h2>
<p>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>
每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>段号</td>
<td>段内页号</td>
<td>页内地址</td>
</tr>
</tbody>
</table>
<p>CPU访存：</p>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成实地址</li>
</ul>
<h2 id="虚拟存储器与Cache的比较">虚拟存储器与Cache的比较</h2>
<table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的均为提供系统性能</td>
<td>Cache主要解决系统速度，虚拟存储器解决主存容量</td>
</tr>
<tr>
<td>均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大</td>
<td>Cache由硬件实现，对程序员透明，虚拟存储器由OS和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td>都有地址的映射、替换算法、更新策略</td>
<td></td>
</tr>
<tr>
<td>均依据程序的局部性原理</td>
<td></td>
</tr>
</tbody>
</table>

  </section>
</article>

  <div class="sharing grid">
  <section class="profile grid-item grid">
    <img class="avatar" src="http://7xrcp8.com1.z0.glb.clouddn.com/avatar.png" alt="avatar" />
    <div class="grid-item">
      <p class="title"> lyyourc </p>
      <p class="subtitle"> You Are The JavaScript In My HTML </p>
    <div>
  </section>

  <section class="share-btns">
    <!-- <p> share it if you like it~ </p> -->
    <a
  class="twitter-share-button"
  data-size="large"
  data-via="DrakeLeung"
  href="https://twitter.com/intent/tweet?text=>虚拟存储器·页式·段式·段页式</h1"
>
  Tweet
</a>

<script>
  window.twttr = (function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0],
    t = window.twttr || {};
  if (d.getElementById(id)) return t;
  js = d.createElement(s);
  js.id = id;
  js.src = "https://platform.twitter.com/widgets.js";
  js.async = true;
  fjs.parentNode.insertBefore(js, fjs);

  t._e = [];
  t.ready = function(f) {
    t._e.push(f);
  };

  return t;
}(document, "script", "twitter-wjs"));
</script>

  </section>
</div>


  
    
<section class="article-comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

<script>
  var disqus_shortname = 'drakeleung';
  
  var disqus_url = 'http://example.com/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


  
</main>

</body>
</html>
