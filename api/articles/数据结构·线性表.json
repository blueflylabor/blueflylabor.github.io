{"title":"数据结构·线性表","slug":"数据结构·线性表","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.348Z","comments":false,"path":"api/articles/数据结构·线性表.json","photos":[],"excerpt":"","covers":null,"content":"<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><h2 id=\"一、逻辑结构和基本操作\"><a href=\"#一、逻辑结构和基本操作\" class=\"headerlink\" title=\"一、逻辑结构和基本操作\"></a>一、逻辑结构和基本操作</h2><h3 id=\"1-逻辑结构\"><a href=\"#1-逻辑结构\" class=\"headerlink\" title=\"1. 逻辑结构\"></a>1. 逻辑结构</h3><ul>\n<li>具有相同数据类型的n个数据元素的有限序列，表长n，n&#x3D;0为空表</li>\n<li>表头：第一个元素</li>\n<li>表尾：最后一个元素</li>\n<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>\n<li>除最后一个元素外，每个元素有且仅有一个直接后继</li>\n</ul>\n<h3 id=\"2-基本操作\"><a href=\"#2-基本操作\" class=\"headerlink\" title=\"2. 基本操作\"></a>2. 基本操作</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">initList</span>(&amp;L);</span><br><span class=\"line\"><span class=\"built_in\">len</span>(L);</span><br><span class=\"line\"><span class=\"built_in\">locateElem</span>(L, i);</span><br><span class=\"line\"><span class=\"built_in\">getElem</span>(L, i);</span><br><span class=\"line\"><span class=\"built_in\">listInsert</span>(&amp;L, i, e);</span><br><span class=\"line\"><span class=\"built_in\">listDelete</span>(&amp;L, i, &amp;e);</span><br><span class=\"line\"><span class=\"built_in\">printList</span>(L);</span><br><span class=\"line\"><span class=\"built_in\">isEmptyList</span>(L);</span><br><span class=\"line\"><span class=\"built_in\">destroyList</span>(&amp;L);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、顺序存储结构\"><a href=\"#二、顺序存储结构\" class=\"headerlink\" title=\"二、顺序存储结构\"></a>二、顺序存储结构</h2><h3 id=\"1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻\"><a href=\"#1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻\" class=\"headerlink\" title=\"1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻\"></a>1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻</h3><ul>\n<li>存储空间的起始位置data[ ]</li>\n<li>顺序表最大存储容量MaxSize</li>\n<li>顺序表当前最大长度len<br>特点</li>\n<li>随机访存，O(1)时间复杂度访问</li>\n<li>存储密度高，每个结点只存储数据元素</li>\n<li>无需花费空间建立数据之间的逻辑关系，由物理位置相邻特性决定</li>\n<li>逻辑上物理上均相邻，插入删除操作需要移动大量元素</li>\n</ul>\n<h3 id=\"2-基本操作-1\"><a href=\"#2-基本操作-1\" class=\"headerlink\" title=\"2. 基本操作\"></a>2. 基本操作</h3><p>（1）插入元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入元素</span></span><br><span class=\"line\"><span class=\"function\">boolean <span class=\"title\">listInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i  L.len + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L.len = MaxSize)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = L.len; j  i; j--)</span><br><span class=\"line\">\t\tL.data[j] = L.data[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\tL.data[i - <span class=\"number\">1</span>] = e;</span><br><span class=\"line\">\tL.len++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析</p>\n<ul>\n<li>最好情况：在表尾插入 **(i&#x3D;n+1)**，不需要移动元素，时间复杂度为O(1)  </li>\n<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>\n<li>平均情况：假设$P_i$ **($P_i &#x3D; \\frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\\frac{n}{2}$，其时间复杂度为O(n)<br>（2）删除元素<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除元素</span></span><br><span class=\"line\"><span class=\"function\">boolean <span class=\"title\">listDelete</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i  L.len + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\te = L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; L.len; j++)</span><br><span class=\"line\">\t\tL.data[j<span class=\"number\">-1</span>] = L.data[j];</span><br><span class=\"line\">\tL.len--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n分析</li>\n<li>最好情况：在表尾插入 **(i&#x3D;n)**，不需要移动元素，时间复杂度为O(1)  </li>\n<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>\n<li>平均情况：假设$P_i$ **($P_i &#x3D; \\frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\\frac{n-1}{2}$，其时间复杂度为O(n)<br>（3）查找元素<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">locateElem</span><span class=\"params\">(SqList &amp;L, Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; L.len; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(e == L.data[i])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n分析</li>\n<li>最好情况：查找的元素在表头，仅需比较1次，时间复杂度O(1)</li>\n<li>最坏情况：查找的元素在表尾或不存在，需要比较n次，时间复杂度O(n)  </li>\n<li>平均情况：假设$P_i$ **($P_i &#x3D; \\frac{1}{n}$)**是在第i个位置上结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\\frac{n+1}{2}$，其时间复杂度为O(n)</li>\n</ul>\n<h1 id=\"链式存储结构\"><a href=\"#链式存储结构\" class=\"headerlink\" title=\"链式存储结构\"></a>链式存储结构</h1><h2 id=\"1-创建单链表\"><a href=\"#1-创建单链表\" class=\"headerlink\" title=\"1.创建单链表\"></a>1.创建单链表</h2><h3 id=\"（1）头插法\"><a href=\"#（1）头插法\" class=\"headerlink\" title=\"（1）头插法\"></a>（1）头插法</h3><ul>\n<li>为新插入的结点分配内存空间</li>\n<li>每次都是把插入的新结点放入表头(头结点位置)</li>\n<li>链表结点的次序与输入的顺序相反</li>\n</ul>\n<h3 id=\"（2）尾插法\"><a href=\"#（2）尾插法\" class=\"headerlink\" title=\"（2）尾插法\"></a>（2）尾插法</h3><ul>\n<li>为新插入的结点分配内存空间</li>\n<li>每次都是把插入的新结点放入表尾(尾结点位置)</li>\n<li>链表中的结点顺序与输入顺序一致</li>\n</ul>\n<h2 id=\"2-按值查找结点\"><a href=\"#2-按值查找结点\" class=\"headerlink\" title=\"2.按值查找结点\"></a>2.按值查找结点</h2><ul>\n<li>在链表中从第一个结点出发，顺指针next逐个向下搜索，直到找到第i个结点，否则返回最后一个结点的指针域NULL</li>\n</ul>\n<h2 id=\"3-按序号查找结点\"><a href=\"#3-按序号查找结点\" class=\"headerlink\" title=\"3.按序号查找结点\"></a>3.按序号查找结点</h2><ul>\n<li>从链表第一个结点开始，由前往后按照序号递增定位到相应结点的位置，返回该值，需检查序号是否越界</li>\n</ul>\n<h2 id=\"4-插入\"><a href=\"#4-插入\" class=\"headerlink\" title=\"4.插入\"></a>4.插入</h2><ul>\n<li>插入操作是将值为x的新结点插入到单链表的第i个位置</li>\n<li>先检查插入位置是否合法</li>\n<li>找到待插入位置的前驱结点</li>\n<li>在其后将结点插入<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"built_in\">getElem</span>(L, i<span class=\"number\">-1</span>)</span><br><span class=\"line\">s-next = p-next;</span><br><span class=\"line\">p-next = s;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"5-删除\"><a href=\"#5-删除\" class=\"headerlink\" title=\"5.删除\"></a>5.删除</h2><ul>\n<li>将单链表的第i个结点删除</li>\n<li>先检查插入位置是否合法</li>\n<li>找到待删除位置的前驱结点</li>\n<li>删除其后结点<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"built_in\">getElem</span>(L, i<span class=\"number\">-1</span>)</span><br><span class=\"line\">q = p-next;</span><br><span class=\"line\">q-next = p-next;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h1><ul>\n<li>双链表有两个指针prior和next，分别指向前驱和后继结点</li>\n<li>插入操作<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-next = p-next;</span><br><span class=\"line\">p-next-prior = s;</span><br><span class=\"line\">s-prior = p;</span><br><span class=\"line\">p-next = s;</span><br></pre></td></tr></table></figure></li>\n<li>删除操作<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-next = q-next;</span><br><span class=\"line\">q-next-prior = p;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h1><ul>\n<li>循环双链表和循环单链表</li>\n<li>静态链表使用数组来描述线性表的链式存储结构</li>\n</ul>\n","categories":[],"tags":[]}