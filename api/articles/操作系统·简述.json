{"title":"操作系统·简述","slug":"操作系统·简述","date":"2021-04-06T04:01:51.000Z","updated":"2024-07-01T05:21:00.160Z","comments":false,"path":"api/articles/操作系统·简述.json","photos":[],"excerpt":"","covers":["https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/os_1.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/OS_mutex.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/source_allocation.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/single_page.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/page_allocation_transform.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/add_TLB_page_allocation_transform.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/2_dim_page.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/2_dim_page_arch.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/single_seg.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/seg.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/segment_address_translation_mechanism.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/OS_page_seg_add.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/segment_page_address_translation_mechanism.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/Request_paging_page_table_mechanism.png","https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/request_paging_address_translation_mechanism.png"],"content":"<h1 id=\"第一章-计算机系统概述\"><a href=\"#第一章-计算机系统概述\" class=\"headerlink\" title=\"第一章 计算机系统概述\"></a>第一章 计算机系统概述</h1><h2 id=\"并发、共享、虚拟、异步\"><a href=\"#并发、共享、虚拟、异步\" class=\"headerlink\" title=\"并发、共享、虚拟、异步\"></a>并发、共享、虚拟、异步</h2><p>没有并发和共享，就没有虚拟和异步</p>\n<p>并发和共享互为存在条件</p>\n<p>只有系统有并发性，才能导致异步性</p>\n<h2 id=\"命令接口\"><a href=\"#命令接口\" class=\"headerlink\" title=\"命令接口\"></a>命令接口</h2><p>联机：交互式</p>\n<p>脱机：批处理</p>\n<h2 id=\"程序接口\"><a href=\"#程序接口\" class=\"headerlink\" title=\"程序接口\"></a>程序接口</h2><p>系统调用（广义指令）</p>\n<h2 id=\"操作系统用作扩充机器\"><a href=\"#操作系统用作扩充机器\" class=\"headerlink\" title=\"操作系统用作扩充机器\"></a>操作系统用作扩充机器</h2><p>没有任何软件支持的计算机称为裸机</p>\n<p>覆盖了软件的机器称为<strong>扩充机器</strong>或<strong>虚拟机</strong></p>\n<h2 id=\"操作系统发展\"><a href=\"#操作系统发展\" class=\"headerlink\" title=\"操作系统发展\"></a>操作系统发展</h2><p>手工操作系统：独占全机、CPU等待手工操作</p>\n<p>单道批处理操作系统：解决人机矛盾、CPU和I&#x2F;O设备速率不匹配、每次主机内存仅存放一道作业</p>\n<p>多道批处理操作系统：资源利用率高、用户响应时间长、不提供人机交互</p>\n<p>分时操作系统：同时、交互、独立、及时</p>\n<p>实时操作系统：及时、可靠</p>\n<p>网络操作系统</p>\n<p>分布式计算机系统</p>\n<p>个人操作系统</p>\n<h2 id=\"操作系统运行机制\"><a href=\"#操作系统运行机制\" class=\"headerlink\" title=\"操作系统运行机制\"></a>操作系统运行机制</h2><p>CPU的状态划分为用户态、核心态</p>\n<h2 id=\"中断和异常\"><a href=\"#中断和异常\" class=\"headerlink\" title=\"中断和异常\"></a>中断和异常</h2><p>中断（外中断）：CPU执行指令意外的事件【设备发出的I&#x2F;O结束中断】</p>\n<p>异常（内中断、陷入）：CPU执行指令内部的事件【非法操作码、地址越界、算术溢出、虚拟存储系统的缺页、陷入指令】</p>\n<h2 id=\"中断处理过程\"><a href=\"#中断处理过程\" class=\"headerlink\" title=\"中断处理过程\"></a>中断处理过程</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">关中断1--保存断点</span><br><span class=\"line\">保存断点--中断服务程序寻址</span><br><span class=\"line\">中断服务程序寻址--保存现场和屏蔽字</span><br><span class=\"line\">保存现场和屏蔽字--开中断1</span><br><span class=\"line\">开中断1--执行中断服务程序</span><br><span class=\"line\">执行中断服务程序--关中断2</span><br><span class=\"line\">关中断2--恢复现场和屏蔽字</span><br><span class=\"line\">恢复现场和屏蔽字--开中断2</span><br><span class=\"line\">开中断2--中断返回</span><br></pre></td></tr></table></figure></div>\n\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/os_1.png\" alt=\"os_1\"></p>\n<h2 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h2><p>用户程序中调用操作系统提供的子功能</p>\n<p>程序员可以使用高级语言，估计又要可以调用库函数，有的库函数封装了系统调用</p>\n<p>用户进程执行 调用系统调用 <strong>进入核心态</strong> 执行系统调用 <strong>退出核心态</strong> 从系统调用返回</p>\n<h2 id=\"大内核-微内核\"><a href=\"#大内核-微内核\" class=\"headerlink\" title=\"大内核 微内核\"></a>大内核 微内核</h2><p>大内核：内核代码庞大、结构混乱、难以维护、提供高性能系统服务</p>\n<p>微内核：分离内核与服务、频繁切换用户核心态、操作系统执行开销大、内核内容少、方便维护</p>\n<h1 id=\"第二章-进程管理\"><a href=\"#第二章-进程管理\" class=\"headerlink\" title=\"第二章 进程管理\"></a>第二章 进程管理</h1><p>进程:程序段、数据段、PCB进程控制块</p>\n<p>进程映像是静态的，进程是动态的</p>\n<p>动态、并发、独立、异步、结构</p>\n<h2 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h2><p>运行、就绪、阻塞、创建、结束</p>\n<h2 id=\"进程通信\"><a href=\"#进程通信\" class=\"headerlink\" title=\"进程通信\"></a>进程通信</h2><p>共享存储（需要同步互斥工具PV操作、低级：基于共享数据结构、高级：基于存储区）</p>\n<p>消息传递（进程间数据交换以格式化消息为单位、直接&#x2F;间接）</p>\n<p>管道通信（pipe文件用于连接一个读进程和写进程通信、半双工、全双工需要两条管道）</p>\n<h2 id=\"线程-多线程\"><a href=\"#线程-多线程\" class=\"headerlink\" title=\"线程 多线程\"></a>线程 多线程</h2><p>引入进程目的：更好的使多道程序<strong>并发</strong>执行</p>\n<p>引入线程目的：减小程序在并发执行付出的时空开销，提高并发性能</p>\n<p>线程：线程ID、程序计数器、寄存器结合、堆栈组合、三态【就绪、阻塞、运行】</p>\n<p>轻量实体，无系统资源，唯一ID和线程控制块</p>\n<p>用户级线程ULT：操作系统意识不到ULT的存在，有关线程管理由应用程序完成</p>\n<p>内核级线程KLT：有关线程管理由内核完成</p>\n<p>多线程模型：多对一、一对一、多对多（m&lt;&#x3D;n）</p>\n<h2 id=\"处理机调度\"><a href=\"#处理机调度\" class=\"headerlink\" title=\"处理机调度\"></a>处理机调度</h2><p>调度层次：作业调度（高）、内存调度（中）、进程调度（低）</p>\n<p>不能进行进程调度与切换：处理中断、进程处于内核态、其他需要完全屏蔽中断的原子操作</p>\n<p>调度方式：非剥夺调度（非抢占方式、适用于大多批处理系统、不能用于分时系统和大多数的实时系统）、剥夺调度（抢占方式、有优先权、短进程优先、时间片原则）</p>\n<p>调度基本原则：CPU利用率、系统吞吐量、周转时间、等待时间、响应时间</p>\n<p>系统吞吐量：单位时间内CPU完成作业的数量</p>\n<p>周转时间：从作业提交到作业完成所用时间</p>\n<p>$$<br>T&#x3D;t_{等待}+t_{就绪队列排队}+t_{上处理机运行及输入输出}\\<br>t_{周转时间}&#x3D;t_{作业完成时间}-t_{作业提交时间}\\<br>t_{平均周转时间}&#x3D;\\frac{\\sum_i^n{t_i}}{n}(作业i的周转时间：t_i)\\<br>t_{带权周转时间}&#x3D;\\frac{t_{作业周转时间}}{t_{作业实际运转}}\\geq{1}\\<br>t_{带权平均周转时间}&#x3D;\\frac{\\sum_i^n{t_i}}{n}(作业i的带权周转时间：t_i)\\<br>$$</p>\n<p>等待时间：进程处于等处理机状态的时间和</p>\n<p>响应时间：从用户提交请求到系统首次产生响应所用时间</p>\n<p><strong>调度算法</strong>：先来先服务（FCFS、非抢占）、短作业优先（SJF、SPF）、抢占式短作业优先（SRTN）、优先级调度、高响应比优先（HRRN）、时间片轮转调度（RR）、多级反馈队列调度</p>\n<p>1.先来先服务（FCFS）：简单，效率低；对长作业有利，对短作业不利；有利于CPU繁忙型作业，不利于I&#x2F;O繁忙型作业；不会导致饥饿；多用于早期批处理系统</p>\n<p>2.短作业优先（SJF、SPF）：当前已到达的最短作业先上处理机；有优先权、短进程优先、时间片原则；适用于实时&#x2F;分时操作系统；调度机制导致长作业长时间不被调度（饥饿）；多用于早期批处理系统</p>\n<p>3.抢占式短作业优先（SRTN）：最短剩余时间算法</p>\n<p>4.优先级调度：适用于实时操作系统；剥夺、非剥夺、静态优先级、动态优先级；系统进程用户进程 交互型进程非交互型进程 I&#x2F;O型进程计算型进程;不导致饥饿</p>\n<p>5.高响应比优先（HRRN）：多用于早期批处理系统</p>\n<p>$$<br>响应比R_p&#x3D;\\frac{t_{等待时间}+t_{要求服务时间}}{t_{要求服务时间}}\\geq{1}\\<br>$$</p>\n<p>6.时间片轮转调度（RR）：时间片大小设置对系统性能影响很大，时间片足够大，以至于所有进程都能在一个时间片完成，退化为先来先服务算法；时间片太小，处理机频繁在进程间切换，增加处理机开销；时间片长短由系统的响应时间、就绪队列的进程数目、系统处理能力决定；不会导致饥饿</p>\n<p>7.多级反馈队列调度：设置多个就绪队列，各个队列赋予不同优先级，赋予各个队列中进程执行时间片的大小各个不同，一个进程进入内存后挂在一级队列队尾，时间片内未完成进入第二级队列队尾，第一级队列为空下一级运行；课本认为是抢占式算法；</p>\n<h2 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h2><p>临界资源：进入区、临界区、退出区、剩余区</p>\n<p>同步：完成某种任务而建立的两个或多个进程，需要协调制约关系</p>\n<p>互斥：一个进程使用临界资源另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程允许访问临界资源</p>\n<p>为禁止两个进程进入同一个临界区，指定准则：</p>\n<p>（1）空闲让进</p>\n<p>（2）忙则等待</p>\n<p>（3）有限等待</p>\n<p>（4）让权等待</p>\n<p>实现互斥基本方法：</p>\n<p>（1）软件：单标志法（违背空闲让进）、双标志法先检查（违法忙则等待）、双标志法后检查（导致饥饿、违背空闲让进、有限等待）、皮特森算法Peterson’s Algorithm（违法让权等待）</p>\n<p>（2）硬件：中断屏蔽方法（禁止一切中断发生、优：简单高效 &#x2F; 缺：不适用多处理机、用户进程，只适用于系统内核进程）、硬件指令方法TS&#x2F;TSL（优：适用于任意数目的进程，无论是单处理机还是多处理机，简单容易验证其正确性 &#x2F; 缺：不能实现让权等待，从等待中随机选择一个进临界区，可能导致饥饿）</p>\n<p><strong>信号量</strong></p>\n<p>整型信号量：用于表示资源数目的整型量S，只要信号量S&lt;&#x3D;0，就会不断测试，违背让权等待</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">wait</span>(S)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(S &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        S = S - <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">signal</span>(S)&#123;</span><br><span class=\"line\">    S = S + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>记录型信号量：一个用于记录资源数目的整型量value，一个进程链表L，链接等待资源的进程,S.L解决了让权等待的问题</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">process</span> *L;</span><br><span class=\"line\">&#125;semaphore;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">wait</span><span class=\"params\">(semaphore S)</span></span>&#123;</span><br><span class=\"line\">    S.value --;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.value &lt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        add <span class=\"keyword\">this</span> process P to S.L;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">block</span>(S.L);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">signal</span><span class=\"params\">(semaphore S)</span></span>&#123;</span><br><span class=\"line\">    S.value ++;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.value &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        remove a process P from S.L;</span><br><span class=\"line\">        <span class=\"built_in\">wakeup</span>(P);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用信号量实现同步：前V后P，必须保证一前一后，实现同步关系</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore S = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">P1</span>()&#123;</span><br><span class=\"line\">    x;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(S);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">P2</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(S);</span><br><span class=\"line\">    y;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用信号量实现互斥：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">seamphore S = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">P1</span>()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(S);</span><br><span class=\"line\">    进程P1的临界区;</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(S);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">P2</span>()&#123;</span><br><span class=\"line\">   ...</span><br><span class=\"line\">   <span class=\"built_in\">P</span>(S);</span><br><span class=\"line\">   进程P2的临界区</span><br><span class=\"line\">   <span class=\"built_in\">V</span>(S);</span><br><span class=\"line\">   ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>利用信号量实现前驱关系：</p>\n<p>对不同的临界资源设置不同的互斥信号量，PV必须成对出现</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/OS_mutex.png\" alt=\"OS_mutex\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore a1 = a2 = b1 = b2 = c = d = e = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">S1</span>()&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(a1);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(a2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">S2</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(a1);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(b1);</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(b2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">S3</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(a2);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(c);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">S4</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(b1);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(d);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">S5</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(b2);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"built_in\">V</span>(e);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">S6</span>()&#123;</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(c);</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(d);</span><br><span class=\"line\">    <span class=\"built_in\">P</span>(e);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>另一角度：图论出度（P）入度（V）</p>\n<p><strong>管程</strong></p>\n<p>名称、共享结构数据、一组过程（函数）、设置共享结构数据初值</p>\n<p>互斥特性由编译器负责实现</p>\n<p>各外部进程&#x2F;线程，只能从管程提供的特定入口才能访问共享数据</p>\n<p>每次只允许一个进程在管程内执行某个内部过程</p>\n<p><strong>经典同步问题</strong></p>\n<p><em>1.生产者消费者问题</em></p>\n<ul>\n<li><p>一组生产者进程(Producer)</p>\n</li>\n<li><p>一组消费者进程(Consumer)</p>\n</li>\n<li><p>共享初始为空 大小为n的缓冲区(Buffer)</p>\n</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore mutex = 1;  //mutex</span><br><span class=\"line\">semaphore empty = n;  //buffer</span><br><span class=\"line\">semaphore full = 0;   //full</span><br><span class=\"line\"></span><br><span class=\"line\">Producer()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tProduce();</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tadd2Buffer();</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t\tV(full);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Consumer()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(full);</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tgetFromBuffer();</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t\tConsume();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><em>2.读者写者问题</em></p>\n<ul>\n<li>读者进程(Reader)</li>\n<li>写者进程(Writer)</li>\n<li>共享一个文档(Document)</li>\n<li>多进程读，不可多进程写</li>\n<li>写进程写，不可读</li>\n<li>写进程检查是否有读进程读</li>\n</ul>\n<p><strong>读进程优先</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 0;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">semaphore rw = 1;</span><br><span class=\"line\">Reader()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tif(count == 0)</span><br><span class=\"line\">\t\t\tP(rw);</span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t\tRead();</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tcount--;</span><br><span class=\"line\">\t\tif(count == 0)</span><br><span class=\"line\">\t\t\tV(rw);</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Writer()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(rw);</span><br><span class=\"line\">\t\twrite();</span><br><span class=\"line\">\t\tv(rw);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>写进程优先</strong></p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int count = 0;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">semaphore rw = 1;</span><br><span class=\"line\">semaphore w = 1;</span><br><span class=\"line\">Writer()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(w);</span><br><span class=\"line\">\t\tP(rw);</span><br><span class=\"line\">\t\tWrite();</span><br><span class=\"line\">\t\tV(rw);</span><br><span class=\"line\">\t\tV(w);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Reader()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(w);</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tif(count == 0)</span><br><span class=\"line\">\t\t\tP(rw);</span><br><span class=\"line\">\t\tcount++;</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t\tV(w);</span><br><span class=\"line\">\t\tRead();</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tcount--;</span><br><span class=\"line\">\t\tif(count == 0)</span><br><span class=\"line\">\t\t\tV(rw);</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><em>3.哲学家进餐问题</em></p>\n<ul>\n<li>5名哲学家(Philosopher)</li>\n<li>每两名之间有一根筷子(Chopstick)</li>\n<li>每名有一碗饭</li>\n<li>吃完饭思考</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">semaphore Chopsticks[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br><span class=\"line\">semaphore mutex = 1;</span><br><span class=\"line\">Philosopher()&#123;</span><br><span class=\"line\">\tdo&#123;</span><br><span class=\"line\">\t\tP(mutex);</span><br><span class=\"line\">\t\tP(Chopsticks[i]);</span><br><span class=\"line\">\t\tP(Chopsticks[(i+1)%5]);</span><br><span class=\"line\">\t\tV(mutex);</span><br><span class=\"line\">\t\teat();</span><br><span class=\"line\">\t\tV(Chopsticks[i]);</span><br><span class=\"line\">\t\tV(Chopsticks[(i+1)%5]);</span><br><span class=\"line\">\t\tthink();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>4.吸烟者问题</strong></p>\n<ul>\n<li>3个吸烟者进程(Smoker)</li>\n<li>1个提供者进程(Offer)</li>\n<li>Smoker1(paper, glue)</li>\n<li>Smoker2(tobacco, glue)</li>\n<li>Smoker3(paper, tobacco)</li>\n<li>Offer(offer1) return paper, glue</li>\n<li>Offer(offer2) return tobacco, glue</li>\n<li>Offer(offer3) return paper, tobacco</li>\n</ul>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int num = 0;\t//store random num</span><br><span class=\"line\">semaphore offer1 = 0;</span><br><span class=\"line\">semaphore offer2 = 0;</span><br><span class=\"line\">semaphore offer3 = 0;</span><br><span class=\"line\">semaphore end = 0;</span><br><span class=\"line\">Offer()&#123;</span><br><span class=\"line\">\twhlie(1)&#123;</span><br><span class=\"line\">\t\tnum++;</span><br><span class=\"line\">\t\tnum = num % 3;</span><br><span class=\"line\">\t\tif(num == 0)</span><br><span class=\"line\">\t\t\tV(offer1);</span><br><span class=\"line\">\t\telse if(num == 1)</span><br><span class=\"line\">\t\t\tV(offer2);</span><br><span class=\"line\">\t\telse</span><br><span class=\"line\">\t\t\tV(offer3);</span><br><span class=\"line\">\t\tP(end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Smoker1()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(offer3);</span><br><span class=\"line\">\t\tsmoke();</span><br><span class=\"line\">\t\tV(end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Smoker2()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(offer2);</span><br><span class=\"line\">\t\tsmoke();</span><br><span class=\"line\">\t\tV(end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Smoker3()&#123;</span><br><span class=\"line\">\twhile(1)&#123;</span><br><span class=\"line\">\t\tP(offer1);</span><br><span class=\"line\">\t\tsmoke();</span><br><span class=\"line\">\t\tV(end);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><em>eg1</em></p>\n<ul>\n<li>3个进程P1 P2 P3</li>\n<li>互斥使用N个单元的缓冲区(Buffer)</li>\n<li>P1 produce() return (int num) put() @Buffer</li>\n<li>P2</li>\n</ul>\n<p><strong>死锁</strong></p>\n<p>多个进程因竞争资源造成的一种互相等待，若无外力作用，这些进程都将无法向前推进</p>\n<p>死锁产生的原因：（1）系统资源的竞争（2）进程推进顺序非法（3）死锁产生的必要条件：互斥条件、不剥夺条件（已经至少保持了一个资源）、请求并保持条件、循环等待条件</p>\n<p><strong>发生死锁一定有循环等待，但发生循环等待未必死锁</strong></p>\n<p><strong>死锁的处理策略</strong></p>\n<p><strong>死锁预防</strong>：破坏四个必要条件之一即可</p>\n<ul>\n<li><p>破坏互斥条件</p>\n</li>\n<li><p>破坏不剥夺条件</p>\n</li>\n<li><p>破坏请求并保持条件</p>\n</li>\n<li><p>破坏循环等待条件</p>\n</li>\n</ul>\n<p>死锁避免：在资源分配过程，防止进入不安全状态</p>\n<ul>\n<li>银行家算法</li>\n</ul>\n<p>$$Need &#x3D; Max -Allocation$$</p>\n<p>死锁检测和解除：系统分配进程时不做措施，应该提供死锁检测和解除的手段</p>\n<ul>\n<li>资源分配图</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/source_allocation.png\" alt=\"source_allocation\"></p>\n<p>请求边：从进程到资源<br>分配边：从资源到进程</p>\n<ul>\n<li>死锁定理：依次消除与不阻塞进程相连接的边，直到无边可消除</li>\n<li>死锁解除：资源剥夺法、撤销进程法、进程回退法</li>\n</ul>\n<h1 id=\"第三章-内存管理\"><a href=\"#第三章-内存管理\" class=\"headerlink\" title=\"第三章 内存管理\"></a>第三章 内存管理</h1><p><strong>程序装入和链接</strong></p>\n<ul>\n<li>编译：编译程序将源代码编译成若干目标模块</li>\n<li>链接：链接程序将编译后形成一组目标模块及所需的库函数链接在一起，形成一个完整的装入模块</li>\n<li>装入：装入程序装入模块装入内存运行</li>\n</ul>\n<p>链接方式</p>\n<ul>\n<li>静态：程序运行前，链接为一个完整可执行的程序</li>\n<li>装入时动态：装入过程中，边装入边链接</li>\n<li>运行时动态：程序执行过程需要该模块才进行</li>\n</ul>\n<p>装入方式：</p>\n<ul>\n<li>绝对装入：仅适用于单道程序，装入程序按照装入模块中的地址，将程序数据装入内存，逻辑地址与物理地址完全相同</li>\n<li>可重定位装入（静态重定位）：一个作业装入内存，<strong>必须给它分配要求的全部内存空间</strong>，若没有足够的内存，则无法装入。一旦运行，作业进入内存，整个运行期间不能在内存中移动，也不能再申请内存空间</li>\n<li>动态运行时装入（动态重定位）：程序在内存中发生移动，则需要采用动态的装入方式。装入程序把装入内存后，并不立即将装入模块中的相对地址转换为绝对地址，而是将<strong>地址转换推迟到程序真正要执行时才进行</strong>，需要重定位寄存器的支持</li>\n</ul>\n<p>逻辑地址和物理地址</p>\n<ul>\n<li>地址重定位：当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成为物理地址</li>\n</ul>\n<p>内存保护</p>\n<ul>\n<li>在CPU中设置一堆上、下限寄存器，CPU要访问一个地址，分别和两个寄存器值相比，判断有无越界</li>\n<li>采用重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）来实现这种保护</li>\n</ul>\n<p><strong>连续分配管理方式</strong></p>\n<p>单一连续分配</p>\n<p>内存分为系统区、用户区，无需进行内存保护，内存中只允许有有一道程序</p>\n<ul>\n<li>优 简单无外部碎片</li>\n<li>缺 只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低</li>\n</ul>\n<p><strong>固定分区分配</strong></p>\n<p>将用户内存空间划分为若干固定大小的区域，每个分区只装入一道作业。当有空闲分区时，可从外存的后备作业队列中选择适当大小的作业装入</p>\n<ul>\n<li>划分分区方式：分区大小相等、分区大小不等</li>\n</ul>\n<p>问题</p>\n<ul>\n<li>程序可能太大放不进任何一块分区，用户不得不使用覆盖技术使用内存空间</li>\n<li>主存利用率低，程序小也要占用一个分区，现象称为<strong>内部碎片</strong></li>\n</ul>\n<p><strong>动态分区分配</strong></p>\n<p>又称可变分区分配，不预先划分内存，在进程装入内存时，根据进程大小动态地建立分区，并使分区的大小正好适合进程的需要</p>\n<p>问题：所有分区外的存储空间会产生越来越多的碎片，克服外部碎片可以通过紧凑技术来解决</p>\n<p>动态分区策略</p>\n<ul>\n<li><p>首次适应Fiist Fit：空闲分区以地址递增的次序链接，找到大小能满足要求的第一个空间。会使得内存的低地址部分出现很多小的空闲分区，每次分配查找时，都要经过这些分区，增加了查找的开销</p>\n</li>\n<li><p>最佳适应Best Fit：空闲分区按容量递增的方式形成分区链，找到第一个能满足要求的空间。性能通常很差，因为每次最佳的分配会留下很小难以利用的内存块，会产生最多的外部碎片。</p>\n</li>\n<li><p>最坏适应Worst Fit（最大适应Lasgest Fit）:以容量递减的次序链接，找到第一个能满足要求的空闲分区。选择最大的块，但却把最大的连续内存的划分开，会很快导致没有可用的大内存块，导致性能很差</p>\n</li>\n<li><p>邻近适用Next Fit（循环首次适应算法）：分配内存时从上次查询结束的位置开始继续查找。在一次扫描中，内存前面部分使用后再释放时，不会参与分配，导致在内存的末尾分配空间分裂为小碎片。</p>\n</li>\n</ul>\n<p><em><strong>非连续分配</strong></em> </p>\n<p><strong>基本分页存储管理方式</strong>：主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程以块为单位进行划分，进程在执行时，以块为单位逐个申请贮存中的空间</p>\n<p>分页管理不会产生外部碎片，块的大小相对分区要小，进程按块划分，进程运行时按块申请主存可用空间并执行，进程只会在最后一个不完整的块，不产生主存碎片，，每个进程平均只产生半个块大小的内部碎片</p>\n<ul>\n<li><p>页面和页面大小：进程中的块称为页（page），内存中的块称为页框（page frame、或页帧）。外存也以同样的单位进行划分，称为块（block）。进程在执行时需要申请主存空间，要为每个页面分配主存中的可用页框，页和页框一一对应</p>\n</li>\n<li><p>地址结构</p>\n</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/single_page.png\" alt=\"single_page\"></p>\n<ul>\n<li>页表：通过查找页表即可找到相应的物理块</li>\n</ul>\n<p>基本地址变换：</p>\n<p>将逻辑地址变换为内存中的物理地址，在系统中设置页表寄存器（PTR）存放内存起始地址F和页表长度M。</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/page_allocation_transform.png\" alt=\"page_allocation_transform\"></p>\n<p>$$<br>\\begin{aligned}<br>&amp;（1）页号P&#x3D;\\frac{A}{L}\\<br>&amp;（2）页内偏移量W&#x3D;A%L\\<br>&amp;（3）比较页号P和页表长度M，P\\geq M产生越界中断\\<br>&amp;（4）页表中页号P对应的页表项地址A&#x3D;F+P<em>M\\<br>&amp;（5）物理地址E&#x3D;b</em>L+W\\<br>\\end{aligned}<br>$$<br><em>页式管理中空间地址是一维的</em></p>\n<p>问题</p>\n<ul>\n<li>每次访存均需地址变换，地址变换必须足够快，否则访存速度会降低</li>\n<li>每个进程引入页表，用于存储映射机制，页表不能过大</li>\n</ul>\n<p>引入快表机制：在地址变换过程中加入具有并行查找能力的高速缓冲存储器——<strong>快表</strong>（相联存储器TLB，主存中的页表为<strong>慢表</strong>）</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/add_TLB_page_allocation_transform.png\" alt=\"add_TLB_page_allocation_transform\"></p>\n<p>一次地址变换流程</p>\n<p>（1）CPU给出逻辑地址，将页号送入高速缓冲寄存器，查询此页号是否存在于快表内</p>\n<p>（2）若匹配到，直接取出对应页的页框号，与页内偏移拼接为物理地址，访存</p>\n<p>（3）若未匹配到，访问慢表查询，读取页表项后复制到快表中，进行地址变换后访存</p>\n<p><em>值得注意的是，题中是否说明快表初始为空以及快表慢表的查询机制，是否同时查询！</em></p>\n<p>两级页表</p>\n<ul>\n<li>引入页表，执行时不需要调入所有内存页框，为了压缩页表，采取多级映射</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/2_dim_page.png\" alt=\"2_dim_page\"></p>\n<ul>\n<li>多级页表大小不能超过一个页面</li>\n</ul>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/2_dim_page_arch.png\" alt=\"2_dim_page_arch\"></p>\n<p>$$<br>\\begin{aligned}<br>&amp;逻辑地址：32bit\\<br>&amp;以字节编址\\<br>&amp;页表项：4B\\<br>&amp;页面大小：4KB&#x3D;2^{12}B （页内偏移量）\\<br>&amp;页号：32-12&#x3D;20\\<br>&amp;全映射需要2^{20}个页表项\\<br>&amp;共需4B<em>2^{20}&#x3D;4MB大小空间存储页表\\<br>&amp;\\<br>&amp;以40MB进程为例\\<br>&amp;页表项：\\frac{40MB}{4B</em>4KB}&#x3D;40KB\\<br>&amp;需要\\frac{40KB}{4KB}&#x3D;10页面\\<br>&amp;整个进程需要\\frac{40MB}{4KB}&#x3D;10*2^{10}个页面\\<br>&amp;\\<br>&amp;为了压缩页表，采取二级页表机制\\<br>&amp;页表10页进行映射只需要10个页表项\\<br>&amp;上一级页表只需要1页就已经足够2^{10}&#x3D;1024个页表项\\<br>&amp;进程执行时，仅需将这一页的上级页表调入即可\\<br>&amp;页面大小：4KB&#x3D;2^{12}B （页内偏移量）\\<br>&amp;页号：32-12&#x3D;20\\<br>&amp;顶级（一级）页表为1个页面\\<br>&amp;一级页表项\\frac{4KB}{4B}&#x3D;1K\\<br>&amp;一级页表占用log_2{1K}&#x3D;10位\\<br>&amp;二级页表占用20-10&#x3D;10位\\<br>&amp;二级页表大小2^{10}*4B&#x3D;4KB\\leq页面大小4KB\\<br>\\end{aligned}<br>$$</p>\n<p><strong>基本分段存储管理方式</strong></p>\n<p>分页管理是从计算机角度考虑设计，提高内存利用率，分页通过硬件机制实现</p>\n<p>分段管理是从用户和程序员出发，方便编程、信息保护和共享、动态增长以及动态链接等方面的需要</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/single_seg.png\" alt=\"single_seg\"></p>\n<p>段号决定每个进程最多可以分几个段，段内地址决定每个段内的最大长度</p>\n<p>段表：每个进程都有一张逻辑空间与内存空间映射的段表</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/seg.png\" alt=\"seg\"></p>\n<p>地址变换机构</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/segment_address_translation_mechanism.png\" alt=\"分段地址变换机构\"></p>\n<p>$$<br>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W\\<br>比较段号S和段表长度M，S\\geq M,产生越界中断，否则继续执行\\<br>段表中段号S对应段表项地址&#x3D;段表始址F+段号S*段表项长度\\<br>段内偏移量\\geq C，产生越界中断，否则继续执行\\<br>取出段表项中该段的起始地址b，E&#x3D;b+W，得到物理地址E去访问内存\\<br>$$</p>\n<p>段的共享与保护：分段系统，通过两个作业的段表中相应表项指向被共享的段同一个物理副本，当地一个作业从共享段读取数据，必须防止另一个修改数据，不能修改的的代码称为<strong>纯代码、可重入代码</strong></p>\n<p>段号和段内偏移需要显示给出，地址空间为二维</p>\n<p><strong>段页式管理方式</strong></p>\n<p>作业的地址空间被分为若干逻辑段，每段都有自己的段号，将每段分为若干大小的固定的页，内存空间分为若干和页面大小相同的存储块，对内存的分配以块为单位。</p>\n<ul>\n<li><p>段号位数决定每个进程最多可以分几个段</p>\n</li>\n<li><p>页号位数决定最多有几个页</p>\n</li>\n<li><p>页内偏移量决定页面大小、内存块的大小</p>\n</li>\n</ul>\n<p>段页式系统的逻辑地址结构：</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/OS_page_seg_add.png\" alt=\"OS_page_seg_add\"></p>\n<p>地址变换</p>\n<p>需要三次访存，可以使用快表机制</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/segment_page_address_translation_mechanism.png\" alt=\"segment_page_address_translation_mechanism\"></p>\n<p><strong>虚拟内存管理</strong></p>\n<p>传统存储管理方式</p>\n<ul>\n<li>一次性：一次全部装入，才能开始</li>\n<li>驻留性：装入后，常驻内存，任何部分都不会被换出，直至结束</li>\n</ul>\n<p>局部性原理</p>\n<p>一个程序，一段时间内，只有一部分会被访问</p>\n<ul>\n<li>空间</li>\n<li>时间</li>\n</ul>\n<p>虚拟存储器</p>\n<p>将程序的一部分装入内存，其余部分留在外存，当所访问的部分不在内存，操作系统将需要的部分调入内存，将暂时不需要的内容换到外存</p>\n<ul>\n<li>多次性：无需一次全部装入，允许分为多次调入</li>\n<li>对换性：无需常驻内存</li>\n<li>虚拟性：从逻辑上扩充内存容量，使用户看到的内存容量远大于内存容量</li>\n</ul>\n<p>本质：用时间换空间</p>\n<p>实现：请求分页、请求分段、请求段页式</p>\n<p>支持：内存、外存、页表机制、段表机制、中断机构、地址变换机构</p>\n<p><strong>请求分页管理方式</strong></p>\n<p>访问不存在内存中的页面，通过调页将其调入，通过置换算法将暂时不需要的页面调到外存上</p>\n<p>页表机制</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/Request_paging_page_table_mechanism.png\" alt=\"Request_paging_page_table_mechanism\"></p>\n<p>$$<br>状态位P：指示是否调入内存\\<br>访问字段A：记录一段时间内被访问的次数\\<br>修改位M：标识页面调入内存后是否被修改过\\<br>外存地址：指出该页在外存上的地址，通常是物理块号\\<br>$$</p>\n<p>缺页中断机制</p>\n<p>访问页面不在内存中时，产生一个缺页中断，请求操作系统将缺页调入内存，将缺页的进程阻塞，若内存有闲置的空闲块，则分配一个块，将页面装入，并修改页表相应的页表项，若内存中无空闲块，则淘汰某页，淘汰页若在内存中修改过需要同步，写回外存</p>\n<p>地址变换机构</p>\n<p><img src=\"https://raw.githubusercontent.com/blueflylabor/blueflylabor/main/imgs/OS/request_paging_address_translation_mechanism.png\" alt=\"request_paging_address_translation_mechanism\"></p>\n<p>页面置换算法</p>\n<ul>\n<li>最佳置换算法OPT</li>\n</ul>\n<p>选择的被淘汰页是以后永不使用的页面，或是最长时间内不再被访问的页面</p>\n<ul>\n<li>先进先出算法FIFO</li>\n</ul>\n<p>优先淘汰最早进入内存的页面，即内存中驻留时间最久的页面</p>\n<p>会产生所分配的物理块增大页故障数不减反增的异常现象，<strong>Belady异常</strong></p>\n<ul>\n<li>最近最久未使用算法LRU</li>\n</ul>\n<p>选择最近最长时间未访问过的页面予以淘汰，为每个页面设置一个访问字段记录上次被访问所经历的时间</p>\n<p>性能较好，需要寄存器和栈的硬件支持</p>\n<ul>\n<li>时钟置换算法CLOCK</li>\n</ul>\n<p>简单的CLOCK算法：每帧关联一个附加位，使用位<strong>u</strong>，连成一个循环队列。某页装入时，使用位置为1；被访问时，使用位置为1；置换时，操作系统扫描缓冲区，每当遇到一个使用位为1的帧，置为0；最后停留在第一个使用位为0的帧</p>\n<p>CLOCK算法性能比较接近LRU算法</p>\n<p>改进的CLOCK算法：再增加一个修改位<strong>m</strong>，<strong>P(u,m)</strong></p>\n<p>第一轮扫描，指针扫描过的页面使用位<strong>u</strong>置为0</p>\n<p>第一轮扫描中，未找到使用位<strong>u</strong>为0的页面进行第二轮扫描</p>\n<p>第二轮扫描，第一个页面置换出，换入页面<strong>m</strong>修改位置为1，并将指针后移</p>\n<p><strong>页面分配策略</strong></p>\n<p>一个进程分配的物理页框的集合，分配给一个进程的存储量越小，任何时候驻留在主存中的进程数就越多，从而提高处理机的效率；一个进程页数过少，基于局部性原理，页错误率会相对较高；页数过多，基于局部性原理，给特定的进程分配更多主存空间对该进程的错误率没有明显改善。</p>\n<p>策略：固定分配局部置换、可变分配全局置换、可变分配局部置换（没有固定分配全局分配）</p>\n<p>调入时机：预调页策略、请求调页策略</p>\n<p>从何处调页：系统拥有足够的对换区间、系统缺少足够的对换区间、UNIX方式</p>\n<p><strong>抖动</strong></p>\n<p>某进程频繁访问的页面数目高于可用的物理页帧数目</p>\n<p><strong>工作集</strong></p>\n<p>在某段时间间隔内，进程要访问的页面集合</p>\n<p>一般，分配给进程的物理块数（驻留集大小）要大于工作集大小</p>\n<h1 id=\"第四章-文件系统\"><a href=\"#第四章-文件系统\" class=\"headerlink\" title=\"第四章 文件系统\"></a>第四章 文件系统</h1><p><strong>文件</strong></p>\n<p>文件结构：数据项、记录、文件</p>\n<p>属性：名称、标识符、类型、位置、大小、保护、时间</p>\n<p>所有文件的信息都保存在目录结构中，而目录结构保存在外存上，文件信息在需要时调入内存。</p>\n<p>基本操作：创建、写、读、重定位、删除、截断</p>\n<p>文件逻辑结构</p>\n<ul>\n<li>无结构文件（流式文件）</li>\n</ul>\n<p>二进制式字符流组成</p>\n<ul>\n<li>有结构文件（记录式文件）</li>\n</ul>\n<p>顺序文件</p>\n<p>索引文件</p>\n<p>索引顺序文件</p>\n<p>直接文件或散列文件</p>\n<p><strong>目录结构</strong></p>\n","categories":[],"tags":[]}