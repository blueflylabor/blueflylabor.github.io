{"total":33,"pageSize":10,"pageCount":4,"data":[{"title":"数据结构·查找算法","slug":"数据结构·查找算法","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.319Z","comments":false,"pin":null,"path":"api/articles/数据结构·查找算法.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"查找\"><a href=\"#查找\" class=\"headerlink\" title=\"查找\"></a>查找</h1><h2 id=\"1-顺序查找\"><a href=\"#1-顺序查找\" class=\"headerlink\" title=\"1.顺序查找\"></a>1.顺序查找</h2><h3 id=\"一般表\"><a href=\"#一般表\" class=\"headerlink\" title=\"一般表\"></a>一般表</h3><p>（1）代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">    ElemType *elem;</span><br><span class=\"line\">    <span class=\"type\">int</span> tableLen;</span><br><span class=\"line\">&#125;SSTable;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">searchSeq</span><span class=\"params\">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class=\"line\">    ST.elem[e] = key;   <span class=\"comment\">//设置哨兵</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i&lt;ST.tableLen; i++)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i;   <span class=\"comment\">//存在返回, 不存在返回1</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（2）设置哨兵：可以不必判断是否越界，注意数据下表从1开始<br>（3）ASL<br>$$<br>如果不能知道查找概率，可先对记录的查找概率进行排序，是表中的记录按查找概率从小到大\\<br>ASL_{success} &#x3D; \\sum_{i&#x3D;1}^{n} P_i(n-i+1) &#x3D; \\frac{n+1}{2}\\<br>ASL_{unsuccess} &#x3D; n+1\\<br>$$<br>（4）优缺点<br>优点：对数据的存储无要求，顺序存储或者链式存储皆可<br>缺点：当n较大，平均查找长度较大，效率低</p>\n<h3 id=\"有序表\"><a href=\"#有序表\" class=\"headerlink\" title=\"有序表\"></a>有序表</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">id1((10))--id2((20))</span><br><span class=\"line\">id1((10)).--infinity,10</span><br><span class=\"line\">id2((20))--id3((30))</span><br><span class=\"line\">id2((20)).--infinity,20</span><br><span class=\"line\">id3((30))--id4((40))</span><br><span class=\"line\">id3((30)).--infinity,30</span><br><span class=\"line\">id4((40))--id5((50))</span><br><span class=\"line\">id4((40)).--infinity,40</span><br><span class=\"line\">id5((50))--id6((60))</span><br><span class=\"line\">id5((50)).--infinity,50</span><br><span class=\"line\">id6((60))--60,=</span><br><span class=\"line\">id6((60)).--infinity,60</span><br></pre></td></tr></table></figure></div>\n<p>（1）一旦查到某个元素大于该元素便停止查找<br>（2）方框是虚构的节点，查找长度&#x3D;方框上的圆环<br>（3)ASL<br>$$<br>ASL_{success} &#x3D; \\sum_{i&#x3D;1}^{n} P_i(n-i+1) &#x3D; \\frac{n+1}{2}\\<br>ASL_{unsuccess} &#x3D; \\sum_{j&#x3D;1}^{n} Q_j(l_j-1) &#x3D;  \\frac{1+2+…+n+n}{n+1} &#x3D; \\frac{n}{2} +  \\frac{n}{n+1}\\<br>$$</p>\n<h3 id=\"折半查找（二分查找）\"><a href=\"#折半查找（二分查找）\" class=\"headerlink\" title=\"折半查找（二分查找）\"></a>折半查找（二分查找）</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">id29((29))--id37((37))--id41((41))--id43((43))</span><br><span class=\"line\">id43((43))--43,+infinity</span><br><span class=\"line\">id43((43))--37,43</span><br><span class=\"line\">id37((37))--id32((32))--id33((33))</span><br><span class=\"line\">id32((32))--29,32</span><br><span class=\"line\">id33((33))--33,37</span><br><span class=\"line\">id33((33))--32,33</span><br><span class=\"line\">id13((13))--id16((16))--id19((19))--19,29</span><br><span class=\"line\">id19((19))--16,19</span><br><span class=\"line\">id29((29))--id13((13))--id7((7))--id10((10))--10,13</span><br><span class=\"line\">id10((10))--7,10</span><br><span class=\"line\">id7((7))---infinity,7</span><br></pre></td></tr></table></figure></div>\n<p>（1）仅适用于顺序表<br>（2）代码</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">binarySearch</span><span class=\"params\">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> low, high, mid = <span class=\"number\">0</span>, L.tableLen, <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(low &lt;= high)&#123;</span><br><span class=\"line\">        mid = (low + high) / <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(L.elem[mid] == key)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(L.elem[mid]  key)</span><br><span class=\"line\">            high = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>（3）ASL<br>$$<br>ASL &#x3D; \\frac{1}{n}\\sum_{i&#x3D;1}^{n} l_i &#x3D; \\frac{1}{n}(1<em>1+2</em>2+…+h*2^{h-1}) &#x3D; \\frac{n+1}{n} log_2(n+1)-1 &#x3D; log_2(n+1)-1\\<br>h&#x3D;[log_2(n+1)]（向上取整）<br>$$</p>\n<h4 id=\"查找11\"><a href=\"#查找11\" class=\"headerlink\" title=\"查找11\"></a>查找11</h4><h5 id=\"low-7-high-43-mid-29\"><a href=\"#low-7-high-43-mid-29\" class=\"headerlink\" title=\"low&#x3D;7, high&#x3D;43, mid&#x3D;29\"></a>low&#x3D;7, high&#x3D;43, mid&#x3D;29</h5><h5 id=\"11\"><a href=\"#11\" class=\"headerlink\" title=\"11&lt;29\"></a>11&lt;29</h5><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph </span><br><span class=\"line\">7--low</span><br><span class=\"line\">10</span><br><span class=\"line\">13</span><br><span class=\"line\">16</span><br><span class=\"line\">19</span><br><span class=\"line\">29--mid</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">37</span><br><span class=\"line\">41</span><br><span class=\"line\">43--high</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<h5 id=\"low-7-high-mid-1-19-mid-13\"><a href=\"#low-7-high-mid-1-19-mid-13\" class=\"headerlink\" title=\"low&#x3D;7, high&#x3D;mid-1&#x3D;19, mid&#x3D;13\"></a>low&#x3D;7, high&#x3D;mid-1&#x3D;19, mid&#x3D;13</h5><h5 id=\"11-1\"><a href=\"#11-1\" class=\"headerlink\" title=\"11&lt;13\"></a>11&lt;13</h5><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph </span><br><span class=\"line\">7--low</span><br><span class=\"line\">10</span><br><span class=\"line\">13--mid</span><br><span class=\"line\">16</span><br><span class=\"line\">19--high</span><br><span class=\"line\">29</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">37</span><br><span class=\"line\">41</span><br><span class=\"line\">43</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h5 id=\"low-7-high-mid-1-7-mid-10\"><a href=\"#low-7-high-mid-1-7-mid-10\" class=\"headerlink\" title=\"low&#x3D;7, high&#x3D;mid-1&#x3D;7, mid&#x3D;10\"></a>low&#x3D;7, high&#x3D;mid-1&#x3D;7, mid&#x3D;10</h5><h5 id=\"117\"><a href=\"#117\" class=\"headerlink\" title=\"117\"></a>117</h5><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph </span><br><span class=\"line\">7--low--mid</span><br><span class=\"line\">10--high</span><br><span class=\"line\">13</span><br><span class=\"line\">16</span><br><span class=\"line\">19</span><br><span class=\"line\">29</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">37</span><br><span class=\"line\">41</span><br><span class=\"line\">43</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<h5 id=\"low-mid-1-10-high-10-mid-10\"><a href=\"#low-mid-1-10-high-10-mid-10\" class=\"headerlink\" title=\"low&#x3D;mid+1&#x3D;10, high&#x3D;10, mid&#x3D;10\"></a>low&#x3D;mid+1&#x3D;10, high&#x3D;10, mid&#x3D;10</h5><h5 id=\"1010-×\"><a href=\"#1010-×\" class=\"headerlink\" title=\"1010 ×\"></a>1010 ×</h5><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph </span><br><span class=\"line\">7</span><br><span class=\"line\">10--low--mid--high</span><br><span class=\"line\">13</span><br><span class=\"line\">16</span><br><span class=\"line\">19</span><br><span class=\"line\">29</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">37</span><br><span class=\"line\">41</span><br><span class=\"line\">43</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<h5 id=\"没找到，停在low\"><a href=\"#没找到，停在low\" class=\"headerlink\" title=\"没找到，停在low\"></a>没找到，停在low</h5><h3 id=\"分块查找\"><a href=\"#分块查找\" class=\"headerlink\" title=\"分块查找\"></a>分块查找</h3><p>（1）将查找表分为若干子块，块内可以无序，但块之间有序的</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph </span><br><span class=\"line\">id24((24))--id((索引块24,54,78,88))</span><br><span class=\"line\">id21((21))</span><br><span class=\"line\">id6((6))</span><br><span class=\"line\">id11((11))</span><br><span class=\"line\">id8((8))</span><br><span class=\"line\">id22((22))</span><br><span class=\"line\">id32((32))--id((索引块24,54,78,88))</span><br><span class=\"line\">id31((31))</span><br><span class=\"line\">id54((54))</span><br><span class=\"line\">id72((72))--id((索引块24,54,78,88))</span><br><span class=\"line\">id61((61))</span><br><span class=\"line\">id78((78))</span><br><span class=\"line\">id88((88))--id((索引块24,54,78,88))</span><br><span class=\"line\">id83((83))</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<p>（2）ASL<br>$$<br>n:长度\\<br>b:分块个数\\<br>s:每块s个记录\\<br>P:等概率\\<br>ASL &#x3D; L_I+L_S &#x3D; \\frac{b+1}{2}+\\frac{s+1}{2}&#x3D;\\frac{s^2+2s+n}{2s}\\<br>s&#x3D;\\sqrt{n},ASL&#x3D;\\sqrt{n}+1\\<br>采用折半查找：ASL&#x3D;L_I+L_S&#x3D;[log_2(b+1)]+\\frac{s+1}{2}（向上取整）<br>$$</p>\n<p>###B树（多路平衡查找树）<br>$$<br>m阶B树或空树\\<br>每棵子树至多m棵子树，最多包含m-1个关键字\\<br>若根节点不是终端节点，至少两棵子树\\<br>除根结点外所有非叶节点至少[\\frac{m}{2}]（向上取整）棵子树（关键字）\\<br>$$</p>\n<div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph </span><br><span class=\"line\">id[22]--id0[5,11]</span><br><span class=\"line\">id[22]--id1[36,45]</span><br><span class=\"line\">id0[5,11]--id00[1,3]</span><br><span class=\"line\">id0[5,11]--id01[6,8,9]</span><br><span class=\"line\">id0[5,11]--id02[13,15]</span><br><span class=\"line\">id1[36,45]--id10[30,35]</span><br><span class=\"line\">id1[36,45]--id11[40,42]</span><br><span class=\"line\">id1[36,45]--id12[47,48,50,56]</span><br></pre></td></tr></table></figure></div>","text":"查找1.顺序查找一般表（1）代码1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>typedef struct&#123;<br>    ElemType *elem;<br>    int tableLen;<br>&#125","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"数据结构·基本概念","slug":"数据结构·基本概念","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.311Z","comments":false,"pin":null,"path":"api/articles/数据结构·基本概念.json","excerpt":"","keywords":null,"cover":null,"content":"<p> Data Structure Notes</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Author : <span class=\"string\">&quot;blueflylabor&quot;</span></span><br><span class=\"line\">Version : <span class=\"number\">1.0</span></span><br><span class=\"line\">Refresh Date <span class=\"number\">2020.11</span><span class=\"number\">.26</span></span><br><span class=\"line\">Description : </span><br><span class=\"line\">Just record <span class=\"keyword\">and</span> review some points about Data Structure.</span><br><span class=\"line\">Have mistakes that please correct it yourself.</span><br></pre></td></tr></table></figure>\n\n<p> 数据结构的基本概念</p>\n<p>  1.数据</p>\n<p>  2.数据元素：</p>\n<p>   数据的基本单位，一个数据元素可有若干个数据项构成，数据项是不可分割的最小单位</p>\n<p>  3.数据类型</p>\n<p>  4.抽象数据类型(ADT[Abstract Data Type]):</p>\n<p>  数学模型在计算机的一种实现，包括数据对象、数据关系、基本操作，如建立一个有限状态机模型</p>\n<p>  5.数据结构：数据元素之间的关系称之为结构，数据结构包括三方面：逻辑结构、存储结构、数据运算(程序&#x3D;算法+数据结构)</p>\n<p>  6.逻辑结构：数据间的逻辑关系，与数据存储独立，分为线性结构和非线性结构</p>\n  <div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"PLAINTEXT\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph TD</span><br><span class=\"line\">逻辑结构--线性结构</span><br><span class=\"line\">逻辑结构--非线性结构</span><br><span class=\"line\">线性结构--一般线性表</span><br><span class=\"line\">线性结构--受限线性表</span><br><span class=\"line\">线性结构--线性表推广</span><br><span class=\"line\">受限线性表--栈和队列</span><br><span class=\"line\">受限线性表--串</span><br><span class=\"line\">线性表推广--数组</span><br><span class=\"line\">线性表推广--广义表</span><br><span class=\"line\">非线性结构--非线性表</span><br><span class=\"line\">非线性表--集合</span><br><span class=\"line\">非线性表--树形结构</span><br><span class=\"line\">非线性表--图形结构</span><br><span class=\"line\">树形结构--一般树</span><br><span class=\"line\">树形结构--二叉树</span><br><span class=\"line\">图形结构--有向图</span><br><span class=\"line\">图形结构--无向图</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<p>  7.物理结构：数据元素的表示以及关系的表示，主要有：顺序存储、链式存储、索引存储、散列存储</p>\n<p>  8.算法评估</p>\n<p>  （1）特性：有穷、确定、可行、输入、输出</p>\n<p>  （2）时间复杂度：衡量算法随问题规模的增大，算法执行的时间增长的快慢</p>\n<p>   T(n)&#x3D;O(f(n))，f(n)为算法运算频度，一般采用最坏情况下的时间复杂度</p>\n<p>   计算方法：取算法时间增长最快的函数项，忽略其系数</p>\n<p>   a加法规则：</p>\n<pre><code>$$\nT(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))\n$$\n\n多项式相加，只保留最高阶的项，且系数变为1\n</code></pre>\n<p>   b乘法规则：</p>\n<pre><code>$$\nT(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))\n$$\n\n多项式相乘，都保留\n</code></pre>\n<p>   从左到右性能依次降低：</p>\n<pre><code>$$\nO(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)\n$$\n</code></pre>\n<p>   单循环体型：</p>\n<pre><code>例题1：计算下列程序的时间复杂度\n\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i,sum\t<span class=\"comment\">//执行1次</span></span><br><span class=\"line\">sum=<span class=\"number\">0</span>\t<span class=\"comment\">//执行1次</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;=n;i++)<span class=\"comment\">//int i=0执行1次，i&lt;=n执行n+2次，i++执行n+1次</span></span><br><span class=\"line\">\tsum+=i;\t<span class=\"comment\">//执行n+1次</span></span><br></pre></td></tr></table></figure>\n\n时间分析： 该算法执行了3n+6个语句。 假设每个语句执行时间一致，均为常数t。则总时间 \n$$\nT=(3n+6)*t\n$$\n随着问题规模n的增大，总时间的增长率与n的增长率一致，所以复杂度为\n$$\nO(n)\n$$\n\n\n结论： \n\n 复杂度是关于增长率的，所以可以直接忽视常数项\n\n  一般可以直接关注循环段基本操作语句\n\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sum+=i;</span><br></pre></td></tr></table></figure>\n \n  \n\n 的执行次数\n</code></pre>\n<p>   例题2：</p>\n   <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> sum,i;</span><br><span class=\"line\">sum=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">1</span>;i &lt;= n;i=<span class=\"number\">2</span>*i)&#123;</span><br><span class=\"line\">\tsum=sum+i;</span><br></pre></td></tr></table></figure>\n<p>   时间分析：</p>\n<p>   i 取值：1,2,4,8…<br>   满足条件：2^𝑘 ≤ n<br>   K𝑙𝑜𝑔_2𝑛时， 跳出循环<br>   所以循环体执行次数：⌈𝑙𝑜𝑔_2𝑛⌉ 故时间复杂度为O(logn).i 取值：1,2,4,8</p>\n<p>  多循环体型</p>\n<p>  两个运算法则：乘法规则（嵌套循环）、加法规则（若干循环）</p>\n<p>  例题3：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x,y,i,j;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\tx++;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;=n;j++)</span><br><span class=\"line\">\t\ty++;</span><br></pre></td></tr></table></figure>\n<p>  两个循环体是独立的，采用加法规则：<br>  $$<br>  T(n)&#x3D;T_1(n)+T_2(n)<br>  $$</p>\n<p>  $$<br>  &#x3D;max(T_1(n),T_2(n)) &#x3D;O(n^2)<br>  $$</p>\n<p>  例题4：</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i,j,sum;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i=<span class=\"number\">1</span>;i&lt;=n;i++)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(j=<span class=\"number\">1</span>;j&lt;=n;j=<span class=\"number\">2</span>*j)</span><br><span class=\"line\">\t\tsum=sum+j;</span><br></pre></td></tr></table></figure>\n<p>  两个循环体是嵌套的，采用乘法规则：</p>\n<p>  $$<br>  T(n)&#x3D;T_1(n)*T_2(n)<br>  $$</p>\n<p>  $$<br>  &#x3D;O(nlogn)<br>  $$</p>\n<p>  （3）空间复杂度：衡量算法随问题规模的增大，算法所需空间的快慢</p>\n<p>   S(n)&#x3D;O(g(n))，算法所需空间的增长率和g(n)的增长率相同</p>\n<p>   空间复杂度S(n)指算法运行过程中所使用的辅助空间的大小</p>\n<p>线性表</p>\n<p> 1.定义：线性表是具有相同数据类型的n个数据类型的有限序列，n为表长</p>\n<p> 线性表中第一个元素称为表头元素，最后一个元素称为表位元素</p>\n<p> 除第一个元素外，每个元素仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继</p>\n<p>顺序存储</p>\n<p>线性表的顺序存储又称顺序表</p>\n<p>使用一组地址连续的存储单元(数组等)依次存储线性表的数据元素，从而使得逻辑相邻的两个元素在物理位置上也相邻</p>\n<p>三个属性：</p>\n<p> 1.存储空间的起始位置</p>\n<p> 2.顺序表最大存储容量</p>\n<p> 3.顺序表当前的长度</p>\n<p>宏定义</p>\n<p>静态分配大小</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 100</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Elemtype</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">Elemtype elem[MaxSize];</span><br><span class=\"line\"><span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n\n<p>动态分配大小(这里动态指空间大小运行时决定，但分配大小后，空间大小被固定)</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Elemtype</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span>&#123;</span><br><span class=\"line\">Elemtype *elem;</span><br><span class=\"line\"><span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br></pre></td></tr></table></figure>\n\n<p>优点：访问效率高、存储密度高</p>\n<p>缺点：插入删除操作复杂</p>\n<p>顺序存储线性表操作</p>\n<p>1.初始化顺序存储线性表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">initLinklist</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">\tL.elem=<span class=\"keyword\">new</span> Elemtype[MaxSize];</span><br><span class=\"line\"><span class=\"keyword\">if</span>(!L.elem)</span><br><span class=\"line\">   <span class=\"built_in\">exit</span>(OVERFLOWS);</span><br><span class=\"line\">L.length=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（1）创建一个顺序存储表后，需要初始化，首先根据数组大小通过new在堆空间开辟一段连续的空间赋值于先前创建的顺序存储表的elem空间</p>\n<p>（2）检查elem是否存在，不存在溢出退出程序</p>\n<p>（3）将length元素赋值为0，即设置顺序存储线性表长度为0</p>\n<p>2.销毁顺序存储线性表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">destroyList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(L.elem)</span><br><span class=\"line\">   <span class=\"built_in\">delete</span>(L.elem);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果线性表存在，删除线性表elem开辟的空间</p>\n<p>3.清空顺序存储线性表</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">clearList</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\">L.length=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>将线性表的长度置为0</p>\n<p>4.判断顺序存储线性表是否为空</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEmpty</span><span class=\"params\">(SqList &amp;L)</span></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(L.length==<span class=\"number\">0</span>)</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>判断线性表长度是否为0，并返回相应bool值</p>\n<p>5.引用类型按下表获取顺序存储线性表元素</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getElem</span><span class=\"params\">(SqList L,<span class=\"type\">int</span> i,type&amp;e)</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>||iL.length)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\"> e=L.elem[i<span class=\"number\">-1</span>];</span><br><span class=\"line\"> <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> （1）先检查传递参数下标量是否正确</p>\n<p> （2）通过访问elem内数据存入引用类型变量内</p>\n<p>6.按下表获取顺序存储线性表元素</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Elemtype <span class=\"title\">getElem</span><span class=\"params\">(SqList L,<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>||iL.length)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> L.elem[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> （1）先检查传递参数下标量是否正确</p>\n<p> （2）通过访问elem内数据并返回</p>\n<p>7.引用类型按值查询顺序存储线性表元素下标</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">locateElem</span><span class=\"params\">(SqList L,Elemtype e,<span class=\"type\">int</span> &amp;i)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;L.length;i++)</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(L.elem[i]==e)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量赋值于引用类型下标变量</p>\n<p>8.按值获取顺序存储线性表元素下标</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">locateElem</span><span class=\"params\">(SqList L,Elemtype e)</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;L.length;i++)</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(L.elem[i]==e)</span><br><span class=\"line\">         <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> 按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量返回</p>\n<p>9.按下标插入元素</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">listInsert</span><span class=\"params\">(SqList &amp;L,type e,<span class=\"type\">int</span> i)</span></span>&#123;</span><br><span class=\"line\"> <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">1</span>||iL.length)</span><br><span class=\"line\">     <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\"> ++L.length;</span><br><span class=\"line\"> <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=L.length<span class=\"number\">-1</span>;j=i<span class=\"number\">-1</span>;j--)</span><br><span class=\"line\">     L.elem[j+<span class=\"number\">1</span>]=L.elem[j];</span><br><span class=\"line\"> L.elem[i<span class=\"number\">-1</span>]=e;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> （1）先检查传递参数下标量是否正确</p>\n<p> （2）增加线性表长度</p>\n<p> （3）按照目标元素位置，将其尾部元素后移1偏移量</p>\n<p> （4）将目标元素存入下标位置</p>\n<p> <strong>时间复杂度分析:</strong></p>\n<p>  （1）<br>  $$<br>  最好情况：在表尾插入(即i&#x3D;n+1)<br>  $$</p>\n<p>  $$<br>  元素后移语句执行的时间复杂度为O(1)<br>  $$</p>\n<p>  （2）<br>  $$<br>  最坏情况：在表头插入(即i&#x3D;1)<br>  $$</p>\n<p>  $$<br>  元素后移语句执行n次，时间复杂度为O(n)<br>  $$</p>\n<p>  （3）<br>  $$<br>  平均情况：假设p_i(p_i&#x3D;1&#x2F;(n+1))<br>  $$</p>\n<p>  $$<br>  是第i个位置上插入一个结点的概率<br>  $$</p>\n<p>  $$<br>  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>  $$</p>\n<p>  $$<br>  \\begin{equation*}</p>\n<p>  f &#x3D; \\sum_{i&#x3D;1}^{n+1}p_i(n-i-1)</p>\n<p>  \\end{equation*}<br>  $$</p>\n<p>  $$<br>  \\begin{equation*}</p>\n<p>  &#x3D;\\sum_{i&#x3D;1}^{n+1}{\\frac{n+1}{n-i+1}}</p>\n<p>  \\end{equation*}<br>  $$</p>\n<p>  $$<br>  \\begin{equation*}</p>\n<p>  &#x3D;\\frac{1}{n+1} \\sum_{i&#x3D;1}^{n+1}(n-i-1)</p>\n<p>  \\end{equation*}<br>  $$</p>\n<p>  $$<br>  &#x3D;\\frac{1}{n+1}\\frac{n(n+2)}{2}&#x3D;\\frac{n}{2}<br>  $$</p>\n<p>  $$<br>  因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>  $$</p>\n<p>10.按下标删除元素</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">listDelete</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((i &lt; <span class=\"number\">1</span>) || (i  L.length))</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; i &lt;= L.length - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">\t\tL.elem[j - <span class=\"number\">1</span>] = L.elem[j];</span><br><span class=\"line\">\t\t--L.length;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p> （1）先检查传递参数下标量是否正确</p>\n<p> （2）按照目标元素位置，将其头部元素前移1偏移量</p>\n<p> （3）减少线性表长度</p>\n<p> <strong>时间复杂度分析:</strong></p>\n<p>  （1）<br>  $$<br>  最好情况：在表尾插入(即i&#x3D;n)<br>  $$</p>\n<p>  $$<br>  无需移动元素，时间复杂度为O(1)<br>  $$</p>\n<p>  （2）<br>  $$<br>  最坏情况：在表头插入(即i&#x3D;1)<br>  $$</p>\n<p>  $$<br>  需移动除第一个元素外的所有元素，时间复杂度为O(n)<br>  $$</p>\n<p>  （3）<br>  $$<br>  平均情况：假设p_i(p_i&#x3D;1&#x2F;(n+1))<br>  $$</p>\n<p>  $$<br>  是第i个位置上插入一个结点的概率<br>  $$</p>\n<p>  $$<br>  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>  $$</p>\n<p>  $$<br>  \\begin{equation*}</p>\n<p>  f &#x3D; \\sum_{i&#x3D;1}^{n}p_i(n-i)</p>\n<p>  \\end{equation*}<br>  $$</p>\n<p>  $$<br>  \\begin{equation*}</p>\n<p>  &#x3D;\\sum_{i&#x3D;1}^{n}{\\frac{n}{n-i}}</p>\n<p>  \\end{equation*}<br>  $$</p>\n<p>  $$<br>  \\begin{equation*}</p>\n<p>  &#x3D;\\frac{1}{n} \\sum_{i&#x3D;1}^{n}(n-i)</p>\n<p>  \\end{equation*}<br>  $$</p>\n<p>  $$<br>  &#x3D;\\frac{1}{n}\\frac{n(n-1)}{2}&#x3D;\\frac{n-1}{2}<br>  $$</p>\n<p>  $$<br>  因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>  $$</p>\n<p>11.创建顺序存储线性表</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">createList</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">\ttype e;</span><br><span class=\"line\">\tL.length = n;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;Please in put an element:&quot;</span>;</span><br><span class=\"line\">\t\tcin  e;</span><br><span class=\"line\">\t\tL.elem[i] = e;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>11.打印顺序存储线性表内元素</p>\n <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printList</span><span class=\"params\">(SqList L)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\nList&#x27;s element：\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; L.length; i++) &#123;</span><br><span class=\"line\">\t\tcout &lt;&lt; <span class=\"string\">&quot;elem[&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"string\">&quot;] =&quot;</span> &lt;&lt; L.elem[i] &lt;&lt; endl;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","text":" Data Structure Notes  1<br>2<br>3<br>4<br>5<br>6<br>Author : &quot;blueflylabor&quot;<br>Version : 1.0<br>Refresh Date 2020.11.26<br>Descri","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"数据结构·栈和队列","slug":"数据结构·栈和队列","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.328Z","comments":false,"pin":null,"path":"api/articles/数据结构·栈和队列.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><ul>\n<li>栈(Stack)：只允许在一端插入或删除的线性表</li>\n<li>栈顶：线性表允许进行插入或删除的那一端</li>\n<li>栈底：固定的，不允许进行插入和删除的另一端</li>\n<li>特点：是受限的线性表，拥有线性关系；后进先出<strong>LIFO</strong></li>\n</ul>\n<h1 id=\"顺序栈\"><a href=\"#顺序栈\" class=\"headerlink\" title=\"顺序栈\"></a>顺序栈</h1><ul>\n<li>使用顺序存储，自底向上存储数据元素，指针指向栈顶元素的位置</li>\n<li>操作</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s.top = <span class=\"number\">-1</span>;             <span class=\"comment\">//判空</span></span><br><span class=\"line\">s.data[++s.top] = x;    <span class=\"comment\">//进栈</span></span><br><span class=\"line\">x = s.data[s.top--];    <span class=\"comment\">//出栈</span></span><br><span class=\"line\">x = s.data[s.top];      <span class=\"comment\">//读取栈顶元素</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"共享栈\"><a href=\"#共享栈\" class=\"headerlink\" title=\"共享栈\"></a>共享栈</h1><ul>\n<li>两个栈共享一个一维数组空间</li>\n<li>两个栈分别设置在共享空间两端</li>\n<li>栈顶指向中间延伸位置</li>\n<li>有利于空间使用</li>\n</ul>\n<h1 id=\"链式栈\"><a href=\"#链式栈\" class=\"headerlink\" title=\"链式栈\"></a>链式栈</h1><ul>\n<li>采用链式存储</li>\n<li>便于多个栈共享存储空间</li>\n<li>效率高</li>\n</ul>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><ul>\n<li>允许在一端插入，另一端删除的线性表</li>\n<li>队头：允许删除的一端</li>\n<li>队尾：允许插入的一端</li>\n<li>先进先出<strong>FIFO</strong></li>\n</ul>\n<h1 id=\"顺序队列\"><a href=\"#顺序队列\" class=\"headerlink\" title=\"顺序队列\"></a>顺序队列</h1><ul>\n<li>连续的存储单元</li>\n<li>头指针指向队头元素</li>\n<li>尾指针指向队尾元素</li>\n</ul>\n<h1 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h1><ul>\n<li>首尾相连的顺序存储的队列</li>\n<li>操作</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Q.rear = Q.front = <span class=\"number\">0</span>;                           <span class=\"comment\">// 初始化</span></span><br><span class=\"line\">rear = (rear + <span class=\"number\">1</span>) % MaxSize;                    <span class=\"comment\">// 入队</span></span><br><span class=\"line\">front = (front + <span class=\"number\">1</span>) % MaxSize;                  <span class=\"comment\">// 出队</span></span><br><span class=\"line\">queueLen = (rear + MaxSize - front) % MaxSize;  <span class=\"comment\">// 队列长度</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>判断空队列或满队列</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用一个单元区分队空或队满</span></span><br><span class=\"line\">(Q.rear + <span class=\"number\">1</span>) % MaxSize = Q.front;   <span class=\"comment\">//</span></span><br><span class=\"line\">Q.front = Q.rear;                   <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 类型中增加表示个数的数据成员</span></span><br><span class=\"line\">Q.size = <span class=\"number\">0</span>;                         <span class=\"comment\">//</span></span><br><span class=\"line\">Q.size = MaxSize;                   <span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// 增加tag成员</span></span><br><span class=\"line\">tag = <span class=\"number\">0</span>;                            <span class=\"comment\">//</span></span><br><span class=\"line\">tag = <span class=\"number\">1</span>;                            <span class=\"comment\">//</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"链式队列\"><a href=\"#链式队列\" class=\"headerlink\" title=\"链式队列\"></a>链式队列</h1><h1 id=\"双端队列\"><a href=\"#双端队列\" class=\"headerlink\" title=\"双端队列\"></a>双端队列</h1><ul>\n<li>允许两端可以入队和出队</li>\n<li>输出受限的双端队列：允许一端进行插入和删除，另一端只允许插入的双端队列</li>\n<li>输入受限的双端队列：允许一端进行插入和删除，另一端只允许删除的双端队列</li>\n</ul>\n<h1 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h1><h2 id=\"栈在括号匹配的应用\"><a href=\"#栈在括号匹配的应用\" class=\"headerlink\" title=\"栈在括号匹配的应用\"></a>栈在括号匹配的应用</h2><h3 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h3><ul>\n<li>空栈，一次读入一个符号</li>\n<li>右括号：使栈顶元素消解，或不合法（序列不匹配，退出程序）</li>\n<li>左括号：放入栈顶，作为更高优先级的一个元素，栈为空，否则括号序列不匹配</li>\n</ul>\n<h3 id=\"栈在表达式中的应用\"><a href=\"#栈在表达式中的应用\" class=\"headerlink\" title=\"栈在表达式中的应用\"></a>栈在表达式中的应用</h3><ul>\n<li>中缀表达式转换后缀表达式</li>\n</ul>\n<h3 id=\"栈在递归中的应用\"><a href=\"#栈在递归中的应用\" class=\"headerlink\" title=\"栈在递归中的应用\"></a>栈在递归中的应用</h3><ul>\n<li>原理：将原始问题转换为相同属性的小规模问题</li>\n<li>求出递归表达式</li>\n<li>边界条件（递归出口）</li>\n</ul>\n<h2 id=\"队列-1\"><a href=\"#队列-1\" class=\"headerlink\" title=\"队列\"></a>队列</h2><h3 id=\"队列在层次遍历的应用\"><a href=\"#队列在层次遍历的应用\" class=\"headerlink\" title=\"队列在层次遍历的应用\"></a>队列在层次遍历的应用</h3><h3 id=\"队列在计算机系统中的应用\"><a href=\"#队列在计算机系统中的应用\" class=\"headerlink\" title=\"队列在计算机系统中的应用\"></a>队列在计算机系统中的应用</h3><ul>\n<li>解决主机与外设之间速度不匹配的问题</li>\n<li>解决多用户引起的资源竞争问题</li>\n</ul>\n<h1 id=\"特殊矩阵压缩存储\"><a href=\"#特殊矩阵压缩存储\" class=\"headerlink\" title=\"特殊矩阵压缩存储\"></a>特殊矩阵压缩存储</h1><h2 id=\"数组的存储结构\"><a href=\"#数组的存储结构\" class=\"headerlink\" title=\"数组的存储结构\"></a>数组的存储结构</h2><ul>\n<li>行优先：先存储行号较小的元素，行号相等先存储列号小的元素</li>\n<li>列优先：先存储列好较小的元素，列号相等先存储行号小的元素</li>\n</ul>\n<h2 id=\"n阶对称矩阵\"><a href=\"#n阶对称矩阵\" class=\"headerlink\" title=\"n阶对称矩阵\"></a>n阶对称矩阵</h2><ul>\n<li>上三角、主对角线、下三角，其中上下三角元素相同</li>\n<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k$</li>\n<li>元素下标之间的对于关系<br>$i \\ge j , k &#x3D; \\frac{i*(i-1)}{2+j}-1(下三角区和主对角线元素)$<br>$i &lt; j , k &#x3D; \\frac{j*(j-1)}{2+i}-1(上三角区元素)$</li>\n</ul>\n<h2 id=\"n阶三角矩阵\"><a href=\"#n阶三角矩阵\" class=\"headerlink\" title=\"n阶三角矩阵\"></a>n阶三角矩阵</h2><ul>\n<li>下三角矩阵（上三角区元素为常量）和上三角矩阵（下三角矩阵元素为常量）</li>\n<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k</li>\n<li>下三角矩阵的的元素下表之间的对应关系</li>\n<li></li>\n</ul>\n","text":"栈栈(Stack)：只允许在一端插入或删除的线性表栈顶：线性表允许进行插入或删除的那一端栈底：固定的，不允许进行插入和删除的另一端特点：是受限的线性表，拥有线性关系；后进先出LIFO顺序栈使用顺序存储，自底向上存储数据元素，指针指向栈顶元素的位置操作1<br>2<br>3<br>","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"数据结构·线性表","slug":"数据结构·线性表","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.348Z","comments":false,"pin":null,"path":"api/articles/数据结构·线性表.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><h2 id=\"一、逻辑结构和基本操作\"><a href=\"#一、逻辑结构和基本操作\" class=\"headerlink\" title=\"一、逻辑结构和基本操作\"></a>一、逻辑结构和基本操作</h2><h3 id=\"1-逻辑结构\"><a href=\"#1-逻辑结构\" class=\"headerlink\" title=\"1. 逻辑结构\"></a>1. 逻辑结构</h3><ul>\n<li>具有相同数据类型的n个数据元素的有限序列，表长n，n&#x3D;0为空表</li>\n<li>表头：第一个元素</li>\n<li>表尾：最后一个元素</li>\n<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>\n<li>除最后一个元素外，每个元素有且仅有一个直接后继</li>\n</ul>\n<h3 id=\"2-基本操作\"><a href=\"#2-基本操作\" class=\"headerlink\" title=\"2. 基本操作\"></a>2. 基本操作</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">initList</span>(&amp;L);</span><br><span class=\"line\"><span class=\"built_in\">len</span>(L);</span><br><span class=\"line\"><span class=\"built_in\">locateElem</span>(L, i);</span><br><span class=\"line\"><span class=\"built_in\">getElem</span>(L, i);</span><br><span class=\"line\"><span class=\"built_in\">listInsert</span>(&amp;L, i, e);</span><br><span class=\"line\"><span class=\"built_in\">listDelete</span>(&amp;L, i, &amp;e);</span><br><span class=\"line\"><span class=\"built_in\">printList</span>(L);</span><br><span class=\"line\"><span class=\"built_in\">isEmptyList</span>(L);</span><br><span class=\"line\"><span class=\"built_in\">destroyList</span>(&amp;L);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"二、顺序存储结构\"><a href=\"#二、顺序存储结构\" class=\"headerlink\" title=\"二、顺序存储结构\"></a>二、顺序存储结构</h2><h3 id=\"1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻\"><a href=\"#1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻\" class=\"headerlink\" title=\"1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻\"></a>1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻</h3><ul>\n<li>存储空间的起始位置data[ ]</li>\n<li>顺序表最大存储容量MaxSize</li>\n<li>顺序表当前最大长度len<br>特点</li>\n<li>随机访存，O(1)时间复杂度访问</li>\n<li>存储密度高，每个结点只存储数据元素</li>\n<li>无需花费空间建立数据之间的逻辑关系，由物理位置相邻特性决定</li>\n<li>逻辑上物理上均相邻，插入删除操作需要移动大量元素</li>\n</ul>\n<h3 id=\"2-基本操作-1\"><a href=\"#2-基本操作-1\" class=\"headerlink\" title=\"2. 基本操作\"></a>2. 基本操作</h3><p>（1）插入元素</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入元素</span></span><br><span class=\"line\"><span class=\"function\">boolean <span class=\"title\">listInsert</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i  L.len + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(L.len = MaxSize)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = L.len; j  i; j--)</span><br><span class=\"line\">\t\tL.data[j] = L.data[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">\tL.data[i - <span class=\"number\">1</span>] = e;</span><br><span class=\"line\">\tL.len++;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>分析</p>\n<ul>\n<li>最好情况：在表尾插入 **(i&#x3D;n+1)**，不需要移动元素，时间复杂度为O(1)  </li>\n<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>\n<li>平均情况：假设$P_i$ **($P_i &#x3D; \\frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\\frac{n}{2}$，其时间复杂度为O(n)<br>（2）删除元素<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//删除元素</span></span><br><span class=\"line\"><span class=\"function\">boolean <span class=\"title\">listDelete</span><span class=\"params\">(SqList &amp;L, <span class=\"type\">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(i &lt; <span class=\"number\">1</span> || i  L.len + <span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">\te = L.data[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = i; j &lt; L.len; j++)</span><br><span class=\"line\">\t\tL.data[j<span class=\"number\">-1</span>] = L.data[j];</span><br><span class=\"line\">\tL.len--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n分析</li>\n<li>最好情况：在表尾插入 **(i&#x3D;n)**，不需要移动元素，时间复杂度为O(1)  </li>\n<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>\n<li>平均情况：假设$P_i$ **($P_i &#x3D; \\frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\\frac{n-1}{2}$，其时间复杂度为O(n)<br>（3）查找元素<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">locateElem</span><span class=\"params\">(SqList &amp;L, Elemtype e)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; L.len; i++)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(e == L.data[i])</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n分析</li>\n<li>最好情况：查找的元素在表头，仅需比较1次，时间复杂度O(1)</li>\n<li>最坏情况：查找的元素在表尾或不存在，需要比较n次，时间复杂度O(n)  </li>\n<li>平均情况：假设$P_i$ **($P_i &#x3D; \\frac{1}{n}$)**是在第i个位置上结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\\frac{n+1}{2}$，其时间复杂度为O(n)</li>\n</ul>\n<h1 id=\"链式存储结构\"><a href=\"#链式存储结构\" class=\"headerlink\" title=\"链式存储结构\"></a>链式存储结构</h1><h2 id=\"1-创建单链表\"><a href=\"#1-创建单链表\" class=\"headerlink\" title=\"1.创建单链表\"></a>1.创建单链表</h2><h3 id=\"（1）头插法\"><a href=\"#（1）头插法\" class=\"headerlink\" title=\"（1）头插法\"></a>（1）头插法</h3><ul>\n<li>为新插入的结点分配内存空间</li>\n<li>每次都是把插入的新结点放入表头(头结点位置)</li>\n<li>链表结点的次序与输入的顺序相反</li>\n</ul>\n<h3 id=\"（2）尾插法\"><a href=\"#（2）尾插法\" class=\"headerlink\" title=\"（2）尾插法\"></a>（2）尾插法</h3><ul>\n<li>为新插入的结点分配内存空间</li>\n<li>每次都是把插入的新结点放入表尾(尾结点位置)</li>\n<li>链表中的结点顺序与输入顺序一致</li>\n</ul>\n<h2 id=\"2-按值查找结点\"><a href=\"#2-按值查找结点\" class=\"headerlink\" title=\"2.按值查找结点\"></a>2.按值查找结点</h2><ul>\n<li>在链表中从第一个结点出发，顺指针next逐个向下搜索，直到找到第i个结点，否则返回最后一个结点的指针域NULL</li>\n</ul>\n<h2 id=\"3-按序号查找结点\"><a href=\"#3-按序号查找结点\" class=\"headerlink\" title=\"3.按序号查找结点\"></a>3.按序号查找结点</h2><ul>\n<li>从链表第一个结点开始，由前往后按照序号递增定位到相应结点的位置，返回该值，需检查序号是否越界</li>\n</ul>\n<h2 id=\"4-插入\"><a href=\"#4-插入\" class=\"headerlink\" title=\"4.插入\"></a>4.插入</h2><ul>\n<li>插入操作是将值为x的新结点插入到单链表的第i个位置</li>\n<li>先检查插入位置是否合法</li>\n<li>找到待插入位置的前驱结点</li>\n<li>在其后将结点插入<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"built_in\">getElem</span>(L, i<span class=\"number\">-1</span>)</span><br><span class=\"line\">s-next = p-next;</span><br><span class=\"line\">p-next = s;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"5-删除\"><a href=\"#5-删除\" class=\"headerlink\" title=\"5.删除\"></a>5.删除</h2><ul>\n<li>将单链表的第i个结点删除</li>\n<li>先检查插入位置是否合法</li>\n<li>找到待删除位置的前驱结点</li>\n<li>删除其后结点<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = <span class=\"built_in\">getElem</span>(L, i<span class=\"number\">-1</span>)</span><br><span class=\"line\">q = p-next;</span><br><span class=\"line\">q-next = p-next;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"双链表\"><a href=\"#双链表\" class=\"headerlink\" title=\"双链表\"></a>双链表</h1><ul>\n<li>双链表有两个指针prior和next，分别指向前驱和后继结点</li>\n<li>插入操作<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s-next = p-next;</span><br><span class=\"line\">p-next-prior = s;</span><br><span class=\"line\">s-prior = p;</span><br><span class=\"line\">p-next = s;</span><br></pre></td></tr></table></figure></li>\n<li>删除操作<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p-next = q-next;</span><br><span class=\"line\">q-next-prior = p;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(q);</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"循环链表\"><a href=\"#循环链表\" class=\"headerlink\" title=\"循环链表\"></a>循环链表</h1><ul>\n<li>循环双链表和循环单链表</li>\n<li>静态链表使用数组来描述线性表的链式存储结构</li>\n</ul>\n","text":"线性表一、逻辑结构和基本操作1. 逻辑结构具有相同数据类型的n个数据元素的有限序列，表长n，n&#x3D;0为空表表头：第一个元素表尾：最后一个元素除第一个元素外，每个元素有且仅有一个直接前驱除最后一个元素外，每个元素有且仅有一个直接后继2. 基本操作1<br>2<br>3<br","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"环境配置·Ubuntu1804安装CUDA和Pytorch","slug":"环境配置·Ubuntu1804安装CUDA和Pytorch","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.354Z","comments":false,"pin":null,"path":"api/articles/环境配置·Ubuntu1804安装CUDA和Pytorch.json","excerpt":"","keywords":null,"cover":null,"content":"<h2 id=\"Init-Ubuntu-and-change-deb-pip-source\"><a href=\"#Init-Ubuntu-and-change-deb-pip-source\" class=\"headerlink\" title=\"Init Ubuntu and change deb&amp;pip source\"></a>Init Ubuntu and change deb&amp;pip source</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://fastly.jsdelivr.net/gh/blueflylabor/_ebxeax.github.io@0.0/toolbox/initUbuntu/initUbuntu.sh</span><br><span class=\"line\">bash ./initUbuntu.sh</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"CUDA11-6\"><a href=\"#CUDA11-6\" class=\"headerlink\" title=\"CUDA11.6\"></a>CUDA11.6</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin</span><br><span class=\"line\">sudo <span class=\"built_in\">mv</span> cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class=\"line\">wget https://developer.download.nvidia.com/compute/cuda/11.6.2/local_installers/cuda-repo-wsl-ubuntu-11-6-local_11.6.2-1_amd64.deb</span><br><span class=\"line\">sudo dpkg -i cuda-repo-wsl-ubuntu-11-6-local_11.6.2-1_amd64.deb</span><br><span class=\"line\">sudo apt-key add /var/cuda-repo-wsl-ubuntu-11-6-<span class=\"built_in\">local</span>/7fa2af80.pub</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get -y install cuda</span><br></pre></td></tr></table></figure></div>\n<h2 id=\"Load-library-path\"><a href=\"#Load-library-path\" class=\"headerlink\" title=\"Load library path\"></a>Load library path</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gedit ~/.bashrc</span><br><span class=\"line\"><span class=\"built_in\">export</span> PATH=/usr/local/cuda/bin:<span class=\"variable\">$PATH</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> LD_LIBRARY_PATH=/usr/local/cuda/lib64:<span class=\"variable\">$LD_LIBRARY_PAT</span></span><br><span class=\"line\"><span class=\"built_in\">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"Test-nvidia-smi\"><a href=\"#Test-nvidia-smi\" class=\"headerlink\" title=\"Test nvidia-smi\"></a>Test nvidia-smi</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvidia-smi</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"Test-nvcc-V\"><a href=\"#Test-nvcc-V\" class=\"headerlink\" title=\"Test nvcc -V\"></a>Test nvcc -V</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvcc -V</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"Pytorch\"><a href=\"#Pytorch\" class=\"headerlink\" title=\"Pytorch\"></a>Pytorch</h2><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip3 install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"get-file-when-network-worse\"><a href=\"#get-file-when-network-worse\" class=\"headerlink\" title=\"get file when network worse\"></a>get file when network worse</h3><div class=\"highlight-wrap\"autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" contenteditable=\"true\"data-rel=\"SH\"><figure class=\"iseeu highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://download.pytorch.org/whl/cu113/torch-1.10.2%2Bcu113-cp36-cp36m-linux_x86_64.whl</span><br><span class=\"line\">wget https://download.pytorch.org/whl/cu113/torchvision-0.11.3%2Bcu113-cp36-cp36m-linux_x86_64.whl</span><br><span class=\"line\">wget </span><br><span class=\"line\">pip3 install ./torch-1.10.2+cu113-cp36-cp36m-linux_x86_64.whl</span><br><span class=\"line\">pip3 install ./torchvision-0.11.3+cu113-cp36-cp36m-linux_x86_64.whl</span><br></pre></td></tr></table></figure></div>","text":"Init Ubuntu and change deb&amp;pip source1<br>2<br>wget https://fastly.jsdelivr.net/gh/blueflylabor/_ebxeax.github.io@0.0/toolbox/initUbuntu","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"数据结构·简述","slug":"数据结构·简述","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.342Z","comments":false,"pin":null,"path":"api/articles/数据结构·简述.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"数据结构绪论\"><a href=\"#数据结构绪论\" class=\"headerlink\" title=\"数据结构绪论\"></a>数据结构绪论</h1><h2 id=\"一、数据结构：相互存在一种或多种特定关系的集合\"><a href=\"#一、数据结构：相互存在一种或多种特定关系的集合\" class=\"headerlink\" title=\"一、数据结构：相互存在一种或多种特定关系的集合\"></a>一、数据结构：相互存在一种或多种特定关系的集合</h2><ul>\n<li>结构：任何问题，数据元素不孤立存在，之间存在关系  </li>\n<li>逻辑结构</li>\n<li>存储结构（物理结构）</li>\n<li>数据的运算</li>\n<li>逻辑结构和存储结构密不可分</li>\n<li>算法设计取决于逻辑结构，实现依赖存储结构</li>\n</ul>\n<h2 id=\"二、逻辑结构：数据元素之间的逻辑关系\"><a href=\"#二、逻辑结构：数据元素之间的逻辑关系\" class=\"headerlink\" title=\"二、逻辑结构：数据元素之间的逻辑关系\"></a>二、逻辑结构：数据元素之间的逻辑关系</h2><ul>\n<li>与存储无关，独立于计算机</li>\n<li>分为线性结构和非线性结构<br>线性结构：线性表、栈、队列、串、数组、广义表<br>非线性结构：树、二叉树、有向图、无向图</li>\n</ul>\n<h2 id=\"三、存储结构（物理结构）：数据结构在计算机中的映像\"><a href=\"#三、存储结构（物理结构）：数据结构在计算机中的映像\" class=\"headerlink\" title=\"三、存储结构（物理结构）：数据结构在计算机中的映像\"></a>三、存储结构（物理结构）：数据结构在计算机中的映像</h2><ul>\n<li>数据结构的表示</li>\n<li>关系的表示</li>\n<li>依赖于计算机语言</li>\n<li>分为顺序存储、链式存储、索引存储、散列存储</li>\n</ul>\n<h3 id=\"1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻\"><a href=\"#1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻\" class=\"headerlink\" title=\"1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻\"></a>1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻</h3><ul>\n<li>优：实现随机存取、每个元素占用的内存少</li>\n<li>缺：只能使用相邻的一块存储单元，产生较多的外部碎片</li>\n</ul>\n<h3 id=\"2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素\"><a href=\"#2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素\" class=\"headerlink\" title=\"2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素\"></a>2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素</h3><ul>\n<li>优：无碎片产生、充分利用存储单元</li>\n<li>缺：只能顺序存储</li>\n</ul>\n<h3 id=\"3-索引存储：类似目录\"><a href=\"#3-索引存储：类似目录\" class=\"headerlink\" title=\"3. 索引存储：类似目录\"></a>3. 索引存储：类似目录</h3><h3 id=\"4-散列存储：通过关键字直接计算出元素的物理地址\"><a href=\"#4-散列存储：通过关键字直接计算出元素的物理地址\" class=\"headerlink\" title=\"4. 散列存储：通过关键字直接计算出元素的物理地址\"></a>4. 散列存储：通过关键字直接计算出元素的物理地址</h3><h2 id=\"四、数据运算\"><a href=\"#四、数据运算\" class=\"headerlink\" title=\"四、数据运算\"></a>四、数据运算</h2><h2 id=\"五、算法的五个特征\"><a href=\"#五、算法的五个特征\" class=\"headerlink\" title=\"五、算法的五个特征\"></a>五、算法的五个特征</h2><ul>\n<li>有穷性：执行有限步后结束</li>\n<li>确定性：每条指令都有确定的含义，相同输入得到相同的输出</li>\n<li>可行性：通过实现的基本运算执行有限次得到确定的结果</li>\n<li>输入：有零或多个输入</li>\n<li>输出：一个或多个程序输出结果</li>\n</ul>\n<h2 id=\"六、算法的复杂度\"><a href=\"#六、算法的复杂度\" class=\"headerlink\" title=\"六、算法的复杂度\"></a>六、算法的复杂度</h2><h3 id=\"1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢\"><a href=\"#1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢\" class=\"headerlink\" title=\"1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢\"></a>1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢</h3><h3 id=\"2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢\"><a href=\"#2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢\" class=\"headerlink\" title=\"2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢\"></a>2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢</h3>","text":"数据结构绪论一、数据结构：相互存在一种或多种特定关系的集合结构：任何问题，数据元素不孤立存在，之间存在关系  逻辑结构存储结构（物理结构）数据的运算逻辑结构和存储结构密不可分算法设计取决于逻辑结构，实现依赖存储结构二、逻辑结构：数据元素之间的逻辑关系与存储无关，独立于计算机分为线","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"计算机组成原理·中央处理器","slug":"计算机组成原理·中央处理器","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.383Z","comments":false,"pin":null,"path":"api/articles/计算机组成原理·中央处理器.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"中央处理器\"><a href=\"#中央处理器\" class=\"headerlink\" title=\"中央处理器\"></a>中央处理器</h1><p>控制器：负责协调并控制计算机各部件执行程序的指令序列：取指令、分析指令、执行指令<br>运算器：对数据加工</p>\n<ul>\n<li>指令控制</li>\n<li>操作控制</li>\n<li>数据加工</li>\n<li>时间控制</li>\n<li>中断处理</li>\n</ul>\n<h3 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><p>运算器和控制器两大部分组成<br>运算器：</p>\n<ul>\n<li>算术逻辑单元（ALU）</li>\n<li>暂存寄存器</li>\n<li>累加寄存器（ACC）</li>\n<li>通用寄存器组（AX&#x2F;BX&#x2F;CX&#x2F;DX&#x2F;SP）</li>\n<li>程序状态字寄存器（PSW：OF&#x2F;SF&#x2F;ZF&#x2F;CF）</li>\n<li>移位器</li>\n<li>计数器</li>\n</ul>\n<p>控制器（CU）：</p>\n<ul>\n<li>程序计数器（PC）</li>\n<li>指令寄存器（IR）</li>\n<li>指令译码器</li>\n<li>存储器地址寄存器</li>\n<li>存储器数据寄存器</li>\n<li>时序系统</li>\n<li>微操作信号发生器</li>\n</ul>\n<h2 id=\"指令执行过程\"><a href=\"#指令执行过程\" class=\"headerlink\" title=\"指令执行过程\"></a>指令执行过程</h2><h3 id=\"指令周期\"><a href=\"#指令周期\" class=\"headerlink\" title=\"指令周期\"></a>指令周期</h3><p>CPU从主存取出并执行一条指令的时间，指令周期通常使用若干机器周期表示，每个机器周期可等长或不等，一个机器周期包含若干时钟周期（节拍），每个机器周期内的时钟周期数可以不等</p>\n<ul>\n<li>无条件转移指令：执行阶段不需要访存，只包含取指阶段（取指和分析）和执行阶段</li>\n<li>间接寻址指令：为了取操作数，需要先访1次，取出有效地址，然后访存，取出操作数，所有需要包含间址周期，介于取指和执行之间</li>\n<li>CPU采用中断方式实现主机和I&#x2F;O设备的信息交换，CPU在每条指令结束前，都要发送中断查询信号，若有中断请求，CPU进入中断响应阶段（中断周期）</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>取指周期</td>\n<td>间址周期</td>\n<td>执行周期</td>\n<td>中断周期</td>\n</tr>\n</tbody></table>\n<p>只有访存的目的不同，取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点<br>CPU内设置了4个标志触发器FE&#x2F;IND&#x2F;EX&#x2F;INT</p>\n<table>\n<thead>\n<tr>\n<th>FE</th>\n<th>IND</th>\n<th>EX</th>\n<th>INT</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Fetch</td>\n<td>Index</td>\n<td>Execute</td>\n<td>Interrupt</td>\n</tr>\n<tr>\n<td>取值</td>\n<td>间址</td>\n<td>执行</td>\n<td>中断</td>\n</tr>\n</tbody></table>\n<h3 id=\"指令周期的数据流\"><a href=\"#指令周期的数据流\" class=\"headerlink\" title=\"指令周期的数据流\"></a>指令周期的数据流</h3><h4 id=\"取指周期\"><a href=\"#取指周期\" class=\"headerlink\" title=\"取指周期\"></a>取指周期</h4><p>根据PC中的内容从主存取出指令代码放入IR  </p>\n<ul>\n<li>PC $\\to$ IR $\\to$ AddrBus $\\to$ Mem</li>\n<li>CU $\\to$ DataBus $\\to$ MDR $\\to$ Mem</li>\n<li>Mem $\\to$ DataBus $\\to$ MDR $\\to$ IR（存放指令）</li>\n<li>CU $\\stackrel{SignalControl::FE}{\\longrightarrow}$ [(PC) + 1 $\\to$ PC]</li>\n</ul>\n<h4 id=\"间址周期\"><a href=\"#间址周期\" class=\"headerlink\" title=\"间址周期\"></a>间址周期</h4><p>取操作数有效地址，间址为例：指令中的地址码送到MAR并送至地址总线，CU向存储器发送读命令，以获取有效地址并存在MDR  </p>\n<ul>\n<li>Addr(IR) &#x2F; MDR $\\to$ MAR $\\to$ AddrBus $\\to$ Mem</li>\n<li>CU $\\stackrel{SignalI&#x2F;O::READ}{\\longrightarrow}$ ControlBus $\\to$ Mem（存放有效地址）</li>\n<li>Mem $\\to$ DataBus $\\to$ MDR</li>\n</ul>\n<h4 id=\"执行周期\"><a href=\"#执行周期\" class=\"headerlink\" title=\"执行周期\"></a>执行周期</h4><p>取操作数，根据IR的指令字的操作码通过ALU操作产生执行结果</p>\n<ul>\n<li>无统一的数据流向</li>\n</ul>\n<h4 id=\"中断周期\"><a href=\"#中断周期\" class=\"headerlink\" title=\"中断周期\"></a>中断周期</h4><p>处理中断请求，假设程序断点存入堆栈，用SP指示栈顶地址，入栈操作是先修改栈顶指针，后存入数据</p>\n<ul>\n<li>CU $\\stackrel{SignalStack::SP}{\\longrightarrow}$ [(SP) - 1 $\\to$ SP] $\\to$ MAR $\\to$ AddrBus $\\to$ Mem</li>\n<li>CU $\\stackrel{SignalI&#x2F;O::WRITE}{\\longrightarrow}$ ControlBus $\\to$ Mem</li>\n<li>PC $\\to$ MDR $\\to$ DataBus $\\to$ Mem（程序断点存入主存）</li>\n<li>CU $\\to$ PC（中断服务程序的入口地址送至PC）</li>\n</ul>\n<h3 id=\"指令执行方案\"><a href=\"#指令执行方案\" class=\"headerlink\" title=\"指令执行方案\"></a>指令执行方案</h3><ul>\n<li>单指令周期</li>\n<li>多指令周期</li>\n<li>流水线方案</li>\n</ul>\n<h2 id=\"数据通路\"><a href=\"#数据通路\" class=\"headerlink\" title=\"数据通路\"></a>数据通路</h2><h3 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h3><p>数据通路：数据在功能部件之间传输的路径<br>由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号<br>数据通路功能：实现CPU内部的运算器与寄存器以及寄存器之间的数据交换</p>\n<h3 id=\"基本结构-1\"><a href=\"#基本结构-1\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h3><ul>\n<li>CPU内部单总线模式<br>所有寄存器的输入输出端都连接在一条公共通路上，结构简单但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构，CPU中有两条或更多的总线时，构成双总线结构或多总线结构</li>\n<li>CPU内部多总线模式<br>所有寄存器的输入输出端都连接在多条公共通路上，相比之下单总线在一个时钟内只允许传一个数据，因此指令执行效率很低，因此在多总线方式，同时在多总线上传输不同的数据，提高效率</li>\n<li>专用数据通路方式<br>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大</li>\n</ul>\n<h4 id=\"寄存器之间的数据传输\"><a href=\"#寄存器之间的数据传输\" class=\"headerlink\" title=\"寄存器之间的数据传输\"></a>寄存器之间的数据传输</h4><p>通过内部总线完成<br>寄存器AX的输入输出由AXout和AXin控制  </p>\n<ul>\n<li>(PC) $\\to$ MAR，PCout和MARin有效</li>\n</ul>\n<h4 id=\"主存与CPU之间的数据传输\"><a href=\"#主存与CPU之间的数据传输\" class=\"headerlink\" title=\"主存与CPU之间的数据传输\"></a>主存与CPU之间的数据传输</h4><p>主存与CPU之间的数据传输需要借助CPU内部总线完成<br>主存内读取</p>\n<ul>\n<li>(PC) $\\to$ MAR，PCout和MARin有效  </li>\n<li>1 $\\to$ R，CU发出读命令  </li>\n<li>MEM(MAR) $\\to$ MDR，MDRin有效  </li>\n<li>(MDR) $\\to$ IR，MDRout和IRin有效</li>\n</ul>\n<h4 id=\"执行算术或逻辑算术\"><a href=\"#执行算术或逻辑算术\" class=\"headerlink\" title=\"执行算术或逻辑算术\"></a>执行算术或逻辑算术</h4><p>由于ALU没有内部存储功能，执行加法操作，相加的两个数必须在ALU的两个输入输出端同时有效</p>\n<ul>\n<li>(MDR) $\\to$ MAR，MDRout和MARin有效  </li>\n<li>1 $\\to$ R，CU读命令</li>\n<li>MEM(MAR) $\\to$ 操作数从主存送至MDR</li>\n<li>(MDR) $\\to$ Y，MDRout和Yin有效</li>\n<li>(ACC) + (Y) $\\to$ Z ACCout和ALUin有效</li>\n<li>(Z) $\\to$ ACC，Zout和ACCin有效</li>\n</ul>\n<h2 id=\"控制器功能与原理\"><a href=\"#控制器功能与原理\" class=\"headerlink\" title=\"控制器功能与原理\"></a>控制器功能与原理</h2><h3 id=\"结构和功能\"><a href=\"#结构和功能\" class=\"headerlink\" title=\"结构和功能\"></a>结构和功能</h3><ul>\n<li>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据</li>\n<li>输入设备和输出设备通过接口电路与总线相连接</li>\n<li>内存储器、输入设备通过接口电路与总线相连接</li>\n<li>内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传输数据</li>\n<li>控制器部件从数据总线接受指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件通过运算所需的控制信号</li>\n</ul>\n<p>控制器功能：</p>\n<ul>\n<li>从主存取指令，并指出下一条指令在主存中的位置</li>\n<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>\n<li>指挥并控制CPU、主存、输入输出设备之间的数据流动方向</li>\n</ul>\n<p>根据控制器产生微操作控制信号的方式不同，控制器可分为</p>\n<ul>\n<li>硬布线控制器</li>\n<li>微程序控制器</li>\n</ul>\n<p>两类控制器的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制部件各部件运算所需控制信号的方案不同</p>\n<h3 id=\"硬布线控制器\"><a href=\"#硬布线控制器\" class=\"headerlink\" title=\"硬布线控制器\"></a>硬布线控制器</h3><ul>\n<li>根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号</li>\n<li>由复杂的组合逻辑门电路和一些触发器构成</li>\n</ul>\n<h4 id=\"硬布线控制单元\"><a href=\"#硬布线控制单元\" class=\"headerlink\" title=\"硬布线控制单元\"></a>硬布线控制单元</h4><p>指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键<br>CU的输入信号来源：</p>\n<ul>\n<li>经指令译码器译码产生的信息指令</li>\n<li>时序系统产生的机器周期信号和节拍信号</li>\n<li>来自执行单元的反馈信号（标志）</li>\n<li>系统总线（控制总线）控制信号（中断请求、DMA请求）</li>\n</ul>\n<h4 id=\"硬布线控制器的时序系统及微操作\"><a href=\"#硬布线控制器的时序系统及微操作\" class=\"headerlink\" title=\"硬布线控制器的时序系统及微操作\"></a>硬布线控制器的时序系统及微操作</h4><ul>\n<li>时钟周期<br>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度对应一个时钟周期，每个节拍内机器可以完成一个或几个需要同时执行的操作</li>\n<li>机器周期<br>是所有指令执行过程的一个基准时间，访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期，在存储字长等于指令字长前提下，取指周期视为机器周期</li>\n<li>指令周期</li>\n<li>微操作命令分析<br>控制单元具有发出各种操作命令（控制信号）序列的功能，这些命令与指令有关</li>\n</ul>\n<p>执行过程，一条指令分为3个工作周期：取指周期、间址周期、执行周期  </p>\n<p>取指周期  </p>\n<ul>\n<li>(PC) $\\to$ MAR  </li>\n<li>1 $\\to$ R  </li>\n<li>M(MAR) $\\to$ MDR</li>\n<li>(MDR) $\\to$ IR</li>\n<li>OP(IR) $\\to$ CU</li>\n<li>(PC) + 1  $\\to$ PC</li>\n</ul>\n<p>间址周期</p>\n<ul>\n<li>Addr(IR) $\\to$ MAR</li>\n<li>1  $\\to$ R</li>\n<li>M(MAR)  $\\to$ MDR</li>\n</ul>\n<p>执行周期  </p>\n<ul>\n<li>非访存指令  </li>\n<li>访存指令</li>\n</ul>\n<h4 id=\"CPU控制方式\"><a href=\"#CPU控制方式\" class=\"headerlink\" title=\"CPU控制方式\"></a>CPU控制方式</h4><ul>\n<li>同步控制方式<br>具有统一的时钟，所有控制信号均来自统一的时钟信号</li>\n<li>异步控制方式<br>不存在基准时标信号，各部件按自身固有的速度工作，以应答方式联络</li>\n<li>联合控制方式<br>大部分采用同步控制，小部分采用异步控制</li>\n</ul>\n<h3 id=\"微程序控制器\"><a href=\"#微程序控制器\" class=\"headerlink\" title=\"微程序控制器\"></a>微程序控制器</h3><p>采用存储逻辑实现,把微操作信号代码化,使每条机器指令转化为一段微程序并存入一个专门的存储器（控制存储器），微操作控制信号由微指令产生</p>\n<h4 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h4><ul>\n<li><p>微操作和微命令<br>一条机器指令可以分解为一系列微操作序列，微操作是计算机中最基本、不可再分解的操作；微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，是构成控制系列的最小单位<br>微命令有相容性和互斥性</p>\n</li>\n<li><p>微指令和微周期<br>微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为微地址<br>一条微地址包括：<br>（1）操作控制字段（微操作码）：用于产生某一步操作所需的各种操作控制信号<br>（2）顺序控制字段（微地址码）：用于控制产生下一条要执行的微指令地址<br>微周期是执行一条微指令所需的时间，通常为一个时钟周期  </p>\n</li>\n<li><p>主存储器和控制存储器<br>主存储器M，用于存放程序和数据，在CPU外部，用RAM实现<br>控制存储器CM，用于存放微程序，在CPU内部，用ROM实现</p>\n</li>\n<li><p>程序和微程序<br>程序是指令的有序集合，用于完成某些特定的功能<br>微程序是微指令的有序集合，一条指令的给你由一段微程序实现<br>微程序和程序是两个不同的概念，微程序由微指令组成，描述机器指令，微程序实质是机器指令的实时解释器，由计算机设计者实现编制并存放于控制存储器CM中，无需知道，而程序最终由机器指令组成，由软件设计人员事先编制并存放于主存储器或辅助存储器</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>MAR</td>\n<td>存放主存的读写地址</td>\n<td>CMAR</td>\n<td>存放控制存储器的读写微指令地址</td>\n</tr>\n<tr>\n<td>IR</td>\n<td>存放从主存中读出的指令</td>\n<td>CMDR&#x2F;$\\mu$IR</td>\n<td>存放控制存储器中读出的微指令</td>\n</tr>\n</tbody></table>\n<h4 id=\"组成-过程\"><a href=\"#组成-过程\" class=\"headerlink\" title=\"组成&amp;过程\"></a>组成&amp;过程</h4><ul>\n<li>控制存储器：存放各指令对应的微程序</li>\n<li>微指令寄存器：用于存放从CM中取出的微指令，位数同微指令字长相等</li>\n<li>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行</li>\n<li>微地址寄存器：接收微地址形成部件送来的微地址，为在CM中读取微指令作准备</li>\n</ul>\n<p>在微程序控制器的控制下计算器执行机器指令的过程：  </p>\n<ul>\n<li>执行取微指令：自动将取指微程序的入口地址送入CMAR，从CM中读取相应的微指令送入CMDR（取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完成，从主存取出的机器指令就已经存入指令寄存器中）</li>\n<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令对应的微程序入口地址，并送入CMAR</li>\n<li>从CM中逐条读取对应的微指令并执行</li>\n<li>执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第一步</li>\n</ul>\n<p>微程序和机器指令：<br>一条机器指令对应一个微程序，由于机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编制为一个微程序，这个微程序只负责将指令从主存单元取出送入指令寄存器，也可编制对应的间址周期和中断周期的微程序<br>控制存储器CM中的微程序个数 &#x3D; 机器指令数+取指+间址+中断</p>\n<h4 id=\"编码方式\"><a href=\"#编码方式\" class=\"headerlink\" title=\"编码方式\"></a>编码方式</h4><p>又称微指令的控制方式，如何对微指令的控制字段进行编码，以形成控制信号  </p>\n<ul>\n<li><p>直接编码（直接控制）<br>无需进行译码，微指令的微命令字段中每位代表一个微命令，设计微指令，选用某个微命令只需将微命令对应的字段设置为1或0<br>优：简单直观速度快<br>缺：微指令字长过长，n个微命令要求微指令的操作字段有n位，造成控制存储器容量极大</p>\n</li>\n<li><p>字段直接编码<br>将微指令的微命令字段分成若干小字段，互斥性微命令组合在同一字段，相容性微命令组合在不同字段，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关<br>优:可以缩短微指令字长<br>缺：需要通过编译电路后发出微命令，较直接编译慢</p>\n</li>\n</ul>\n<h4 id=\"地址形成方式\"><a href=\"#地址形成方式\" class=\"headerlink\" title=\"地址形成方式\"></a>地址形成方式</h4><ul>\n<li>直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址（断定方式）</li>\n<li>根据机器指令的操作码形成，机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>\n<li>增量计算器法：(CMAR) + 1 $\\to$ CMAR</li>\n<li>根据各种标志决定微指令分支转移地址</li>\n<li>通过测试网络形成</li>\n<li>由硬件直接产生微程序入口地址</li>\n</ul>\n<h4 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h4><ul>\n<li>水平型：直接编码、字段直接编码、字段间接编码、混合编码</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$A_1$</td>\n<td>$A_2$</td>\n<td>$\\dots$</td>\n<td>$A_{n-1}$</td>\n<td>$A_{n}$</td>\n<td>判断测试字段</td>\n<td>后继地址字段</td>\n</tr>\n<tr>\n<td>操作控制</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>顺序控制</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>优：微程序短，执行速快<br>缺：微指令长，编写微程序复杂  </p>\n<ul>\n<li>垂直型：采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>$\\mu$OP</th>\n<th>Rd</th>\n<th>Rs</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>微操作码</td>\n<td>目的地址</td>\n<td>源地址</td>\n</tr>\n</tbody></table>\n<p>优：微指令短、简单、规整，便于编写微程序<br>缺：微程序长，执行速度慢，工作效率低  </p>\n<ul>\n<li>混合型<br>在垂直型的基础上增加一些不太复杂的并行操作</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>水平型</th>\n<th>垂直型</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>并行能力</td>\n<td>并行能力强、灵活性高、效率高</td>\n<td>较差</td>\n</tr>\n<tr>\n<td>执行时间</td>\n<td>短</td>\n<td>长</td>\n</tr>\n<tr>\n<td>长度</td>\n<td>微指令字较长，微程序较短</td>\n<td>微指令字较短，微程序较长</td>\n</tr>\n<tr>\n<td>难易程度</td>\n<td>难</td>\n<td>易</td>\n</tr>\n</tbody></table>\n<h4 id=\"动态微程序设计和毫微程序设计\"><a href=\"#动态微程序设计和毫微程序设计\" class=\"headerlink\" title=\"动态微程序设计和毫微程序设计\"></a>动态微程序设计和毫微程序设计</h4><ul>\n<li><p>动态微程序设计：根据用户的要求改变微程序，需要可写控制寄存器，使用EPROM</p>\n</li>\n<li><p>毫微程序设计：硬件不由微程序直接控制，通过存放在第二级控制存储器中的毫微程序来解释</p>\n</li>\n</ul>\n<h4 id=\"微程序控制器和硬布线控制器比较\"><a href=\"#微程序控制器和硬布线控制器比较\" class=\"headerlink\" title=\"微程序控制器和硬布线控制器比较\"></a>微程序控制器和硬布线控制器比较</h4><table>\n<thead>\n<tr>\n<th></th>\n<th>微程序控制器</th>\n<th>硬布线控制器</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>工作原理</td>\n<td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>\n<td>微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</td>\n</tr>\n<tr>\n<td>执行速度</td>\n<td>慢</td>\n<td>快</td>\n</tr>\n<tr>\n<td>规整性</td>\n<td>较规整</td>\n<td>烦琐、不规整</td>\n</tr>\n<tr>\n<td>应用场合</td>\n<td>CISC CPU</td>\n<td>RISC CPU</td>\n</tr>\n<tr>\n<td>易扩充性</td>\n<td>容易</td>\n<td>困难</td>\n</tr>\n</tbody></table>\n<h3 id=\"异常（内中断）和中断\"><a href=\"#异常（内中断）和中断\" class=\"headerlink\" title=\"异常（内中断）和中断\"></a>异常（内中断）和中断</h3><p>异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常<br>硬故障中断：是由硬连线出现异常引起（存储器校验异常、总线错误）<br>程序性异常（软件中断）：CPU内部因执行指令而引起的（整除0、溢出、断点、单步跟踪、非法指令）<br>按照异常发生的原因和返回方式，可进一步分为故障、自陷、终止</p>\n<ul>\n<li><p>故障（Fault）<br>引起故障的指令启动后、执行结束前被检测到的异常，因为无法通过异常处理程序恢复故障，因此不能回到原断点处执行，必须终止进程的执行  </p>\n</li>\n<li><p>自陷（Trap）<br>事先安排的一种异常事件，事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志人为设置一个陷阱，当执行到被设置了陷阱的指令时，CPU在执行陷阱指令后，自动根据不同的陷阱类型进行相应的处理，然后返回到自陷程序下一条指令执行。当自陷指令是转移指令时，并不是返回到下一条指令执行，而不是返回到转移目标指令执行</p>\n</li>\n<li><p>终止（Abort）<br>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，程序将无法继续执行，只能终止，此时调出中断服务程序来重启系统，终止异常和外中断属于硬件中断</p>\n</li>\n</ul>\n<p>中断是来自CPU外部、与CPU执行指令无关的事件引起的中断<br>中断的分类：</p>\n<ul>\n<li><p>可屏蔽中断<br>通过可屏蔽中断请求线INTR向CPU发出中断请求，CPU可通过设置相应的屏蔽字来屏蔽或不屏蔽某个中断</p>\n</li>\n<li><p>不可屏蔽中断<br>通过专门的不可屏蔽中断请求NMI向CPU发出的中断请求，通常是非常紧急的硬件故障</p>\n</li>\n</ul>\n<p>中断和异常的不同：  </p>\n<ul>\n<li><p>缺页或溢出等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成  </p>\n</li>\n<li><p>异常的检测由CPU完成，不通过外部的某个信号通知CPU，中断CPU必须通过中断请求线获取中断源信息，才能知道哪个设备发生了何种中断</p>\n</li>\n</ul>\n<h3 id=\"异常和中断响应过程\"><a href=\"#异常和中断响应过程\" class=\"headerlink\" title=\"异常和中断响应过程\"></a>异常和中断响应过程</h3><ul>\n<li>关中断</li>\n<li>保存断点和程序状态</li>\n<li>识别异常和中断并转到相应的处理程序（软件识别和硬件识别）</li>\n</ul>\n<p>软件识别：CPU设置一个异常状态寄存器，用于记录异常原因，操作系统使用一个统一的异常和中断查询程序，按优先级顺序查询异常状态寄存器，以检查异常和中断类型，先查询到的先处理，然后转到内核中相应的处理程序</p>\n<p>硬件识别（向量中断）：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放于中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表内，类型号和中断向量一一对应</p>\n<h2 id=\"指令流水线\"><a href=\"#指令流水线\" class=\"headerlink\" title=\"指令流水线\"></a>指令流水线</h2><p>从两方面提高处理机的并行性：  </p>\n<ul>\n<li>时间并行：流水线技术</li>\n<li>空间并行：超标量处理机</li>\n</ul>\n<h3 id=\"指令流水的定义\"><a href=\"#指令流水的定义\" class=\"headerlink\" title=\"指令流水的定义\"></a>指令流水的定义</h3><p>一条指令的执行过程分解为几个阶段，每个阶段由相应的功能部件完成</p>\n<ul>\n<li>取指IF</li>\n<li>译码&#x2F;读寄存器ID</li>\n<li>执行&#x2F;计算地址EX</li>\n<li>访存MEM</li>\n<li>写回WB</li>\n</ul>\n","text":"中央处理器控制器：负责协调并控制计算机各部件执行程序的指令序列：取指令、分析指令、执行指令<br>运算器：对数据加工指令控制操作控制数据加工时间控制中断处理基本结构运算器和控制器两大部分组成<br>运算器：算术逻辑单元（ALU）暂存寄存器累加寄存器（ACC）通用寄存器组（AX&#","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"计算机组成原理·Cache和主存的映射替换算法和写策略","slug":"计算机组成原理·Cache和主存的映射替换算法和写策略","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.374Z","comments":false,"pin":null,"path":"api/articles/计算机组成原理·Cache和主存的映射替换算法和写策略.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"Cache和主存的映射·替换算法·写策略\"><a href=\"#Cache和主存的映射·替换算法·写策略\" class=\"headerlink\" title=\"Cache和主存的映射·替换算法·写策略\"></a>Cache和主存的映射·替换算法·写策略</h1><h2 id=\"映射\"><a href=\"#映射\" class=\"headerlink\" title=\"映射\"></a>映射</h2><p>Cache行中的信息是主存某个块的副本<br>地址映射：将主存地址空间映射到Cache地址空间，按某种规则将主存的信息装入Cache<br>Cache的行数比主存块少的多，只有一部分主存块的信息可以装入Cache中，因此在Cache中需要为每块加一个<strong>标记</strong>，指明它是主存的哪一块的副本，此标记相当于主存块的编号。为了说明Cache行中的信息是否有效还需要一个<strong>有效位</strong>，地址映射以下3种：</p>\n<ul>\n<li>直接映射</li>\n<li>全相联映射</li>\n<li>组相联映射</li>\n</ul>\n<h3 id=\"直接映射\"><a href=\"#直接映射\" class=\"headerlink\" title=\"直接映射\"></a>直接映射</h3><p>Cache 行号 &#x3D; 主存块号 mod Cache 总行数<br>假设 Cache : $2^c$行 主存 : $2^m$块<br>$0,2^c,2^{c+1},\\dots$块映射到第0行<br>$1,2^c+1,2^{c+1}+1$块映射到第1行<br>低c位为装入的Cache行号，给每行设置一个长为t&#x3D;m-c的标记，当某个主存块调入Cache后，将主存块号的高t位设置为对应Cache行中的标记  </p>\n<table>\n<thead>\n<tr>\n<th>t</th>\n<th>c</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标记</td>\n<td>Cache行号</td>\n<td>块内地址</td>\n</tr>\n</tbody></table>\n<p>CPU访存过程：</p>\n<ul>\n<li>根据访存地址中间的c位找到对应Cache行</li>\n<li>Cache行标记与主存地址高t位标记比较，确定是否有效</li>\n<li>相等且有效位为1，访问Cache命中，根据主存地址低b位的块内地址，在对应Cache行中存取信息</li>\n<li>不相等或有效位为0，不命中，CPU将主存读出该地址所在的一块信息送到相应的Cache行中，置有效位1，并将标记设置为地址高t位，同时将地址中的内容送CPU</li>\n</ul>\n<h3 id=\"全相联映射\"><a href=\"#全相联映射\" class=\"headerlink\" title=\"全相联映射\"></a>全相联映射</h3><p>主存的每一块可以装入Cache中的任何位置，每行<strong>标记</strong>用于指出该行取自主存的哪一块，CPU访存时需要与所有Cache行的标记进行对比  </p>\n<table>\n<thead>\n<tr>\n<th>t</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标记</td>\n<td>块内地址</td>\n</tr>\n</tbody></table>\n<h3 id=\"组相联映射\"><a href=\"#组相联映射\" class=\"headerlink\" title=\"组相联映射\"></a>组相联映射</h3><p>将Cache分为Q个大小相等的组，每个主存块可以装入固定组的任意一行，即组间采用直接映射，而组内采用全相联映射，Q&#x3D;1变为全相联映射，Q&#x3D;Cache行数变为直接映射<br>假设r个Cache行，则称之为r路组相联映射<br>Cache组号&#x3D;主存块号 mod Cache组数(Q)  </p>\n<table>\n<thead>\n<tr>\n<th>t</th>\n<th>g</th>\n<th>b</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标记</td>\n<td>组号</td>\n<td>块内地址</td>\n</tr>\n</tbody></table>\n<p>CPU访存：</p>\n<ul>\n<li>根据访存地址中间的g位组号找到对应的Cache组</li>\n<li>将对应的Cache组的每个行标记与主存的高t位标记进行比较</li>\n<li>相等且有效位为1，命中，根据主存地址中的低b位块内地址，在对应的Cache行中存取信息</li>\n<li>不相等或有效位为0，未命中，CPU从主存读出该地址所在的一块信息送到对应的Cache组的任意一个空行，有效位置1，设置标记，同时将地址中的内容送CPU</li>\n</ul>\n<h2 id=\"替换算法\"><a href=\"#替换算法\" class=\"headerlink\" title=\"替换算法\"></a>替换算法</h2><p>在采用全相联映射或组相联映射方式时，主存向Cache传送一个新块，Cache或Cache组空间已满替换的策略</p>\n<ul>\n<li>RAND</li>\n<li>FIFO</li>\n<li>LRU</li>\n</ul>\n<h2 id=\"写策略\"><a href=\"#写策略\" class=\"headerlink\" title=\"写策略\"></a>写策略</h2><p>因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略，使Cache内容和主存保持一致<br>对于Cache写命中：</p>\n<ul>\n<li>全写法：当CPU对Cache写命中时，必须八数据同时写入Cache和内存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖。</li>\n<li>回写法：当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有当此块被换出时，才写入主存。每个Cache行设置一个修改位（脏位），若修改位为1，Cache行被修改过，替换时需要写回主存，若为0，则说明Cache行中的块未被命中，替换时无需写回</li>\n</ul>\n<p>对于Cache写不命中：</p>\n<ul>\n<li>写分配法：加载主存中的块到Cache中，然后更新这个Cache块</li>\n<li>非写分配法：只写入主存，不进行调块</li>\n</ul>\n","text":"Cache和主存的映射·替换算法·写策略映射Cache行中的信息是主存某个块的副本<br>地址映射：将主存地址空间映射到Cache地址空间，按某种规则将主存的信息装入Cache<br>Cache的行数比主存块少的多，只有一部分主存块的信息可以装入Cache中，因此在Cache中需","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"计算机组成原理·指令系统","slug":"计算机组成原理·指令系统","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.389Z","comments":false,"pin":null,"path":"api/articles/计算机组成原理·指令系统.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"指令系统\"><a href=\"#指令系统\" class=\"headerlink\" title=\"指令系统\"></a>指令系统</h1><h2 id=\"指令系统-1\"><a href=\"#指令系统-1\" class=\"headerlink\" title=\"指令系统\"></a>指令系统</h2><p>是指令集体系结构ISA的核心<br>ISA主要包括：</p>\n<ul>\n<li>指令格式</li>\n<li>数据类型及格式</li>\n<li>操作数的存放方式</li>\n<li>程序可访问的寄存器个数、位数和编号 </li>\n<li>存储空间大小和编址方式</li>\n<li>寻址方式</li>\n<li>指令执行过程的控制方式等</li>\n</ul>\n<h3 id=\"指令的基本格式\"><a href=\"#指令的基本格式\" class=\"headerlink\" title=\"指令的基本格式\"></a>指令的基本格式</h3><p>一条指令包括操作码和地址码字段</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>操作码</td>\n<td>地址码</td>\n</tr>\n</tbody></table>\n<p>操作码:</p>\n<ul>\n<li>指出指令应执行的操作</li>\n<li>识别指令</li>\n<li>了解指令功能</li>\n<li>区分操作数地址内容的组成和使用方法</li>\n</ul>\n<p>地址码：</p>\n<ul>\n<li>给出被操作的信息的地址</li>\n<li>参加运算的一个或多个操作数所在的地址</li>\n<li>运算结果的保存地址</li>\n<li>程序的转移地址</li>\n<li>被调用的子程序的入口地址等</li>\n</ul>\n<p>指令长度是指一条指令中包含的二进制代码的位数<br>指令字长取决于</p>\n<ul>\n<li>操作码的长度</li>\n<li>操作数地址码的长度</li>\n<li>操作数地址个数</li>\n</ul>\n<p>单字长指令：等于机器字长<br>半字长指令：一半机器字长<br>双字长指令：二倍机器字长<br>定长指令字结构：一个指令系统所有指令的长度都是相等的  </p>\n<h4 id=\"零地址指令：无显示地址\"><a href=\"#零地址指令：无显示地址\" class=\"headerlink\" title=\"零地址指令：无显示地址\"></a>零地址指令：无显示地址</h4><table>\n<thead>\n<tr>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OP</td>\n</tr>\n</tbody></table>\n<ul>\n<li>不需要操作数的指令</li>\n<li>零地址运算指令仅用于堆栈计算机，通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出，送至运算器，运算结果再隐含的压入堆栈</li>\n</ul>\n<p>一地址指令：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OP</td>\n<td>$A_1$</td>\n</tr>\n</tbody></table>\n<p>OP($A_1$) $\\to$ $A_1$</p>\n<ul>\n<li>只有目的操作数，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址</li>\n</ul>\n<p>(ACC)OP($A_1$) $\\to$ ACC</p>\n<ul>\n<li>隐含约定目的地址的双操作数指令，按指令地址$A_1$地址读取操作数，指令可隐含约定另一个操作数由ACC提供，运算结果也将存放在ACC中</li>\n<li>若指令长度为32位，操作码占8位，1个地址码字段占24位，指令操作数直接寻址范围$2^{24}&#x3D;16M$</li>\n</ul>\n<h4 id=\"二地址指令\"><a href=\"#二地址指令\" class=\"headerlink\" title=\"二地址指令\"></a>二地址指令</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OP</td>\n<td>$A_1$</td>\n<td>$A_2$</td>\n</tr>\n</tbody></table>\n<p>($A_1$)OP($A_2$) $\\to$ $A_1$</p>\n<ul>\n<li>常用的算术和逻辑运算指令，需要两个操作数，需要分别给出目的操作数和源操作数，其中目的操作数地址还用于存放本次运算结果</li>\n<li>指令字长位32位，操作码占8位，两个地址码各占12位，则指令操作数的直接寻址范围$2^{12}&#x3D;4K$</li>\n</ul>\n<h4 id=\"三地址指令\"><a href=\"#三地址指令\" class=\"headerlink\" title=\"三地址指令\"></a>三地址指令</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OP</td>\n<td>$A_1$</td>\n<td>$A_2$</td>\n<td>$A_3$(结果)</td>\n</tr>\n</tbody></table>\n<p>($A_1$)OP($A_2$) $\\to$ $A_3$</p>\n<ul>\n<li>指令字长位32位，操作码占8位，3个地址码各占8位，直接寻址范围$2^8&#x3D;256$，地址字段为主存地址，则完成一条三地址需要4次访存，取指令1次，取两个操作数2次，存放结果1次</li>\n</ul>\n<h4 id=\"四地址指令\"><a href=\"#四地址指令\" class=\"headerlink\" title=\"四地址指令\"></a>四地址指令</h4><table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>OP</td>\n<td>$A_1$</td>\n<td>$A_2$</td>\n<td>$A_3$</td>\n<td>$A_4$</td>\n</tr>\n</tbody></table>\n<p>($A_1$)OP($A_2$) $\\to$ $A_3$ ，$A_4$ &#x3D; 下一条执行指令的地址</p>\n<ul>\n<li>地址字长为32位，操作码占8位，4个地址码各占6位，直接寻址范围$2^6&#x3D;64$</li>\n</ul>\n<h3 id=\"定长操作码指令格式\"><a href=\"#定长操作码指令格式\" class=\"headerlink\" title=\"定长操作码指令格式\"></a>定长操作码指令格式</h3><p>在指令字的最高位部分分配固定的若干位（定长）表示操作码。<br>n位操作码字段的指令系统最大能表示$2^{n}$条指令</p>\n<h3 id=\"扩展操作码指令格式\"><a href=\"#扩展操作码指令格式\" class=\"headerlink\" title=\"扩展操作码指令格式\"></a>扩展操作码指令格式</h3><ul>\n<li>不允许短码是长码的前缀</li>\n<li>各指令的操作码一定不能重复</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0000</td>\n<td>0001</td>\n<td>0010</td>\n<td>0011</td>\n</tr>\n<tr>\n<td>0100</td>\n<td>0101</td>\n<td>0110</td>\n<td>0111</td>\n</tr>\n<tr>\n<td>1000</td>\n<td>1001</td>\n<td>1010</td>\n<td>1011</td>\n</tr>\n<tr>\n<td>1100</td>\n<td>1101</td>\n<td>1110</td>\n<td>1111</td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>操作码情况</td>\n<td>OP</td>\n<td>$A_1$</td>\n<td>$A_2$</td>\n<td>$A_3$</td>\n<td>说明</td>\n</tr>\n<tr>\n<td>15条三地址</td>\n<td>0000-1110</td>\n<td></td>\n<td></td>\n<td></td>\n<td>余出16-15&#x3D;1，1*2^4&#x3D;16种</td>\n</tr>\n<tr>\n<td>12条二地址</td>\n<td>1111</td>\n<td>0000-1011</td>\n<td></td>\n<td></td>\n<td>余出16-12&#x3D;4，4*2^4&#x3D;64种</td>\n</tr>\n<tr>\n<td>62条一地址</td>\n<td>1111</td>\n<td>(1100-1110)&#x2F;1111</td>\n<td>(0000-1111)&#x2F;(0000-1101)</td>\n<td></td>\n<td>余出64-62&#x3D;2，2*2^4&#x3D;32种</td>\n</tr>\n<tr>\n<td>32条零地址</td>\n<td>1111</td>\n<td>1111</td>\n<td>1110-1111</td>\n<td>0000-1111</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"指令的操作类型\"><a href=\"#指令的操作类型\" class=\"headerlink\" title=\"指令的操作类型\"></a>指令的操作类型</h3><ul>\n<li>数据传送</li>\n<li>算术和逻辑运算</li>\n<li>移位</li>\n<li>转移</li>\n<li>输入输出</li>\n</ul>\n<h2 id=\"指令寻址方式\"><a href=\"#指令寻址方式\" class=\"headerlink\" title=\"指令寻址方式\"></a>指令寻址方式</h2><p>确定本条指令的数据地址以及下一条待执行指令的地址，分为：</p>\n<ul>\n<li><p>指令寻址：寻找下条要执行的指令<br>（1）顺序寻址<br>通过PC+(1)，自动形成下一条指令<br>（2）跳跃寻址<br>通过转移指令实现，下条指令的地址不由PC自动给出，而由本条指令给出下条指令地址的计算方式。是否可跳跃受到状态寄存器和操作数的控制，跳跃的结果是当前指令修改PC值，下一条指令仍通过PC给出</p>\n</li>\n<li><p>数据寻址：寻找本条指令的数据<br>通常在指令字中设一个字段指明寻址方式</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>操作码</td>\n<td>寻址特征</td>\n<td>形式地址A</td>\n</tr>\n</tbody></table>\n</li>\n</ul>\n<h3 id=\"常见数据寻址方式\"><a href=\"#常见数据寻址方式\" class=\"headerlink\" title=\"常见数据寻址方式\"></a>常见数据寻址方式</h3><h4 id=\"隐含寻址\"><a href=\"#隐含寻址\" class=\"headerlink\" title=\"隐含寻址\"></a>隐含寻址</h4><p>不明显的给出操作数，在指令中隐含操作数地址</p>\n<ul>\n<li>优：有利于缩短指令字长</li>\n<li>缺：需要增加存储操作数或隐含地址的硬件</li>\n</ul>\n<h4 id=\"立即（数）寻址\"><a href=\"#立即（数）寻址\" class=\"headerlink\" title=\"立即（数）寻址\"></a>立即（数）寻址</h4><p>指令的地址字段指出的不是操作数地址，而是操作数本身，又称立即数，#表示立即寻址特征，使用补码表示</p>\n<ul>\n<li>优：指令在执行阶段不访问主存，指令执行时间最短</li>\n<li>缺：A的位数限制立即数的范围</li>\n</ul>\n<h4 id=\"直接寻址\"><a href=\"#直接寻址\" class=\"headerlink\" title=\"直接寻址\"></a>直接寻址</h4><p>指令中的形式地址A是操作数的真实地址EA，EA&#x3D;A  </p>\n<ul>\n<li>优：简单，访存1次，不需要专门计算操作数的地址</li>\n<li>缺：A的位数决定了指令操作数的寻址范围，操作数的地址不易修改</li>\n</ul>\n<h4 id=\"间接寻址\"><a href=\"#间接寻址\" class=\"headerlink\" title=\"间接寻址\"></a>间接寻址</h4><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址的存储单元地址，EA&#x3D;(A)，间接寻址可以迭代多次<br>间接寻址，主存第一位表示是否为多次间址</p>\n<ul>\n<li>优：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间址寻址可方便的完成子程序返回）</li>\n<li>缺：访问速度慢</li>\n</ul>\n<h4 id=\"寄存器寻址\"><a href=\"#寄存器寻址\" class=\"headerlink\" title=\"寄存器寻址\"></a>寄存器寻址</h4><p>指令字中直接给出操作数所在的寄存器编号EA&#x3D; $R_i$，操作数在由$R_i$所指的寄存器内</p>\n<ul>\n<li>优：指令执行阶段不访存，只访问寄存器，寄存器对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量&#x2F;矩阵运算</li>\n<li>缺:寄存器昂贵，有限</li>\n</ul>\n<h4 id=\"寄存器间接寻址\"><a href=\"#寄存器间接寻址\" class=\"headerlink\" title=\"寄存器间接寻址\"></a>寄存器间接寻址</h4><p>寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址EA&#x3D;($R_i$)</p>\n<ul>\n<li>优：与一般间址寻址速度快</li>\n<li>缺：需要访存</li>\n</ul>\n<h4 id=\"相对寻址\"><a href=\"#相对寻址\" class=\"headerlink\" title=\"相对寻址\"></a>相对寻址</h4><p>PC的内容加上指令格式的形式地址A而形成操作数的有效地址EA&#x3D;(PC)+A，A是相对于当前PC的值的位移量，可正可负，用补码表示，A的位数决定寻址范围</p>\n<ul>\n<li>操作数的地址是不固定的，随PC的值变化而变化，且与指令地址之间相差一个固定值，便于程序浮动，广泛用于转移指令</li>\n<li>JMP A，CPU从存储器取出一字节，自动执行(PC)+1 $\\to$ PC，若转移指令的地址为X，且占2B，取出该指令后，PC自增2，(PC)&#x3D;X+2，执行完该指令，会自动跳转至X+2+A的地址继续执行</li>\n</ul>\n<h4 id=\"基址寻址\"><a href=\"#基址寻址\" class=\"headerlink\" title=\"基址寻址\"></a>基址寻址</h4><p>将CPU的基址寄存器BR的内容加上指令格式的形式地址A形成操作数的有效地址EA&#x3D;(BR)+A，基址寄存器可采用专用寄存器也可为通用寄存器</p>\n<ul>\n<li><p>基址寄存器面向操作系统，内容通过操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性</p>\n</li>\n<li><p>执行过程中基址寄存器内容不变，形式地址可变（偏移量）</p>\n</li>\n<li><p>采用通用寄存器作为基址寄存器，用户可决定使用哪个寄存器，内容由操作系统确定</p>\n</li>\n<li><p>优：可扩大寻址范围（基址寄存器位数大于形式地址A的位数），用户不必考虑自己的程序存于主存哪个区域，有利于多道程序设计，可用于制成浮动程序</p>\n</li>\n<li><p>缺：偏移量位数较短</p>\n</li>\n</ul>\n<h4 id=\"变址寻址\"><a href=\"#变址寻址\" class=\"headerlink\" title=\"变址寻址\"></a>变址寻址</h4><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，EA&#x3D;(IX)+A</p>\n<ul>\n<li>IX可使用专用寄存器或通用寄存器</li>\n<li>变址寄存器面向用户，在程序执行过程，变址寄存器内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）</li>\n<li>可扩大寻址范围（变址寄存器位数大于形式地址A的位数），适合编制循环程序，偏移量的位数（IX）足以表示整个存储空间</li>\n</ul>\n<h4 id=\"堆栈寻址\"><a href=\"#堆栈寻址\" class=\"headerlink\" title=\"堆栈寻址\"></a>堆栈寻址</h4><p>堆栈是存储器（或专用寄存器组）中一块特定的、按照后进先出（LIFO）的原则管理的存储区，存储区读写单元地址是用一个特定寄存器给出的称为堆栈指针(SP)，分为硬堆栈（不适合做大容量堆栈）和软堆栈（主存划出一段区域）</p>\n<table>\n<thead>\n<tr>\n<th>寻址方式</th>\n<th>有效地址</th>\n<th>访存次数</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>隐含寻址</td>\n<td>程序指定</td>\n<td>0</td>\n</tr>\n<tr>\n<td>立即寻址</td>\n<td>A是操作数</td>\n<td>0</td>\n</tr>\n<tr>\n<td>直接寻址</td>\n<td>EA&#x3D;A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>一次间接寻址</td>\n<td>EA&#x3D;(A)</td>\n<td>2</td>\n</tr>\n<tr>\n<td>寄存器寻址</td>\n<td>EA&#x3D; $R_i$</td>\n<td>0</td>\n</tr>\n<tr>\n<td>寄存器间接一次寻址</td>\n<td>EA &#x3D; ($R_i$)</td>\n<td>1</td>\n</tr>\n<tr>\n<td>相对寻址</td>\n<td>EA&#x3D;(PC)+A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>基址寻址</td>\n<td>EA&#x3D;(BR)+A</td>\n<td>1</td>\n</tr>\n<tr>\n<td>变址寻址</td>\n<td>EA&#x3D;(IX)+A</td>\n<td>1</td>\n</tr>\n</tbody></table>\n","text":"指令系统指令系统是指令集体系结构ISA的核心<br>ISA主要包括：指令格式数据类型及格式操作数的存放方式程序可访问的寄存器个数、位数和编号 存储空间大小和编址方式寻址方式指令执行过程的控制方式等指令的基本格式一条指令包括操作码和地址码字段操作码地址码操作码:指出指令应执行的操作","raw":null,"photos":[],"categories":[],"tags":[]},{"title":"计算机组成原理·虚拟存储器页式段式和段页式","slug":"计算机组成原理·虚拟存储器页式段式和段页式","date":"2021-04-06T04:01:51.000Z","updated":"2024-06-30T07:40:05.407Z","comments":false,"pin":null,"path":"api/articles/计算机组成原理·虚拟存储器页式段式和段页式.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"虚拟存储器·页式·段式·段页式\"><a href=\"#虚拟存储器·页式·段式·段页式\" class=\"headerlink\" title=\"虚拟存储器·页式·段式·段页式\"></a>虚拟存储器·页式·段式·段页式</h1><p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>\n<ul>\n<li>实地址 &#x3D; 主存页号 + 页内字地址</li>\n<li>虚地址 &#x3D; 虚存页号 + 页内字地址</li>\n<li>辅存地址 &#x3D; 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>\n</ul>\n<p>CPU使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>\n<ul>\n<li>在内存，通过地址变换，CPU可直接访问主存指示的数据单元</li>\n<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>\n</ul>\n<h2 id=\"页式虚拟存储器\"><a href=\"#页式虚拟存储器\" class=\"headerlink\" title=\"页式虚拟存储器\"></a>页式虚拟存储器</h2><p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong>  </p>\n<h3 id=\"页表\"><a href=\"#页表\" class=\"headerlink\" title=\"页表\"></a>页表</h3><p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>\n<table>\n<thead>\n<tr>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>有效位</td>\n<td>脏位</td>\n<td>引用位</td>\n<td>物理页</td>\n</tr>\n</tbody></table>\n<ul>\n<li>有效位（装入位）：表示对应页是否在主存</li>\n<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>\n<li>引用位（使用位）：配合替换算法进行设置</li>\n</ul>\n<p>CPU运行指令时，虚地址转实地址：</p>\n<ul>\n<li>页表基址寄存器存放进程的页表首地址</li>\n<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>\n<li>装入位为1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>\n<li>装入位为0，说明缺页，需要操作系统进行缺页处理</li>\n</ul>\n<h3 id=\"快表-TLB\"><a href=\"#快表-TLB\" class=\"headerlink\" title=\"快表(TLB)\"></a>快表(TLB)</h3><p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>快表通常采用组相联或全相联方式</p>\n<table>\n<thead>\n<tr>\n<th>t</th>\n<th>r</th>\n<th>p</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>标记</td>\n<td>有效位</td>\n<td>实页号</td>\n</tr>\n</tbody></table>\n<h3 id=\"具有TLB和Cache的多级存储系统\"><a href=\"#具有TLB和Cache的多级存储系统\" class=\"headerlink\" title=\"具有TLB和Cache的多级存储系统\"></a>具有TLB和Cache的多级存储系统</h3><p>三种缺失的情况  </p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>TLB</th>\n<th>Page</th>\n<th>Cache</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>命中</td>\n<td>命中</td>\n<td>命中</td>\n<td>TLB命中则Page一定命中，信息在主存，就可能在Cache</td>\n</tr>\n<tr>\n<td>2</td>\n<td>命中</td>\n<td>命中</td>\n<td>缺失</td>\n<td>TLB命中则Page一定命中，信息在主存，也可能不在Cache</td>\n</tr>\n<tr>\n<td>3</td>\n<td>缺失</td>\n<td>命中</td>\n<td>命中</td>\n<td>TLB缺失但Page可能命中，信息在主存，就可能在Cache</td>\n</tr>\n<tr>\n<td>4</td>\n<td>缺失</td>\n<td>命中</td>\n<td>缺失</td>\n<td>TLB缺失但Page一定命中，信息在主存，也可能不在Cache</td>\n</tr>\n<tr>\n<td>5</td>\n<td>缺失</td>\n<td>缺失</td>\n<td>缺失</td>\n<td>TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache</td>\n</tr>\n</tbody></table>\n<h2 id=\"段式虚拟存储器\"><a href=\"#段式虚拟存储器\" class=\"headerlink\" title=\"段式虚拟存储器\"></a>段式虚拟存储器</h2><p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>段号</td>\n<td>段首地址</td>\n<td>装入位</td>\n<td>段长</td>\n</tr>\n</tbody></table>\n<p>CPU访存时：</p>\n<ul>\n<li>根据段号与段表基地址拼接成对应的段表行</li>\n<li>根据段表行的装入位判断是否调入内存</li>\n<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址</li>\n</ul>\n<h2 id=\"段页式虚拟存储器\"><a href=\"#段页式虚拟存储器\" class=\"headerlink\" title=\"段页式虚拟存储器\"></a>段页式虚拟存储器</h2><p>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍  </p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>段号</td>\n<td>段内页号</td>\n<td>页内地址</td>\n</tr>\n</tbody></table>\n<p>CPU访存：</p>\n<ul>\n<li>根据段号得到段表地址</li>\n<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>\n<li>从页表中取出实页号，与页内地址拼接形成实地址</li>\n</ul>\n<h2 id=\"虚拟存储器与Cache的比较\"><a href=\"#虚拟存储器与Cache的比较\" class=\"headerlink\" title=\"虚拟存储器与Cache的比较\"></a>虚拟存储器与Cache的比较</h2><table>\n<thead>\n<tr>\n<th>相同</th>\n<th>不同</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>目的均为提供系统性能</td>\n<td>Cache主要解决系统速度，虚拟存储器解决主存容量</td>\n</tr>\n<tr>\n<td>均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大</td>\n<td>Cache由硬件实现，对程序员透明，虚拟存储器由OS和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明</td>\n</tr>\n<tr>\n<td>都有地址的映射、替换算法、更新策略</td>\n<td></td>\n</tr>\n<tr>\n<td>均依据程序的局部性原理</td>\n<td></td>\n</tr>\n</tbody></table>\n","text":"虚拟存储器·页式·段式·段页式主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>实际的主存单元地址称为","raw":null,"photos":[],"categories":[],"tags":[]}]}