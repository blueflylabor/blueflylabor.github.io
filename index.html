<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>ebxeax</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="ebxeax">
<meta property="og:url" content="http://ebxeax.github.io/index.html">
<meta property="og:site_name" content="ebxeax">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="ebx">
<meta property="article:tag" content="blog">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ebxeax" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ebxeax</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Suche"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://ebxeax.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-中央处理器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.346Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>控制器：负责协调并控制计算机各部件执行程序的指令序列：取指令、分析指令、执行指令<br>运算器：对数据加工</p>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>数据加工</li>
<li>时间控制</li>
<li>中断处理</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>运算器和控制器两大部分组成<br>运算器：</p>
<ul>
<li>算术逻辑单元（ALU）</li>
<li>暂存寄存器</li>
<li>累加寄存器（ACC）</li>
<li>通用寄存器组（AX&#x2F;BX&#x2F;CX&#x2F;DX&#x2F;SP）</li>
<li>程序状态字寄存器（PSW：OF&#x2F;SF&#x2F;ZF&#x2F;CF）</li>
<li>移位器</li>
<li>计数器</li>
</ul>
<p>控制器（CU）：</p>
<ul>
<li>程序计数器（PC）</li>
<li>指令寄存器（IR）</li>
<li>指令译码器</li>
<li>存储器地址寄存器</li>
<li>存储器数据寄存器</li>
<li>时序系统</li>
<li>微操作信号发生器</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>CPU从主存取出并执行一条指令的时间，指令周期通常使用若干机器周期表示，每个机器周期可等长或不等，一个机器周期包含若干时钟周期（节拍），每个机器周期内的时钟周期数可以不等</p>
<ul>
<li>无条件转移指令：执行阶段不需要访存，只包含取指阶段（取指和分析）和执行阶段</li>
<li>间接寻址指令：为了取操作数，需要先访1次，取出有效地址，然后访存，取出操作数，所有需要包含间址周期，介于取指和执行之间</li>
<li>CPU采用中断方式实现主机和I&#x2F;O设备的信息交换，CPU在每条指令结束前，都要发送中断查询信号，若有中断请求，CPU进入中断响应阶段（中断周期）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>取指周期</td>
<td>间址周期</td>
<td>执行周期</td>
<td>中断周期</td>
</tr>
</tbody></table>
<p>只有访存的目的不同，取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点<br>CPU内设置了4个标志触发器FE&#x2F;IND&#x2F;EX&#x2F;INT</p>
<table>
<thead>
<tr>
<th>FE</th>
<th>IND</th>
<th>EX</th>
<th>INT</th>
</tr>
</thead>
<tbody><tr>
<td>Fetch</td>
<td>Index</td>
<td>Execute</td>
<td>Interrupt</td>
</tr>
<tr>
<td>取值</td>
<td>间址</td>
<td>执行</td>
<td>中断</td>
</tr>
</tbody></table>
<h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>根据PC中的内容从主存取出指令代码放入IR  </p>
<ul>
<li>PC $\to$ IR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\to$ DataBus $\to$ MDR $\to$ Mem</li>
<li>Mem $\to$ DataBus $\to$ MDR $\to$ IR（存放指令）</li>
<li>CU $\stackrel{SignalControl::FE}{\longrightarrow}$ [(PC) + 1 $\to$ PC]</li>
</ul>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>取操作数有效地址，间址为例：指令中的地址码送到MAR并送至地址总线，CU向存储器发送读命令，以获取有效地址并存在MDR  </p>
<ul>
<li>Addr(IR) &#x2F; MDR $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI&#x2F;O::READ}{\longrightarrow}$ ControlBus $\to$ Mem（存放有效地址）</li>
<li>Mem $\to$ DataBus $\to$ MDR</li>
</ul>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><p>取操作数，根据IR的指令字的操作码通过ALU操作产生执行结果</p>
<ul>
<li>无统一的数据流向</li>
</ul>
<h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>处理中断请求，假设程序断点存入堆栈，用SP指示栈顶地址，入栈操作是先修改栈顶指针，后存入数据</p>
<ul>
<li>CU $\stackrel{SignalStack::SP}{\longrightarrow}$ [(SP) - 1 $\to$ SP] $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI&#x2F;O::WRITE}{\longrightarrow}$ ControlBus $\to$ Mem</li>
<li>PC $\to$ MDR $\to$ DataBus $\to$ Mem（程序断点存入主存）</li>
<li>CU $\to$ PC（中断服务程序的入口地址送至PC）</li>
</ul>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul>
<li>单指令周期</li>
<li>多指令周期</li>
<li>流水线方案</li>
</ul>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>数据通路：数据在功能部件之间传输的路径<br>由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号<br>数据通路功能：实现CPU内部的运算器与寄存器以及寄存器之间的数据交换</p>
<h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>CPU内部单总线模式<br>所有寄存器的输入输出端都连接在一条公共通路上，结构简单但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构，CPU中有两条或更多的总线时，构成双总线结构或多总线结构</li>
<li>CPU内部多总线模式<br>所有寄存器的输入输出端都连接在多条公共通路上，相比之下单总线在一个时钟内只允许传一个数据，因此指令执行效率很低，因此在多总线方式，同时在多总线上传输不同的数据，提高效率</li>
<li>专用数据通路方式<br>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大</li>
</ul>
<h4 id="寄存器之间的数据传输"><a href="#寄存器之间的数据传输" class="headerlink" title="寄存器之间的数据传输"></a>寄存器之间的数据传输</h4><p>通过内部总线完成<br>寄存器AX的输入输出由AXout和AXin控制  </p>
<ul>
<li>(PC) $\to$ MAR，PCout和MARin有效</li>
</ul>
<h4 id="主存与CPU之间的数据传输"><a href="#主存与CPU之间的数据传输" class="headerlink" title="主存与CPU之间的数据传输"></a>主存与CPU之间的数据传输</h4><p>主存与CPU之间的数据传输需要借助CPU内部总线完成<br>主存内读取</p>
<ul>
<li>(PC) $\to$ MAR，PCout和MARin有效  </li>
<li>1 $\to$ R，CU发出读命令  </li>
<li>MEM(MAR) $\to$ MDR，MDRin有效  </li>
<li>(MDR) $\to$ IR，MDRout和IRin有效</li>
</ul>
<h4 id="执行算术或逻辑算术"><a href="#执行算术或逻辑算术" class="headerlink" title="执行算术或逻辑算术"></a>执行算术或逻辑算术</h4><p>由于ALU没有内部存储功能，执行加法操作，相加的两个数必须在ALU的两个输入输出端同时有效</p>
<ul>
<li>(MDR) $\to$ MAR，MDRout和MARin有效  </li>
<li>1 $\to$ R，CU读命令</li>
<li>MEM(MAR) $\to$ 操作数从主存送至MDR</li>
<li>(MDR) $\to$ Y，MDRout和Yin有效</li>
<li>(ACC) + (Y) $\to$ Z ACCout和ALUin有效</li>
<li>(Z) $\to$ ACC，Zout和ACCin有效</li>
</ul>
<h2 id="控制器功能与原理"><a href="#控制器功能与原理" class="headerlink" title="控制器功能与原理"></a>控制器功能与原理</h2><h3 id="结构和功能"><a href="#结构和功能" class="headerlink" title="结构和功能"></a>结构和功能</h3><ul>
<li>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据</li>
<li>输入设备和输出设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传输数据</li>
<li>控制器部件从数据总线接受指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件通过运算所需的控制信号</li>
</ul>
<p>控制器功能：</p>
<ul>
<li>从主存取指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、主存、输入输出设备之间的数据流动方向</li>
</ul>
<p>根据控制器产生微操作控制信号的方式不同，控制器可分为</p>
<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
</ul>
<p>两类控制器的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制部件各部件运算所需控制信号的方案不同</p>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul>
<li>根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号</li>
<li>由复杂的组合逻辑门电路和一些触发器构成</li>
</ul>
<h4 id="硬布线控制单元"><a href="#硬布线控制单元" class="headerlink" title="硬布线控制单元"></a>硬布线控制单元</h4><p>指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键<br>CU的输入信号来源：</p>
<ul>
<li>经指令译码器译码产生的信息指令</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信号（标志）</li>
<li>系统总线（控制总线）控制信号（中断请求、DMA请求）</li>
</ul>
<h4 id="硬布线控制器的时序系统及微操作"><a href="#硬布线控制器的时序系统及微操作" class="headerlink" title="硬布线控制器的时序系统及微操作"></a>硬布线控制器的时序系统及微操作</h4><ul>
<li>时钟周期<br>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度对应一个时钟周期，每个节拍内机器可以完成一个或几个需要同时执行的操作</li>
<li>机器周期<br>是所有指令执行过程的一个基准时间，访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期，在存储字长等于指令字长前提下，取指周期视为机器周期</li>
<li>指令周期</li>
<li>微操作命令分析<br>控制单元具有发出各种操作命令（控制信号）序列的功能，这些命令与指令有关</li>
</ul>
<p>执行过程，一条指令分为3个工作周期：取指周期、间址周期、执行周期  </p>
<p>取指周期  </p>
<ul>
<li>(PC) $\to$ MAR  </li>
<li>1 $\to$ R  </li>
<li>M(MAR) $\to$ MDR</li>
<li>(MDR) $\to$ IR</li>
<li>OP(IR) $\to$ CU</li>
<li>(PC) + 1  $\to$ PC</li>
</ul>
<p>间址周期</p>
<ul>
<li>Addr(IR) $\to$ MAR</li>
<li>1  $\to$ R</li>
<li>M(MAR)  $\to$ MDR</li>
</ul>
<p>执行周期  </p>
<ul>
<li>非访存指令  </li>
<li>访存指令</li>
</ul>
<h4 id="CPU控制方式"><a href="#CPU控制方式" class="headerlink" title="CPU控制方式"></a>CPU控制方式</h4><ul>
<li>同步控制方式<br>具有统一的时钟，所有控制信号均来自统一的时钟信号</li>
<li>异步控制方式<br>不存在基准时标信号，各部件按自身固有的速度工作，以应答方式联络</li>
<li>联合控制方式<br>大部分采用同步控制，小部分采用异步控制</li>
</ul>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>采用存储逻辑实现,把微操作信号代码化,使每条机器指令转化为一段微程序并存入一个专门的存储器（控制存储器），微操作控制信号由微指令产生</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>微操作和微命令<br>一条机器指令可以分解为一系列微操作序列，微操作是计算机中最基本、不可再分解的操作；微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，是构成控制系列的最小单位<br>微命令有相容性和互斥性</p>
</li>
<li><p>微指令和微周期<br>微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为微地址<br>一条微地址包括：<br>（1）操作控制字段（微操作码）：用于产生某一步操作所需的各种操作控制信号<br>（2）顺序控制字段（微地址码）：用于控制产生下一条要执行的微指令地址<br>微周期是执行一条微指令所需的时间，通常为一个时钟周期  </p>
</li>
<li><p>主存储器和控制存储器<br>主存储器M，用于存放程序和数据，在CPU外部，用RAM实现<br>控制存储器CM，用于存放微程序，在CPU内部，用ROM实现</p>
</li>
<li><p>程序和微程序<br>程序是指令的有序集合，用于完成某些特定的功能<br>微程序是微指令的有序集合，一条指令的给你由一段微程序实现<br>微程序和程序是两个不同的概念，微程序由微指令组成，描述机器指令，微程序实质是机器指令的实时解释器，由计算机设计者实现编制并存放于控制存储器CM中，无需知道，而程序最终由机器指令组成，由软件设计人员事先编制并存放于主存储器或辅助存储器</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAR</td>
<td>存放主存的读写地址</td>
<td>CMAR</td>
<td>存放控制存储器的读写微指令地址</td>
</tr>
<tr>
<td>IR</td>
<td>存放从主存中读出的指令</td>
<td>CMDR&#x2F;$\mu$IR</td>
<td>存放控制存储器中读出的微指令</td>
</tr>
</tbody></table>
<h4 id="组成-过程"><a href="#组成-过程" class="headerlink" title="组成&amp;过程"></a>组成&amp;过程</h4><ul>
<li>控制存储器：存放各指令对应的微程序</li>
<li>微指令寄存器：用于存放从CM中取出的微指令，位数同微指令字长相等</li>
<li>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行</li>
<li>微地址寄存器：接收微地址形成部件送来的微地址，为在CM中读取微指令作准备</li>
</ul>
<p>在微程序控制器的控制下计算器执行机器指令的过程：  </p>
<ul>
<li>执行取微指令：自动将取指微程序的入口地址送入CMAR，从CM中读取相应的微指令送入CMDR（取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完成，从主存取出的机器指令就已经存入指令寄存器中）</li>
<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令对应的微程序入口地址，并送入CMAR</li>
<li>从CM中逐条读取对应的微指令并执行</li>
<li>执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第一步</li>
</ul>
<p>微程序和机器指令：<br>一条机器指令对应一个微程序，由于机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编制为一个微程序，这个微程序只负责将指令从主存单元取出送入指令寄存器，也可编制对应的间址周期和中断周期的微程序<br>控制存储器CM中的微程序个数 &#x3D; 机器指令数+取指+间址+中断</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>又称微指令的控制方式，如何对微指令的控制字段进行编码，以形成控制信号  </p>
<ul>
<li><p>直接编码（直接控制）<br>无需进行译码，微指令的微命令字段中每位代表一个微命令，设计微指令，选用某个微命令只需将微命令对应的字段设置为1或0<br>优：简单直观速度快<br>缺：微指令字长过长，n个微命令要求微指令的操作字段有n位，造成控制存储器容量极大</p>
</li>
<li><p>字段直接编码<br>将微指令的微命令字段分成若干小字段，互斥性微命令组合在同一字段，相容性微命令组合在不同字段，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关<br>优:可以缩短微指令字长<br>缺：需要通过编译电路后发出微命令，较直接编译慢</p>
</li>
</ul>
<h4 id="地址形成方式"><a href="#地址形成方式" class="headerlink" title="地址形成方式"></a>地址形成方式</h4><ul>
<li>直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址（断定方式）</li>
<li>根据机器指令的操作码形成，机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
<li>增量计算器法：(CMAR) + 1 $\to$ CMAR</li>
<li>根据各种标志决定微指令分支转移地址</li>
<li>通过测试网络形成</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li>水平型：直接编码、字段直接编码、字段间接编码、混合编码</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$\dots$</td>
<td>$A_{n-1}$</td>
<td>$A_{n}$</td>
<td>判断测试字段</td>
<td>后继地址字段</td>
</tr>
<tr>
<td>操作控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>顺序控制</td>
<td></td>
</tr>
</tbody></table>
<p>优：微程序短，执行速快<br>缺：微指令长，编写微程序复杂  </p>
<ul>
<li>垂直型：采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>
</ul>
<table>
<thead>
<tr>
<th>$\mu$OP</th>
<th>Rd</th>
<th>Rs</th>
</tr>
</thead>
<tbody><tr>
<td>微操作码</td>
<td>目的地址</td>
<td>源地址</td>
</tr>
</tbody></table>
<p>优：微指令短、简单、规整，便于编写微程序<br>缺：微程序长，执行速度慢，工作效率低  </p>
<ul>
<li>混合型<br>在垂直型的基础上增加一些不太复杂的并行操作</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>水平型</th>
<th>垂直型</th>
</tr>
</thead>
<tbody><tr>
<td>并行能力</td>
<td>并行能力强、灵活性高、效率高</td>
<td>较差</td>
</tr>
<tr>
<td>执行时间</td>
<td>短</td>
<td>长</td>
</tr>
<tr>
<td>长度</td>
<td>微指令字较长，微程序较短</td>
<td>微指令字较短，微程序较长</td>
</tr>
<tr>
<td>难易程度</td>
<td>难</td>
<td>易</td>
</tr>
</tbody></table>
<h4 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h4><ul>
<li><p>动态微程序设计：根据用户的要求改变微程序，需要可写控制寄存器，使用EPROM</p>
</li>
<li><p>毫微程序设计：硬件不由微程序直接控制，通过存放在第二级控制存储器中的毫微程序来解释</p>
</li>
</ul>
<h4 id="微程序控制器和硬布线控制器比较"><a href="#微程序控制器和硬布线控制器比较" class="headerlink" title="微程序控制器和硬布线控制器比较"></a>微程序控制器和硬布线控制器比较</h4><table>
<thead>
<tr>
<th></th>
<th>微程序控制器</th>
<th>硬布线控制器</th>
</tr>
</thead>
<tbody><tr>
<td>工作原理</td>
<td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
<td>微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>规整性</td>
<td>较规整</td>
<td>烦琐、不规整</td>
</tr>
<tr>
<td>应用场合</td>
<td>CISC CPU</td>
<td>RISC CPU</td>
</tr>
<tr>
<td>易扩充性</td>
<td>容易</td>
<td>困难</td>
</tr>
</tbody></table>
<h3 id="异常（内中断）和中断"><a href="#异常（内中断）和中断" class="headerlink" title="异常（内中断）和中断"></a>异常（内中断）和中断</h3><p>异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常<br>硬故障中断：是由硬连线出现异常引起（存储器校验异常、总线错误）<br>程序性异常（软件中断）：CPU内部因执行指令而引起的（整除0、溢出、断点、单步跟踪、非法指令）<br>按照异常发生的原因和返回方式，可进一步分为故障、自陷、终止</p>
<ul>
<li><p>故障（Fault）<br>引起故障的指令启动后、执行结束前被检测到的异常，因为无法通过异常处理程序恢复故障，因此不能回到原断点处执行，必须终止进程的执行  </p>
</li>
<li><p>自陷（Trap）<br>事先安排的一种异常事件，事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志人为设置一个陷阱，当执行到被设置了陷阱的指令时，CPU在执行陷阱指令后，自动根据不同的陷阱类型进行相应的处理，然后返回到自陷程序下一条指令执行。当自陷指令是转移指令时，并不是返回到下一条指令执行，而不是返回到转移目标指令执行</p>
</li>
<li><p>终止（Abort）<br>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，程序将无法继续执行，只能终止，此时调出中断服务程序来重启系统，终止异常和外中断属于硬件中断</p>
</li>
</ul>
<p>中断是来自CPU外部、与CPU执行指令无关的事件引起的中断<br>中断的分类：</p>
<ul>
<li><p>可屏蔽中断<br>通过可屏蔽中断请求线INTR向CPU发出中断请求，CPU可通过设置相应的屏蔽字来屏蔽或不屏蔽某个中断</p>
</li>
<li><p>不可屏蔽中断<br>通过专门的不可屏蔽中断请求NMI向CPU发出的中断请求，通常是非常紧急的硬件故障</p>
</li>
</ul>
<p>中断和异常的不同：  </p>
<ul>
<li><p>缺页或溢出等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成  </p>
</li>
<li><p>异常的检测由CPU完成，不通过外部的某个信号通知CPU，中断CPU必须通过中断请求线获取中断源信息，才能知道哪个设备发生了何种中断</p>
</li>
</ul>
<h3 id="异常和中断响应过程"><a href="#异常和中断响应过程" class="headerlink" title="异常和中断响应过程"></a>异常和中断响应过程</h3><ul>
<li>关中断</li>
<li>保存断点和程序状态</li>
<li>识别异常和中断并转到相应的处理程序（软件识别和硬件识别）</li>
</ul>
<p>软件识别：CPU设置一个异常状态寄存器，用于记录异常原因，操作系统使用一个统一的异常和中断查询程序，按优先级顺序查询异常状态寄存器，以检查异常和中断类型，先查询到的先处理，然后转到内核中相应的处理程序</p>
<p>硬件识别（向量中断）：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放于中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表内，类型号和中断向量一一对应</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>从两方面提高处理机的并行性：  </p>
<ul>
<li>时间并行：流水线技术</li>
<li>空间并行：超标量处理机</li>
</ul>
<h3 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h3><p>一条指令的执行过程分解为几个阶段，每个阶段由相应的功能部件完成</p>
<ul>
<li>取指IF</li>
<li>译码&#x2F;读寄存器ID</li>
<li>执行&#x2F;计算地址EX</li>
<li>访存MEM</li>
<li>写回WB</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" data-id="cll50ezza001gxpbi6b9iduui" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-指令系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.304Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h1><h2 id="指令系统-1"><a href="#指令系统-1" class="headerlink" title="指令系统"></a>指令系统</h2><p>是指令集体系结构ISA的核心<br>ISA主要包括：</p>
<ul>
<li>指令格式</li>
<li>数据类型及格式</li>
<li>操作数的存放方式</li>
<li>程序可访问的寄存器个数、位数和编号 </li>
<li>存储空间大小和编址方式</li>
<li>寻址方式</li>
<li>指令执行过程的控制方式等</li>
</ul>
<h3 id="指令的基本格式"><a href="#指令的基本格式" class="headerlink" title="指令的基本格式"></a>指令的基本格式</h3><p>一条指令包括操作码和地址码字段</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>操作码</td>
<td>地址码</td>
</tr>
</tbody></table>
<p>操作码:</p>
<ul>
<li>指出指令应执行的操作</li>
<li>识别指令</li>
<li>了解指令功能</li>
<li>区分操作数地址内容的组成和使用方法</li>
</ul>
<p>地址码：</p>
<ul>
<li>给出被操作的信息的地址</li>
<li>参加运算的一个或多个操作数所在的地址</li>
<li>运算结果的保存地址</li>
<li>程序的转移地址</li>
<li>被调用的子程序的入口地址等</li>
</ul>
<p>指令长度是指一条指令中包含的二进制代码的位数<br>指令字长取决于</p>
<ul>
<li>操作码的长度</li>
<li>操作数地址码的长度</li>
<li>操作数地址个数</li>
</ul>
<p>单字长指令：等于机器字长<br>半字长指令：一半机器字长<br>双字长指令：二倍机器字长<br>定长指令字结构：一个指令系统所有指令的长度都是相等的  </p>
<h4 id="零地址指令：无显示地址"><a href="#零地址指令：无显示地址" class="headerlink" title="零地址指令：无显示地址"></a>零地址指令：无显示地址</h4><table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
</tr>
</tbody></table>
<ul>
<li>不需要操作数的指令</li>
<li>零地址运算指令仅用于堆栈计算机，通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出，送至运算器，运算结果再隐含的压入堆栈</li>
</ul>
<p>一地址指令：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
</tr>
</tbody></table>
<p>OP($A_1$) $\to$ $A_1$</p>
<ul>
<li>只有目的操作数，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址</li>
</ul>
<p>(ACC)OP($A_1$) $\to$ ACC</p>
<ul>
<li>隐含约定目的地址的双操作数指令，按指令地址$A_1$地址读取操作数，指令可隐含约定另一个操作数由ACC提供，运算结果也将存放在ACC中</li>
<li>若指令长度为32位，操作码占8位，1个地址码字段占24位，指令操作数直接寻址范围$2^{24}&#x3D;16M$</li>
</ul>
<h4 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
</tr>
</tbody></table>
<p>($A_1$)OP($A_2$) $\to$ $A_1$</p>
<ul>
<li>常用的算术和逻辑运算指令，需要两个操作数，需要分别给出目的操作数和源操作数，其中目的操作数地址还用于存放本次运算结果</li>
<li>指令字长位32位，操作码占8位，两个地址码各占12位，则指令操作数的直接寻址范围$2^{12}&#x3D;4K$</li>
</ul>
<h4 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$(结果)</td>
</tr>
</tbody></table>
<p>($A_1$)OP($A_2$) $\to$ $A_3$</p>
<ul>
<li>指令字长位32位，操作码占8位，3个地址码各占8位，直接寻址范围$2^8&#x3D;256$，地址字段为主存地址，则完成一条三地址需要4次访存，取指令1次，取两个操作数2次，存放结果1次</li>
</ul>
<h4 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h4><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>$A_4$</td>
</tr>
</tbody></table>
<p>($A_1$)OP($A_2$) $\to$ $A_3$ ，$A_4$ &#x3D; 下一条执行指令的地址</p>
<ul>
<li>地址字长为32位，操作码占8位，4个地址码各占6位，直接寻址范围$2^6&#x3D;64$</li>
</ul>
<h3 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h3><p>在指令字的最高位部分分配固定的若干位（定长）表示操作码。<br>n位操作码字段的指令系统最大能表示$2^{n}$条指令</p>
<h3 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h3><ul>
<li>不允许短码是长码的前缀</li>
<li>各指令的操作码一定不能重复</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
</tr>
<tr>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
</tr>
<tr>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>操作码情况</td>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>说明</td>
</tr>
<tr>
<td>15条三地址</td>
<td>0000-1110</td>
<td></td>
<td></td>
<td></td>
<td>余出16-15&#x3D;1，1*2^4&#x3D;16种</td>
</tr>
<tr>
<td>12条二地址</td>
<td>1111</td>
<td>0000-1011</td>
<td></td>
<td></td>
<td>余出16-12&#x3D;4，4*2^4&#x3D;64种</td>
</tr>
<tr>
<td>62条一地址</td>
<td>1111</td>
<td>(1100-1110)&#x2F;1111</td>
<td>(0000-1111)&#x2F;(0000-1101)</td>
<td></td>
<td>余出64-62&#x3D;2，2*2^4&#x3D;32种</td>
</tr>
<tr>
<td>32条零地址</td>
<td>1111</td>
<td>1111</td>
<td>1110-1111</td>
<td>0000-1111</td>
<td></td>
</tr>
</tbody></table>
<h3 id="指令的操作类型"><a href="#指令的操作类型" class="headerlink" title="指令的操作类型"></a>指令的操作类型</h3><ul>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位</li>
<li>转移</li>
<li>输入输出</li>
</ul>
<h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><p>确定本条指令的数据地址以及下一条待执行指令的地址，分为：</p>
<ul>
<li><p>指令寻址：寻找下条要执行的指令<br>（1）顺序寻址<br>通过PC+(1)，自动形成下一条指令<br>（2）跳跃寻址<br>通过转移指令实现，下条指令的地址不由PC自动给出，而由本条指令给出下条指令地址的计算方式。是否可跳跃受到状态寄存器和操作数的控制，跳跃的结果是当前指令修改PC值，下一条指令仍通过PC给出</p>
</li>
<li><p>数据寻址：寻找本条指令的数据<br>通常在指令字中设一个字段指明寻址方式</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>操作码</td>
<td>寻址特征</td>
<td>形式地址A</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="常见数据寻址方式"><a href="#常见数据寻址方式" class="headerlink" title="常见数据寻址方式"></a>常见数据寻址方式</h3><h4 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h4><p>不明显的给出操作数，在指令中隐含操作数地址</p>
<ul>
<li>优：有利于缩短指令字长</li>
<li>缺：需要增加存储操作数或隐含地址的硬件</li>
</ul>
<h4 id="立即（数）寻址"><a href="#立即（数）寻址" class="headerlink" title="立即（数）寻址"></a>立即（数）寻址</h4><p>指令的地址字段指出的不是操作数地址，而是操作数本身，又称立即数，#表示立即寻址特征，使用补码表示</p>
<ul>
<li>优：指令在执行阶段不访问主存，指令执行时间最短</li>
<li>缺：A的位数限制立即数的范围</li>
</ul>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>指令中的形式地址A是操作数的真实地址EA，EA&#x3D;A  </p>
<ul>
<li>优：简单，访存1次，不需要专门计算操作数的地址</li>
<li>缺：A的位数决定了指令操作数的寻址范围，操作数的地址不易修改</li>
</ul>
<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址的存储单元地址，EA&#x3D;(A)，间接寻址可以迭代多次<br>间接寻址，主存第一位表示是否为多次间址</p>
<ul>
<li>优：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间址寻址可方便的完成子程序返回）</li>
<li>缺：访问速度慢</li>
</ul>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>指令字中直接给出操作数所在的寄存器编号EA&#x3D; $R_i$，操作数在由$R_i$所指的寄存器内</p>
<ul>
<li>优：指令执行阶段不访存，只访问寄存器，寄存器对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量&#x2F;矩阵运算</li>
<li>缺:寄存器昂贵，有限</li>
</ul>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p>寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址EA&#x3D;($R_i$)</p>
<ul>
<li>优：与一般间址寻址速度快</li>
<li>缺：需要访存</li>
</ul>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>PC的内容加上指令格式的形式地址A而形成操作数的有效地址EA&#x3D;(PC)+A，A是相对于当前PC的值的位移量，可正可负，用补码表示，A的位数决定寻址范围</p>
<ul>
<li>操作数的地址是不固定的，随PC的值变化而变化，且与指令地址之间相差一个固定值，便于程序浮动，广泛用于转移指令</li>
<li>JMP A，CPU从存储器取出一字节，自动执行(PC)+1 $\to$ PC，若转移指令的地址为X，且占2B，取出该指令后，PC自增2，(PC)&#x3D;X+2，执行完该指令，会自动跳转至X+2+A的地址继续执行</li>
</ul>
<h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>将CPU的基址寄存器BR的内容加上指令格式的形式地址A形成操作数的有效地址EA&#x3D;(BR)+A，基址寄存器可采用专用寄存器也可为通用寄存器</p>
<ul>
<li><p>基址寄存器面向操作系统，内容通过操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性</p>
</li>
<li><p>执行过程中基址寄存器内容不变，形式地址可变（偏移量）</p>
</li>
<li><p>采用通用寄存器作为基址寄存器，用户可决定使用哪个寄存器，内容由操作系统确定</p>
</li>
<li><p>优：可扩大寻址范围（基址寄存器位数大于形式地址A的位数），用户不必考虑自己的程序存于主存哪个区域，有利于多道程序设计，可用于制成浮动程序</p>
</li>
<li><p>缺：偏移量位数较短</p>
</li>
</ul>
<h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，EA&#x3D;(IX)+A</p>
<ul>
<li>IX可使用专用寄存器或通用寄存器</li>
<li>变址寄存器面向用户，在程序执行过程，变址寄存器内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）</li>
<li>可扩大寻址范围（变址寄存器位数大于形式地址A的位数），适合编制循环程序，偏移量的位数（IX）足以表示整个存储空间</li>
</ul>
<h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>堆栈是存储器（或专用寄存器组）中一块特定的、按照后进先出（LIFO）的原则管理的存储区，存储区读写单元地址是用一个特定寄存器给出的称为堆栈指针(SP)，分为硬堆栈（不适合做大容量堆栈）和软堆栈（主存划出一段区域）</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>有效地址</th>
<th>访存次数</th>
</tr>
</thead>
<tbody><tr>
<td>隐含寻址</td>
<td>程序指定</td>
<td>0</td>
</tr>
<tr>
<td>立即寻址</td>
<td>A是操作数</td>
<td>0</td>
</tr>
<tr>
<td>直接寻址</td>
<td>EA&#x3D;A</td>
<td>1</td>
</tr>
<tr>
<td>一次间接寻址</td>
<td>EA&#x3D;(A)</td>
<td>2</td>
</tr>
<tr>
<td>寄存器寻址</td>
<td>EA&#x3D; $R_i$</td>
<td>0</td>
</tr>
<tr>
<td>寄存器间接一次寻址</td>
<td>EA &#x3D; ($R_i$)</td>
<td>1</td>
</tr>
<tr>
<td>相对寻址</td>
<td>EA&#x3D;(PC)+A</td>
<td>1</td>
</tr>
<tr>
<td>基址寻址</td>
<td>EA&#x3D;(BR)+A</td>
<td>1</td>
</tr>
<tr>
<td>变址寻址</td>
<td>EA&#x3D;(IX)+A</td>
<td>1</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" data-id="cll50ezzb001hxpbi5dnlept4" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-虚拟存储器·页式·段式·段页式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%C2%B7%E9%A1%B5%E5%BC%8F%C2%B7%E6%AE%B5%E5%BC%8F%C2%B7%E6%AE%B5%E9%A1%B5%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.269Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚拟存储器·页式·段式·段页式"><a href="#虚拟存储器·页式·段式·段页式" class="headerlink" title="虚拟存储器·页式·段式·段页式"></a>虚拟存储器·页式·段式·段页式</h1><p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>
<ul>
<li>实地址 &#x3D; 主存页号 + 页内字地址</li>
<li>虚地址 &#x3D; 虚存页号 + 页内字地址</li>
<li>辅存地址 &#x3D; 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>
</ul>
<p>CPU使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>
<ul>
<li>在内存，通过地址变换，CPU可直接访问主存指示的数据单元</li>
<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>
</ul>
<h2 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h2><p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong>  </p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>有效位</td>
<td>脏位</td>
<td>引用位</td>
<td>物理页</td>
</tr>
</tbody></table>
<ul>
<li>有效位（装入位）：表示对应页是否在主存</li>
<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>
<li>引用位（使用位）：配合替换算法进行设置</li>
</ul>
<p>CPU运行指令时，虚地址转实地址：</p>
<ul>
<li>页表基址寄存器存放进程的页表首地址</li>
<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>
<li>装入位为1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>
<li>装入位为0，说明缺页，需要操作系统进行缺页处理</li>
</ul>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h3><p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>快表通常采用组相联或全相联方式</p>
<table>
<thead>
<tr>
<th>t</th>
<th>r</th>
<th>p</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>有效位</td>
<td>实页号</td>
</tr>
</tbody></table>
<h3 id="具有TLB和Cache的多级存储系统"><a href="#具有TLB和Cache的多级存储系统" class="headerlink" title="具有TLB和Cache的多级存储系统"></a>具有TLB和Cache的多级存储系统</h3><p>三种缺失的情况  </p>
<table>
<thead>
<tr>
<th></th>
<th>TLB</th>
<th>Page</th>
<th>Cache</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>命中</td>
<td>命中</td>
<td>命中</td>
<td>TLB命中则Page一定命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>2</td>
<td>命中</td>
<td>命中</td>
<td>缺失</td>
<td>TLB命中则Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>3</td>
<td>缺失</td>
<td>命中</td>
<td>命中</td>
<td>TLB缺失但Page可能命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>4</td>
<td>缺失</td>
<td>命中</td>
<td>缺失</td>
<td>TLB缺失但Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>5</td>
<td>缺失</td>
<td>缺失</td>
<td>缺失</td>
<td>TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache</td>
</tr>
</tbody></table>
<h2 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h2><p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>段首地址</td>
<td>装入位</td>
<td>段长</td>
</tr>
</tbody></table>
<p>CPU访存时：</p>
<ul>
<li>根据段号与段表基地址拼接成对应的段表行</li>
<li>根据段表行的装入位判断是否调入内存</li>
<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址</li>
</ul>
<h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><p>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>段内页号</td>
<td>页内地址</td>
</tr>
</tbody></table>
<p>CPU访存：</p>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成实地址</li>
</ul>
<h2 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与Cache的比较</h2><table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody><tr>
<td>目的均为提供系统性能</td>
<td>Cache主要解决系统速度，虚拟存储器解决主存容量</td>
</tr>
<tr>
<td>均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大</td>
<td>Cache由硬件实现，对程序员透明，虚拟存储器由OS和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td>都有地址的映射、替换算法、更新策略</td>
<td></td>
</tr>
<tr>
<td>均依据程序的局部性原理</td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%C2%B7%E9%A1%B5%E5%BC%8F%C2%B7%E6%AE%B5%E5%BC%8F%C2%B7%E6%AE%B5%E9%A1%B5%E5%BC%8F/" data-id="cll50ezzd001ixpbid7m75ln5" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-YOLO_001_from-CNN-to-YOLOv1" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/YOLO_001_from-CNN-to-YOLOv1/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.226Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h1><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn1.png" alt="cnn1"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn2%20(2).png" alt="cnn2 (2)"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn3.png" alt="cnn3"></p>
<p><strong>分类猫和狗</strong></p>
<p>使用一个还不错的相机采集图片(12M)   </p>
<p>RGB figure 36M 元素  </p>
<p>使用100大小的单隐藏层MLP 模型有3.6B &#x3D; 14GB 元素   </p>
<p>远多于世界上所有的猫狗总数(900M dog 600M cat)  </p>
<p><strong>两个原则</strong></p>
<p>平移不变性  </p>
<p>局部性  </p>
<p><strong>重新考察全连接层</strong>  </p>
<p>将输入和输出变形为矩阵（宽度，高度）</p>
<p>将权重变形为4-D张量（h,w）到（h’,w’）<br>$$<br>h_{i,j}&#x3D;\sum_{k,l}w_{i,j,k,l}x_{k,l}&#x3D;\sum_{a,b}&#x3D;v_{i,j,a,b}x_{i+a,j+b}<br>$$<br>V是W的重新索引<br>$$<br>v_{i,j,a,b}&#x3D;w_{i,j,i+a,j+b}<br>$$</p>
<p><strong>原则#1 - 平移不变性</strong></p>
<p>x的平移导致h的平移<br>$$<br>h_{i,j}&#x3D;\sum_{a,b}v_{i,j,a,b}x_{i+a,j+b}<br>$$<br>v不应依赖于（i, j）  </p>
<p>解决方案：<br>$$<br>v_{i,j,a,b}&#x3D;v_{a, b},<br>h_{i,j}&#x3D;\sum_{a,b}v_{a,b}x_{i+a,j+b}<br>$$<br>这就是交叉相关  </p>
<p><strong>原则#2 - 局部性</strong></p>
<h3 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h3><p>$$<br>\begin{aligned}<br>&amp;为了收集用来训练参数[\mathbf{H}]<em>{i, j}的相关信息，\<br>&amp;我们不应偏离到距(i, j)很远的地方。\<br>&amp;这意味着在|a|&gt; \Delta或|b| &gt; \Delta的范围之外，\<br>&amp;我们可以设置[\mathbf{V}]</em>{a, b} &#x3D; 0。\<br>&amp;因此，我们可以将[\mathbf{H}]<em>{i, j}重写为:\<br>&amp;[\mathbf{H}]*</em>{i, j} &#x3D; u + \sum_*{a &#x3D; -\Delta}^{\Delta} \sum*_{b &#x3D; -\Delta}^{\Delta} [\mathbf{V}]<em>*{a, b} [\mathbf{X}]</em>{i+a, j+b}.<br>\end{aligned}<br>$$<br>当图像处理的局部区域很小时，卷积神经网络与多层感知机的训练差异可能是巨大的：以前，多层感知机可能需要数十亿个参数来表示网络中的一层，而现在卷积神经网络通常只需要几百个参数，而且不需要改变输入或隐藏表示的维数。</p>
<p>参数大幅减少的代价是，我们的特征现在是平移不变的，并且当确定每个隐藏活性值时，每一层只包含局部的信息。</p>
<p>以上所有的权重学习都将依赖于归纳偏置。当这种偏置与现实相符时，我们就能得到样本有效的模型，并且这些模型能很好地泛化到未知数据中。</p>
<p>但如果这偏置与现实不符时，比如当图像不满足平移不变时，我们的模型可能难以拟合我们的训练数据。</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn4.png" alt="cnn4"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn5.png" alt="image-20220127104222384"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn6.png" alt="cnn6"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn7.png" alt="cnn7"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn8.png" alt="cnn8"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn9.png" alt="cnn9"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20220127105601246.png" alt="image-20220127105601246"></p>
<h2 id="Sharing-Weight"><a href="#Sharing-Weight" class="headerlink" title="Sharing-Weight"></a>Sharing-Weight</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn11.png" alt="cnn11"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20220127110147649.png" alt="image-20220127110147649"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn12.png" alt="cnn12"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn13.png" alt="cnn13"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn14.png" alt="cnn14"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn15.png" alt="cnn15"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn16.png" alt="cnn16"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn17.png" alt="cnn17"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn18.png" alt="cnn18"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn19.png" alt="cnn19"></p>
<h2 id="Pooling-Max-Pooling"><a href="#Pooling-Max-Pooling" class="headerlink" title="Pooling - Max Pooling"></a>Pooling - Max Pooling</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn20.png" alt="cnn20"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn20.1.png" alt="cnn20.1"></p>
<p><strong>Max-Pooling:选取最大的值 也可选取其他的采用 当然也可不做采用前提是性能足够</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn21.png" alt="cnn21"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn22.png" alt="cnn22"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/cnn23.png" alt="cnn23"></p>
<p><strong>但CNN无法直接对一个放大的图像做识别，需要data augmentation(对数据集进行旋转，放大，缩小，等操作)</strong></p>
<h1 id="YOLOv1"><a href="#YOLOv1" class="headerlink" title="YOLOv1"></a>YOLOv1</h1><h2 id="Bounding-Box"><a href="#Bounding-Box" class="headerlink" title="Bounding-Box"></a>Bounding-Box</h2><p>将一张图片分割为有限个单元格(Cell,图中红色网格)<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/split-image.png" alt="split-pic"><br>每一个输出和标签都是针对每一个单元格的物体中心(midpiont,图中蓝色圆点)<br>每一个单元格会有[X1, Y1, X2, Y2]<br>对应的物体中心会有一个[X, Y, W, H]<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/bounding-box1.png" alt="bb1"><br>X, Y 在[0, 1]内表示水平或垂直的距离<br>W, H &gt; 1 表示物体水平或垂直方向上高于该单元格 数值表示水平或垂直方向的单位长度的倍数<br>[0.95, 0.55, 0.5, 1.5]&#x3D;&gt;显然图像靠近右下角 单元格不能表示出完整的物体<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/bounding-box2.png" alt="bb2"><br>根据 [X, Y, W, H] &#x3D;&gt; [0.95, 0.55, 0.5, 1.5] 计算得到Bounding Box(图中蓝色网格)</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/b-box-seq.png" alt="bbx3"></p>
<h2 id="Image-Label"><a href="#Image-Label" class="headerlink" title="Image-Label"></a>Image-Label</h2><p>$$<br>\begin{aligned}<br>&amp;label_{cell}&#x3D;[C_1,C_2,\cdots,C_{20},P_c,X,Y,W,H]\<br>&amp;[C_1,C_2,\cdots,C_{20}]:20\space different\space classes\<br>&amp;[P_c]:Probability\space for\space there\space is\space an\space object(0or1)\<br>&amp;[X,Y,W,H]:Bounding-Box\<br>&amp;pred_{cell}&#x3D;[C_1,C_2,\cdots,C_{20},P_{c1},X_1,Y_1,W_1,H_1,P_{c2},X_2,Y_2,W_2,H_2]\<br>&amp;Taget\space shape\space for\space one \space images:(S, S, 25)\<br>&amp;Predication\space shape \space for\space one\space images:(S,S,30)\<br>\end{aligned}<br>$$</p>
<h2 id="Model-Framework"><a href="#Model-Framework" class="headerlink" title="Model-Framework"></a>Model-Framework</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/yolov1-modelfw.png" alt="yolov1"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/YOLO_001_from-CNN-to-YOLOv1/" data-id="cll50ezz8001fxpbig9j01cye" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PCC_007_第七章-I⁄O" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/PCC_007_%E7%AC%AC%E4%B8%83%E7%AB%A0-I%E2%81%84O/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.195Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I&#x2F;O系统"></a>I&#x2F;O系统</h1><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806163855382.jpg" alt="image-20210806163855382"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806164055287.jpg" alt="image-20210806164055287"></p>
<p><strong>CPU如何控制键盘I&#x2F;O的完成？</strong><br>$$<br>\begin{align}<br>&amp;I&#x2F;O控制方式<br>\begin{cases}<br>&amp;程序查询方式\<br>&amp;程序中断方式\<br>&amp;DMA控制方式\<br>\end{cases}<br>\end{align}<br>$$</p>
<h2 id="I-O硬件"><a href="#I-O硬件" class="headerlink" title="I&#x2F;O硬件"></a>I&#x2F;O硬件</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165815777.jpg" alt="image-20210806165815777"></p>
<h4 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806170055057.jpg" alt="image-20210806170055057"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165553492.jpg" alt="image-20210806165553492"></p>
<h4 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806170108933.jpg" alt="image-20210806170108933"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165602872.jpg" alt="image-20210806165602872"></p>
<h4 id="DMA控制方式"><a href="#DMA控制方式" class="headerlink" title="DMA控制方式"></a>DMA控制方式</h4><p>DMA控制器与主存每次传送1个字，当传送完一整块数据后才向CPU发送中断请求</p>
<h4 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165148498.jpg" alt="image-20210806165148498"></p>
<p><strong>通道</strong>是具有特殊功能的处理器，能对I&#x2F;O设备进行统一的管理，通道可以识别并执行一系列<strong>通道指令</strong>，通过指令种类、功能通常比较单一</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165333341.jpg" alt="image-20210806165333341"></p>
<h2 id="I-O软件"><a href="#I-O软件" class="headerlink" title="I&#x2F;O软件"></a>I&#x2F;O软件</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165837786.jpg" alt="image-20210806165837786"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165911845.jpg" alt="image-20210806165911845"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806165924844.jpg" alt="image-20210806165924844"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806170008647.jpg" alt="image-20210806170008647"></p>
<h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><p>$$<br>\begin{align}<br>&amp;外部设备<br>&amp;\begin{cases}&amp;输入设备\&amp;输出设备\&amp;外存设备\\end{cases}\</p>
<p>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806170752700.jpg" alt="image-20210806170752700"></p>
<h3 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806170910600.jpg" alt="image-20210806170910600"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806170922462.jpg" alt="image-20210806170922462"></p>
<h3 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806171237863.jpg" alt="image-20210806171237863"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806171351764.jpg" alt="image-20210806171351764"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806171733638.jpg" alt="image-20210806171733638"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172041384.jpg" alt="image-20210806172041384"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172139423.jpg" alt="image-20210806172139423"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172148195.jpg" alt="image-20210806172148195"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172302581.jpg" alt="image-20210806172302581"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172351568.jpg" alt="image-20210806172351568"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172453188.jpg" alt="image-20210806172453188"></p>
<h2 id="外存储器"><a href="#外存储器" class="headerlink" title="外存储器"></a>外存储器</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806172734774.jpg" alt="image-20210806172734774"></p>
<p>一次只能读&#x2F;写1bit数据，且不能同时读写</p>
<h3 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h3><h4 id="磁盘设备的组成"><a href="#磁盘设备的组成" class="headerlink" title="磁盘设备的组成"></a>磁盘设备的组成</h4><h5 id="存储区域"><a href="#存储区域" class="headerlink" title="存储区域"></a>存储区域</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806173100898.jpg" alt="image-20210806173100898"></p>
<h5 id="硬盘存储器"><a href="#硬盘存储器" class="headerlink" title="硬盘存储器"></a>硬盘存储器</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806173115912.jpg" alt="image-20210806173115912"></p>
<h5 id="磁盘的性能指标"><a href="#磁盘的性能指标" class="headerlink" title="磁盘的性能指标"></a>磁盘的性能指标</h5><h6 id="磁盘的容量"><a href="#磁盘的容量" class="headerlink" title="磁盘的容量"></a>磁盘的容量</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806210734896.jpg" alt="image-20210806210734896"></p>
<h6 id="记录密度"><a href="#记录密度" class="headerlink" title="记录密度"></a>记录密度</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806210815041.jpg" alt="image-20210806210815041"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806210916872.jpg" alt="image-20210806210916872"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806210950153.jpg" alt="image-20210806210950153"></p>
<h6 id="平均存取时间"><a href="#平均存取时间" class="headerlink" title="平均存取时间"></a>平均存取时间</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806210857099.jpg" alt="image-20210806210857099"></p>
<h6 id="数据传输率"><a href="#数据传输率" class="headerlink" title="数据传输率"></a>数据传输率</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806210830675.jpg" alt="image-20210806210830675"><br>$$<br>\begin{align}<br>假设磁盘转数为r(转&#x2F;秒)，每条磁道容量为N个字节，则数据传输率为D_r&#x3D;rN<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806211017907.jpg" alt="image-20210806211017907"></p>
<h5 id="磁盘地址"><a href="#磁盘地址" class="headerlink" title="磁盘地址"></a>磁盘地址</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212229096.jpg" alt="image-20210806212229096"></p>
<h5 id="磁盘的工作过程"><a href="#磁盘的工作过程" class="headerlink" title="磁盘的工作过程"></a>磁盘的工作过程</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212326766.jpg" alt="image-20210806212326766"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212339138.jpg" alt="image-20210806212339138"></p>
<h4 id="磁盘阵列"><a href="#磁盘阵列" class="headerlink" title="磁盘阵列"></a>磁盘阵列</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212536196.jpg" alt="image-20210806212536196"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212603961.jpg" alt="image-20210806212603961"></p>
<h5 id="RAID0-RAID1"><a href="#RAID0-RAID1" class="headerlink" title="RAID0&amp;RAID1"></a>RAID0&amp;RAID1</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212620031.jpg" alt="image-20210806212620031"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212631266.jpg" alt="image-20210806212631266"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212810630.jpg" alt="image-20210806212810630"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212853261.jpg" alt="image-20210806212853261"></p>
<h5 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212642401.jpg" alt="image-20210806212642401"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212832631.jpg" alt="image-20210806212832631"></p>
<h5 id="RAID3-RAID4-RAID5"><a href="#RAID3-RAID4-RAID5" class="headerlink" title="RAID3&amp;RAID4&amp;RAID5"></a>RAID3&amp;RAID4&amp;RAID5</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806212910891.jpg" alt="image-20210806212910891"></p>
<p>RAID通过同时使用多个磁盘，提高传输率；通过多个磁盘上并行存取来大幅度提高存储系统的数据吞吐量；通过镜像功能，可以提高安全可靠性；通过数据校验，可以提高容错能力</p>
<h4 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806213252093.jpg" alt="image-20210806213252093"></p>
<h4 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806213330220.jpg" alt="image-20210806213330220"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806213423090.jpg" alt="image-20210806213423090"></p>
<h2 id="I-O接口"><a href="#I-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806213950429.jpg" alt="image-20210806213950429"></p>
<h3 id="I-O接口的作用"><a href="#I-O接口的作用" class="headerlink" title="I&#x2F;O接口的作用"></a>I&#x2F;O接口的作用</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210806214142881.jpg" alt="image-20210806214142881"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813161648960.jpg" alt="image-20210813161648960"></p>
<p>数据缓冲寄存器</p>
<p>状态&#x2F;控制寄存器</p>
<p>（1）<strong>发命令</strong>：发送命令字到I&#x2F;O控制寄存器，向设备发送命令（需要驱动程序的协助）</p>
<p>（2）<strong>读状态</strong>：从状态寄存器读取状态字，获得设备或I&#x2F;O控制器的状态信息</p>
<p>（3）<strong>读&#x2F;写数据</strong>：从数据缓冲器发送或读取数据，完成主机与外设的数据交换</p>
<p><strong>如何确定要操作的设备？</strong></p>
<p>每个设备对应一组寄存器，操作不同的寄存器就是在操作不同的设备</p>
<h3 id="I-O端口及其编址"><a href="#I-O端口及其编址" class="headerlink" title="I&#x2F;O端口及其编址"></a>I&#x2F;O端口及其编址</h3><h4 id="统一编址"><a href="#统一编址" class="headerlink" title="统一编址"></a>统一编址</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813163256072.jpg" alt="image-20210813163256072"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813163201150.jpg" alt="image-20210813163201150"></p>
<h4 id="独立编址"><a href="#独立编址" class="headerlink" title="独立编址"></a>独立编址</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813163241572.jpg" alt="image-20210813163241572"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813163214727.jpg" alt="image-20210813163214727"></p>
<h3 id="I-O接口类型"><a href="#I-O接口类型" class="headerlink" title="I&#x2F;O接口类型"></a>I&#x2F;O接口类型</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813163347023.jpg" alt="image-20210813163347023"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813163409152.jpg" alt="image-20210813163409152"></p>
<h2 id="I-O方式"><a href="#I-O方式" class="headerlink" title="I&#x2F;O方式"></a>I&#x2F;O方式</h2><h3 id="程序查询方式-1"><a href="#程序查询方式-1" class="headerlink" title="程序查询方式"></a>程序查询方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813180820262.jpg" alt="image-20210813180820262"></p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813181124355.jpg" alt="image-20210813181124355"><br>$$<br>\begin{align}<br>&amp;时间角度：\<br>&amp;一个时钟周期为\frac{1}{50MHZ}&#x3D;20ns\<br>&amp;一个查询操作时间100<em>20ns&#x3D;2000ns\<br>&amp;(1)鼠标\<br>&amp;每次查询鼠标耗时30</em>2000ns&#x3D;60000ns\<br>&amp;查询鼠标所花费的时间比率&#x3D;\frac{60000ns}{1s}&#x3D;0.006%\<br>&amp;(2)硬盘\<br>&amp;每32位需要查询一次，每秒传送2<em>2^{20}B\<br>&amp;每秒需要查询\frac{2</em>2^{20}B}{4B}&#x3D;2^{19}次\<br>&amp;查询硬盘耗时2^{19}<em>2000ns&#x3D;1.05</em>10^9ns\<br>&amp;查询硬盘所花费的时间比率\frac{1.05*10^9ns}{1s}&#x3D;105%\<br>&amp;结论：CPU将全部时间都用于硬盘查询也不能满足磁盘传输的要求<br>\end{align}<br>$$</p>
<h3 id="程序中断方式-1"><a href="#程序中断方式-1" class="headerlink" title="程序中断方式"></a>程序中断方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813185043891.jpg" alt="image-20210813185043891"></p>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813214458403.jpg" alt="image-20210813214458403"></p>
<h4 id="中断方式"><a href="#中断方式" class="headerlink" title="中断方式"></a>中断方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813214635761.jpg" alt="image-20210813214635761"></p>
<h4 id="中断请求标记"><a href="#中断请求标记" class="headerlink" title="中断请求标记"></a>中断请求标记</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813214923823.jpg" alt="image-20210813214923823"></p>
<h4 id="中断判优"><a href="#中断判优" class="headerlink" title="中断判优"></a>中断判优</h4><h5 id="硬件排队器-查询程序"><a href="#硬件排队器-查询程序" class="headerlink" title="硬件排队器&amp;查询程序"></a>硬件排队器&amp;查询程序</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813215205716.jpg" alt="image-20210813215205716"></p>
<h5 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813215410647.jpg" alt="image-20210813215410647"></p>
<h5 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813215538505.jpg" alt="image-20210813215538505"></p>
<h6 id="中断隐指令（一系列的指令）"><a href="#中断隐指令（一系列的指令）" class="headerlink" title="中断隐指令（一系列的指令）"></a>中断隐指令（一系列的指令）</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813215641585.jpg" alt="image-20210813215641585"></p>
<h6 id="硬件向量法（二级指针【向量地址—–入口地址】）"><a href="#硬件向量法（二级指针【向量地址—–入口地址】）" class="headerlink" title="硬件向量法（二级指针【向量地址—–入口地址】）"></a>硬件向量法（二级指针【向量地址—–入口地址】）</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813215940720.jpg" alt="image-20210813215940720"></p>
<h5 id="中断服务程序"><a href="#中断服务程序" class="headerlink" title="中断服务程序"></a>中断服务程序</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813220248708.jpg" alt="image-20210813220248708"></p>
<h5 id="总结：中断处理过程"><a href="#总结：中断处理过程" class="headerlink" title="总结：中断处理过程"></a>总结：中断处理过程</h5><p>单重中断</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210813220436008.jpg" alt="image-20210813220436008"></p>
<h2 id="多重中断（中断嵌套）"><a href="#多重中断（中断嵌套）" class="headerlink" title="多重中断（中断嵌套）"></a>多重中断（中断嵌套）</h2><h3 id="单重中断-多重中断"><a href="#单重中断-多重中断" class="headerlink" title="单重中断&amp;多重中断"></a>单重中断&amp;多重中断</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814151329290.jpg" alt="image-20210814151329290"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814151340847.jpg" alt="image-20210814151340847"></p>
<h3 id="中断屏蔽技术"><a href="#中断屏蔽技术" class="headerlink" title="中断屏蔽技术"></a>中断屏蔽技术</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814151543557.jpg" alt="image-20210814151543557"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814151559383.jpg" alt="image-20210814151559383"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814151621213.jpg" alt="image-20210814151621213"></p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814151646383.jpg" alt="image-20210814151646383"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814153726480.jpg" alt="image-20210814153726480"></p>
<p><strong>总结</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814153820909.jpg" alt="image-20210814153820909"></p>
<h2 id="程序中断方式-2"><a href="#程序中断方式-2" class="headerlink" title="程序中断方式"></a>程序中断方式</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814154819165.jpg" alt="image-20210814154819165"></p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814154840327.jpg" alt="image-20210814154840327"><br>$$<br>\begin{align}<br>&amp;（1）数据位7位，1位校验位，1位起始位，1位终止位，共需传送10位\<br>&amp;每秒钟可送\frac{1}{0.5ms}&#x3D;2000个字符\<br>&amp;（2）主频50MHZ,时钟周期为\frac{1}{50MHZ}&#x3D;20ns\<br>&amp;0.5ms对应的周期数为\frac{0.5ms}{20ns}&#x3D;25000\<br>&amp;传送1个字符需要的时钟周期数为25000+10+15<em>4&#x3D;25070\<br>&amp;传送1000个字符需要的时钟周期为25070</em>1000&#x3D;25070000<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814161443760.jpg" alt="image-20210814161443760"><br>$$<br>\begin{align}<br>&amp;(3)CPU用于该任务的时间大约为1000*(10+20<em>4)&#x3D;9</em>10^4个时钟周期\<br>&amp;(4)中断隐指令：\begin{cases}&amp;1.关中断\&amp;2.保存断点(PC)\&amp;3.引出中断服务程序\\end{cases}\<br>\end{align}<br>$$</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814161947278.jpg" alt="image-20210814161947278"></p>
<h2 id="DMA方式"><a href="#DMA方式" class="headerlink" title="DMA方式"></a>DMA方式</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814162826190.jpg" alt="image-20210814162826190"></p>
<h3 id="DMA控制器"><a href="#DMA控制器" class="headerlink" title="DMA控制器"></a>DMA控制器</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163120177.jpg" alt="image-20210814163120177"></p>
<h3 id="DMA传送过程"><a href="#DMA传送过程" class="headerlink" title="DMA传送过程"></a>DMA传送过程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163313746.jpg" alt="image-20210814163313746"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163301338.jpg" alt="image-20210814163301338"></p>
<h3 id="DMA方式的特点"><a href="#DMA方式的特点" class="headerlink" title="DMA方式的特点"></a>DMA方式的特点</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163351381.jpg" alt="image-20210814163351381"></p>
<h3 id="DMA传送方式"><a href="#DMA传送方式" class="headerlink" title="DMA传送方式"></a>DMA传送方式</h3><h4 id="停止CPU访问主存"><a href="#停止CPU访问主存" class="headerlink" title="停止CPU访问主存"></a>停止CPU访问主存</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163651635.jpg" alt="image-20210814163651635"></p>
<h4 id="DMA与CPU交替访存"><a href="#DMA与CPU交替访存" class="headerlink" title="DMA与CPU交替访存"></a>DMA与CPU交替访存</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163707107.jpg" alt="image-20210814163707107"></p>
<h4 id="周期挪用（周期窃取）"><a href="#周期挪用（周期窃取）" class="headerlink" title="周期挪用（周期窃取）"></a>周期挪用（周期窃取）</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163720513.jpg" alt="image-20210814163720513"></p>
<h3 id="DMA方式-中断方式"><a href="#DMA方式-中断方式" class="headerlink" title="DMA方式&amp;中断方式"></a>DMA方式&amp;中断方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163905587.jpg" alt="image-20210814163905587"></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210814163924085.jpg" alt="image-20210814163924085"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/PCC_007_%E7%AC%AC%E4%B8%83%E7%AB%A0-I%E2%81%84O/" data-id="cll50ezz6001expbi5mmn4utx" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PCC_006_第六章-总线" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/PCC_006_%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%80%BB%E7%BA%BF/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.152Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第六章-总线"><a href="#第六章-总线" class="headerlink" title="第六章 总线"></a>第六章 总线</h1><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730175049623.jpg" alt="image-20210730175049623"></p>
<h2 id="总线概念"><a href="#总线概念" class="headerlink" title="总线概念"></a>总线概念</h2><p><strong>总线</strong>是一组能为多个部件<strong>分时</strong> <strong>共享</strong>的公共信息传送线路</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804153128054.jpg" alt="image-20210804153128054"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804153342203.jpg" alt="image-20210804153342203"></p>
<p><strong>共享 分时</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804153404370.jpg" alt="image-20210804153404370"></p>
<h3 id="总线的特性"><a href="#总线的特性" class="headerlink" title="总线的特性"></a>总线的特性</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730180717178.jpg" alt="image-20210730180717178"></p>
<h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804153919317.jpg" alt="image-20210804153919317"></p>
<h4 id="串行总线-并行总线"><a href="#串行总线-并行总线" class="headerlink" title="串行总线&amp;并行总线"></a>串行总线&amp;并行总线</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804153728683.jpg" alt="image-20210804153728683"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160443346.jpg" alt="image-20210804160443346"></p>
<h4 id="片内总线-系统总线-通信总线"><a href="#片内总线-系统总线-通信总线" class="headerlink" title="片内总线&amp;系统总线&amp;通信总线"></a>片内总线&amp;系统总线&amp;通信总线</h4><h5 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804154337625.jpg" alt="image-20210804154337625"></p>
<h5 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804154357368.jpg" alt="image-20210804154357368"></p>
<h5 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804154413635.jpg" alt="image-20210804154413635"></p>
<h4 id="系统总线结构"><a href="#系统总线结构" class="headerlink" title="系统总线结构"></a>系统总线结构</h4><h5 id="单总线"><a href="#单总线" class="headerlink" title="单总线"></a>单总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155232767.jpg" alt="image-20210804155232767"></p>
<h5 id="双总线"><a href="#双总线" class="headerlink" title="双总线"></a>双总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155257559.jpg" alt="image-20210804155257559"></p>
<h5 id="三总线"><a href="#三总线" class="headerlink" title="三总线"></a>三总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155325994.jpg" alt="image-20210804155325994"></p>
<h5 id="【扩充】四总线"><a href="#【扩充】四总线" class="headerlink" title="【扩充】四总线"></a>【扩充】四总线</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155351630.jpg" alt="image-20210804155351630"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155110192.jpg" alt="image-20210804155110192"></p>
<h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><h3 id="传输周期（总线周期）"><a href="#传输周期（总线周期）" class="headerlink" title="传输周期（总线周期）"></a>传输周期（总线周期）</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155613079.jpg" alt="image-20210804155613079"></p>
<h3 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155800291.jpg" alt="image-20210804155800291"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155651953.jpg" alt="image-20210804155651953"></p>
<h3 id="工作频率"><a href="#工作频率" class="headerlink" title="工作频率"></a>工作频率</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155820780.jpg" alt="image-20210804155820780"></p>
<h3 id="时钟频率"><a href="#时钟频率" class="headerlink" title="时钟频率"></a>时钟频率</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155832909.jpg" alt="image-20210804155832909"></p>
<h3 id="总线宽度"><a href="#总线宽度" class="headerlink" title="总线宽度"></a>总线宽度</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155911411.jpg" alt="image-20210804155911411"></p>
<h3 id="总线带宽"><a href="#总线带宽" class="headerlink" title="总线带宽"></a>总线带宽</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804155931961.jpg" alt="image-20210804155931961"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160009980.jpg" alt="image-20210804160009980"></p>
<p>例题：</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160241858.jpg" alt="image-20210804160241858"></p>
<p>解答</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160312643.jpg" alt="image-20210804160312643"></p>
<h3 id="总线复用"><a href="#总线复用" class="headerlink" title="总线复用"></a>总线复用</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160525451.jpg" alt="image-20210804160525451"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160541418.jpg" alt="image-20210804160541418"></p>
<h3 id="信号线数"><a href="#信号线数" class="headerlink" title="信号线数"></a>信号线数</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160627811.jpg" alt="image-20210804160627811"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804160750367.jpg" alt="image-20210804160750367"></p>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804164921305.jpg" alt="image-20210804164921305"><br>$$<br>\begin{align}<br>总线仲裁分类\begin{cases}&amp;集中仲裁方式\begin{cases}&amp;链式查询方式\&amp;计数器定时查询方式\&amp;独立请求方式\\end{cases}\&amp;分布仲裁方式\\end{cases}<br>\end{align}<br>$$</p>
<h3 id="集中仲裁方式"><a href="#集中仲裁方式" class="headerlink" title="集中仲裁方式"></a>集中仲裁方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804165400626.jpg" alt="image-20210804165400626"></p>
<h4 id="链式查询方式"><a href="#链式查询方式" class="headerlink" title="链式查询方式"></a>链式查询方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804165749685.jpg" alt="image-20210804165749685"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804165802704.jpg" alt="image-20210804165802704"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804165820886.jpg" alt="image-20210804165820886"></p>
<h4 id="计数器查询方式"><a href="#计数器查询方式" class="headerlink" title="计数器查询方式"></a>计数器查询方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804170144150.jpg" alt="image-20210804170144150"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804170206237.jpg" alt="image-20210804170206237"></p>
<h4 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804170414490.jpg" alt="image-20210804170414490"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804170431345.jpg" alt="image-20210804170431345"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804170522526.jpg" alt="image-20210804170522526"></p>
<h3 id="分布仲裁方式"><a href="#分布仲裁方式" class="headerlink" title="分布仲裁方式"></a>分布仲裁方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804170656625.jpg" alt="image-20210804170656625"></p>
<h2 id="总线的操作和定时"><a href="#总线的操作和定时" class="headerlink" title="总线的操作和定时"></a>总线的操作和定时</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804171208841.jpg" alt="image-20210804171208841"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804171240176.jpg" alt="image-20210804171240176"></p>
<h3 id="同步定时方式"><a href="#同步定时方式" class="headerlink" title="同步定时方式"></a>同步定时方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804172656139.jpg" alt="image-20210804172656139"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804172622572.jpg" alt="image-20210804172622572"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804172643501.jpg" alt="image-20210804172643501"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804172553892.jpg" alt="image-20210804172553892"></p>
<h3 id="异步定时方式"><a href="#异步定时方式" class="headerlink" title="异步定时方式"></a>异步定时方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804172820414.jpg" alt="image-20210804172820414"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804173023737.jpg" alt="image-20210804173023737"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804173053364.jpg" alt="image-20210804173053364"></p>
<h3 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804173206886.jpg" alt="image-20210804173206886"></p>
<h3 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804173315142.jpg" alt="image-20210804173315142"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804173348170.jpg" alt="image-20210804173348170"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804173549842.jpg" alt="image-20210804173549842"></p>
<h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>并行传输</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193314193.jpg" alt="image-20210804193314193"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193346410.jpg" alt="image-20210804193346410"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193505965.jpg" alt="image-20210804193505965"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193528046.jpg" alt="image-20210804193528046"></p>
<p>串行传输</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193722198.jpg" alt="image-20210804193722198"></p>
<p>支持热插拔</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193815040.jpg" alt="image-20210804193815040"></p>
<p>设备总线标准</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193859415.jpg" alt="image-20210804193859415"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804193925451.jpg" alt="image-20210804193925451"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804194039982.jpg" alt="image-20210804194039982"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804194105837.jpg" alt="image-20210804194105837"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804194341097.jpg" alt="image-20210804194341097"></p>
<h3 id="为何串行总线取代并行总线"><a href="#为何串行总线取代并行总线" class="headerlink" title="为何串行总线取代并行总线"></a>为何串行总线取代并行总线</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804194500044.jpg" alt="image-20210804194500044"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210804194715468.jpg" alt="image-20210804194715468"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/PCC_006_%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%80%BB%E7%BA%BF/" data-id="cll50ezz5001dxpbid6u98id1" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PCC_005_第五章-中央处理器CPU" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/PCC_005_%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8CPU/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.105Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第五章-中央处理器CPU"><a href="#第五章-中央处理器CPU" class="headerlink" title="第五章 中央处理器CPU"></a>第五章 中央处理器CPU</h1><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721184403798.jpg" alt="image-20210721184403798"></p>
<h2 id="CPU的功能和结构"><a href="#CPU的功能和结构" class="headerlink" title="CPU的功能和结构"></a>CPU的功能和结构</h2><h3 id="CPU的功能"><a href="#CPU的功能" class="headerlink" title="CPU的功能"></a>CPU的功能</h3><p>1.指令控制</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721185931323.jpg" alt="image-20210721185931323"></p>
<p>2.操作控制</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721185942291.jpg" alt="image-20210721185942291"></p>
<p>3.时间控制</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721190019863.jpg" alt="image-20210721190019863"></p>
<p>4.数据加工</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721190027711.jpg" alt="image-20210721190027711"></p>
<p>5.中断处理</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721190038328.jpg" alt="image-20210721190038328"></p>
<h3 id="运算器和控制器的功能"><a href="#运算器和控制器的功能" class="headerlink" title="运算器和控制器的功能"></a>运算器和控制器的功能</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721190511050.jpg" alt="image-20210721190511050"></p>
<h4 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h4><p>1.算数逻辑单元</p>
<p>进行算术&#x2F;逻辑运算</p>
<p>2.通用寄存器组</p>
<p>存放操作数（包括源操作数、目的操作数及中间结果和各地址信息等）如AX,BX,CX,DX,SP等</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721200236671.jpg" alt="image-20210721200236671"></p>
<h5 id="连线方式"><a href="#连线方式" class="headerlink" title="连线方式"></a>连线方式</h5><h6 id="专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路"><a href="#专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路" class="headerlink" title="专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路"></a>专用数据通路方式：根据指令执行过程中的数据和地址的流动方向安排连接线路</h6><p>如果直接用导线连接，相当于多个寄存器同时并且一直向ALU传输数据</p>
<p>方法1：使用多路选择器</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727123834990.jpg" alt="image-20210727123834990"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727123914076.jpg" alt="image-20210727123914076"></p>
<p>方法2：使用三态门</p>
<p>可以控制每一路是否输出</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721200929571.jpg" alt="image-20210721200929571"><br>$$<br>\begin{align}<br>&amp;R0_{out}&#x3D;1时R_0中的数据输出到A端\<br>&amp;R0_{out}&#x3D;0时R_0中的数据无法输出到B端\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721201132262.jpg" alt="image-20210721201132262"></p>
<p>3.暂存寄存器</p>
<p>暂存从主存读来的数据，这个数据不能存放在通用寄存器中，否则会破坏其原有内容</p>
<p>如果两个操作数</p>
<h6 id="CPU内部单总线方式：所有寄存器的输入端和输出端都连接在一条公共的通路上"><a href="#CPU内部单总线方式：所有寄存器的输入端和输出端都连接在一条公共的通路上" class="headerlink" title="CPU内部单总线方式：所有寄存器的输入端和输出端都连接在一条公共的通路上"></a>CPU内部单总线方式：所有寄存器的输入端和输出端都连接在一条公共的通路上</h6><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210721201529622.jpg" alt="image-20210721201529622"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/Y_E%7BPDCPUM333AYF%7DFO%F_V.jpg" alt="img"></p>
<p>$$<br>\begin{align}<br>&amp;暂存寄存器解决需要多个数据时造成的总线冲突，如需要R_0+R_1时会造成总线冲突，先把R_0传输到数据总线，R_1放置于暂存寄存器，等待R_0传输结束,在将R_1从暂存寄存器中传至数据总线完成一次加法\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727125341977.jpg" alt="image-20210727125341977"></p>
<p>4.累加寄存器</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727125619934.jpg" alt="image-20210727125619934"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727125528863.jpg" alt="image-20210727125528863"></p>
<p>5.程序状态字寄存器</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727125646606.jpg" alt="image-20210727125646606"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727125730949.jpg" alt="image-20210727125730949"></p>
<p>6.移位器</p>
<p>对运算结果进行移位运算</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727125820889.jpg" alt="image-20210727125820889"></p>
<p>7.计数器</p>
<p>控制乘除运算的操作步数</p>
<h4 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727130643958.jpg" alt="image-20210727130643958"></p>
<p> 1.程序计数器</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727130223050.jpg" alt="image-20210727130223050"></p>
<p>2.指令寄存器</p>
<p>用于保存当前正在执行的那条指令</p>
<p>3.指令译码器</p>
<p>仅对操作码字段进行译码，向控制器提供特定的操作信号</p>
<p>4.存储器地址寄存器（<strong>MAR</strong>）</p>
<p>用于存放要访问的主存单元地址</p>
<p>5.存储器数据寄存器（<strong>MDR</strong>）</p>
<p>用于存放向主存写入的的信息或从主存读出的信息</p>
<p>6.时序系统</p>
<p>用于产生各种时序信号，它们都是由统一时钟（<strong>CLOCK</strong>）分频得到</p>
<p>7.微操作信号发生器</p>
<p>根据IR的内容（指令），<strong>PSW</strong>的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑性</p>
<h3 id="CPU的结构"><a href="#CPU的结构" class="headerlink" title="CPU的结构"></a>CPU的结构</h3><p>用户可见的寄存器（可编程，即程序员可以通过汇编语言操作的寄存器）</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727131611682.jpg" alt="image-20210727131611682"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727131638321.jpg" alt="image-20210727131638321"></p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p><strong>指令周期</strong>：CPU从主存中每取出并执行一条指令所需的全部时间</p>
<p><strong>指令周期</strong>常常用于若干<strong>机器周期</strong>来表示，机器周期又叫<strong>CPU周期</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727175501451.jpg" alt="image-20210727175501451"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727175516629.jpg" alt="image-20210727175516629"></p>
<p>一个<strong>机器周期</strong>又包括若干个<strong>时钟周期</strong>（也称<strong>节拍</strong>，<strong>T周期</strong>或<strong>CPU时钟周期</strong>，是CPU操作的<strong>最基本单位</strong>）</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727175306246.jpg" alt="image-20210727175306246"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727175917458.jpg" alt="image-20210727175917458"></p>
<h3 id="指令周期流程"><a href="#指令周期流程" class="headerlink" title="指令周期流程"></a>指令周期流程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180005843.jpg" alt="image-20210727180005843"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180324241.jpg" alt="image-20210727180324241"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180306810.jpg" alt="image-20210727180306810"></p>
<h3 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180516212.jpg" alt="image-20210727180516212"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180531888.jpg" alt="image-20210727180531888"></p>
<h3 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180808953.jpg" alt="image-20210727180808953"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180828153.jpg" alt="image-20210727180828153"></p>
<h3 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181338562.jpg" alt="image-20210727181338562"></p>
<h3 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727180959374.jpg" alt="image-20210727180959374"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181206770.jpg" alt="image-20210727181206770"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181311557.jpg" alt="image-20210727181311557"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181239381.jpg" alt="image-20210727181239381"></p>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><h4 id="单指令周期"><a href="#单指令周期" class="headerlink" title="单指令周期"></a>单指令周期</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181521088.jpg" alt="image-20210727181521088"></p>
<h4 id="多指令周期"><a href="#多指令周期" class="headerlink" title="多指令周期"></a>多指令周期</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181540094.jpg" alt="image-20210727181540094"></p>
<h4 id="流水线周期"><a href="#流水线周期" class="headerlink" title="流水线周期"></a>流水线周期</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181603193.jpg" alt="image-20210727181603193"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727181821416.jpg" alt="image-20210727181821416"></p>
<h2 id="数据通路的功能"><a href="#数据通路的功能" class="headerlink" title="数据通路的功能"></a>数据通路的功能</h2><p>数据在功能部件之间传送的路径<br>$$<br>\begin{align}<br>&amp;数据通路基本结构\begin{cases}1.CPU内部单总线方式\2.CPU内部多总线方式\3.专用数据通路方式\\end{cases}\</p>
<p>\end{align}<br>$$</p>
<h3 id="CPU内部总线方式"><a href="#CPU内部总线方式" class="headerlink" title="CPU内部总线方式"></a>CPU内部总线方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171132827.jpg" alt="image-20210727171132827"></p>
<h4 id="寄存器之间数据传输"><a href="#寄存器之间数据传输" class="headerlink" title="寄存器之间数据传输"></a>寄存器之间数据传输</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171245965.jpg" alt="image-20210727171245965"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171606113.jpg" alt="image-20210727171606113"></p>
<h4 id="主存与CPU之间的数据传送"><a href="#主存与CPU之间的数据传送" class="headerlink" title="主存与CPU之间的数据传送"></a>主存与CPU之间的数据传送</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171428283.jpg" alt="image-20210727171428283"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171525674.jpg" alt="image-20210727171525674"></p>
<h4 id="执行算术或逻辑运算"><a href="#执行算术或逻辑运算" class="headerlink" title="执行算术或逻辑运算"></a>执行算术或逻辑运算</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171933830.jpg" alt="image-20210727171933830"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727171923259.jpg" alt="image-20210727171923259"></p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727174532011.jpg" alt="image-20210727174532011"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727174557930.jpg" alt="image-20210727174557930"></p>
<p>1.分析指令功能和指令周期</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727183522172.jpg" alt="image-20210727183522172"></p>
<p>2.写出各阶段的指令流程</p>
<p><strong>取指周期</strong></p>
<table>
<thead>
<tr>
<th>时序</th>
<th>微操作</th>
<th>有效控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(PC)-&gt;MAR</td>
<td>PCout,MARin</td>
</tr>
<tr>
<td>2</td>
<td>M(MAR)-&gt;MDR,(PC)+1-&gt;PC</td>
<td>MemR,MARout,MDRinE</td>
</tr>
<tr>
<td>3</td>
<td>(MDR)-&gt;IR</td>
<td>MDRout,IRin</td>
</tr>
<tr>
<td>4</td>
<td>指令译码</td>
<td>-</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727190232964.jpg" alt="image-20210727190232964"></p>
<p><strong>间址周期</strong></p>
<p>完成取数操作，被加数在主存中，加数已经放在寄存器R1中</p>
<table>
<thead>
<tr>
<th>时序</th>
<th>微操作</th>
<th>有效控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(R0)-&gt;MAR</td>
<td>R0out,MARin</td>
</tr>
<tr>
<td>2</td>
<td>M(MAR)-&gt;MDR</td>
<td>MemR,MARout,MDRinE</td>
</tr>
<tr>
<td>3</td>
<td>(MDR)-&gt;Y</td>
<td>MDRout,Yin</td>
</tr>
</tbody></table>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727190153694.jpg" alt="image-20210727190153694"></p>
<p><strong>执行周期</strong></p>
<p>完成取数操作，被加数在主存中，加数已经存放在寄存器R1中</p>
<table>
<thead>
<tr>
<th>时序</th>
<th>微操作</th>
<th>有效控制信号</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>(R1)+(Y)-&gt;Z</td>
<td>R1out,ALUin,CU向ALU发ADD控制信号</td>
</tr>
<tr>
<td>2</td>
<td>(Z)-&gt;MDR</td>
<td>Zout,MDRin</td>
</tr>
<tr>
<td>3</td>
<td>(MDR)-&gt;M(MAR)</td>
<td>MenW,MDRoutE,MARout</td>
</tr>
</tbody></table>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727191919813.jpg" alt="image-20210727191919813"></p>
<h2 id="专用数据通路"><a href="#专用数据通路" class="headerlink" title="专用数据通路"></a>专用数据通路</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727192531465.jpg" alt="image-20210727192531465"></p>
<h3 id="取指周期-1"><a href="#取指周期-1" class="headerlink" title="取指周期"></a>取指周期</h3><p>$$<br>\begin{align}<br>&amp;(PC)\rightarrow MAR, C_0有效\<br>&amp;(MAR)\rightarrow主存,C_1有效\<br>&amp;M(MAR)\rightarrow MDR,C_2有效\<br>&amp;(MDR)\rightarrow IR,C_3有效\<br>&amp;(PC)+1\rightarrow PC\<br>&amp;Op(IR)\rightarrow CU,C_4有效\<br>\end{align}<br>$$</p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727205416083.jpg" alt="image-20210727205416083"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727205357777.jpg" alt="image-20210727205357777"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727205429814.jpg" alt="image-20210727205429814"><br>$$<br>\begin{align}<br>&amp;(1)a:MDR,b:IR,c:MAR,d:PC\<br>&amp;(2)(PC)\rightarrow MAR\<br>&amp;M(MAR)\rightarrow MDR\<br>&amp;(MDR)\rightarrow IR\<br>&amp;OP(IR)\rightarrow 微操作发生器\<br>&amp;(PC)+1\rightarrow PC\<br>&amp;(3)取：\<br>&amp;M(MAR)\rightarrow MDR\<br>&amp;(MDR)\rightarrow ALU\rightarrow ACC\<br>&amp;存：\<br>&amp;(ACC)\rightarrow MDR\<br>&amp;(MDR)\rightarrow M(MAR)\<br>&amp;(4)X\rightarrow MAR\<br>&amp;M(MAR)\rightarrow MDR\<br>&amp;(MDR)\rightarrow ALU\rightarrow ACC\<br>&amp;(5)Y\rightarrow MAR\<br>&amp;(MAR)\rightarrow ALU,(ACC)\rightarrow ALU\<br>&amp;ALU\rightarrow ACC\<br>&amp;(6)Z\rightarrow MAR\<br>&amp;(ACC)\rightarrow MDR\<br>&amp;(MDR)\rightarrow M(MAR)\<br>\end{align}<br>$$</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210727213702928.jpg" alt="image-20210727213702928"></p>
<h2 id="控制器设计-硬布线控制器"><a href="#控制器设计-硬布线控制器" class="headerlink" title="控制器设计 硬布线控制器"></a>控制器设计 硬布线控制器</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728095801939.jpg" alt="image-20210728095801939"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728095955749.jpg" alt="image-20210728095955749"><br>$$<br>\begin{align}<br>&amp;CU发出一个微命令，可完成对应的微操作\<br>&amp;如：微命令1使得PC_{out},MAR_{in}有效,完成对应的微操作1(PC)\rightarrow MAR\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728100041937.jpg" alt="image-20210728100041937"></p>
<p>根据<strong>指令操作码</strong>，<strong>目前的机器周期</strong>，<strong>节拍信号</strong>，<strong>机器状态条件</strong>，即可确定现在这个节拍下<strong>应该发出哪些“微命令”</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728100823083.jpg" alt="image-20210728100823083"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728100838801.jpg" alt="image-20210728100838801"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728100906275.jpg" alt="image-20210728100906275"></p>
<h3 id="硬布线控制器的设计"><a href="#硬布线控制器的设计" class="headerlink" title="硬布线控制器的设计"></a>硬布线控制器的设计</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728101324227.jpg" alt="image-20210728101324227"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728101334738.jpg" alt="image-20210728101334738"></p>
<h4 id="微操作序列"><a href="#微操作序列" class="headerlink" title="微操作序列"></a>微操作序列</h4><h5 id="取指周期微操作序列"><a href="#取指周期微操作序列" class="headerlink" title="取指周期微操作序列"></a>取指周期微操作序列</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728101733688.jpg" alt="image-20210728101733688"></p>
<h5 id="间址周期微操作序列"><a href="#间址周期微操作序列" class="headerlink" title="间址周期微操作序列"></a>间址周期微操作序列</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728101748131.jpg" alt="image-20210728101748131"></p>
<h5 id="执行周期微操作序列"><a href="#执行周期微操作序列" class="headerlink" title="执行周期微操作序列"></a>执行周期微操作序列</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728101801822.jpg" alt="image-20210728101801822"></p>
<h4 id="安排微操作时序的原则"><a href="#安排微操作时序的原则" class="headerlink" title="安排微操作时序的原则"></a>安排微操作时序的原则</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728103230882.jpg" alt="image-20210728103230882"></p>
<h5 id="安排微操作时序-取指周期"><a href="#安排微操作时序-取指周期" class="headerlink" title="安排微操作时序 取指周期"></a>安排微操作时序 取指周期</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728103327517.jpg" alt="image-20210728103327517"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728103346913.jpg" alt="image-20210728103346913"></p>
<h5 id="安排微操作时序-间址周期"><a href="#安排微操作时序-间址周期" class="headerlink" title="安排微操作时序 间址周期"></a>安排微操作时序 间址周期</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728103427192.jpg" alt="image-20210728103427192"></p>
<h5 id="安排微操作时序-执行周期"><a href="#安排微操作时序-执行周期" class="headerlink" title="安排微操作时序 执行周期"></a>安排微操作时序 执行周期</h5><p>非访存指令</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728103900058.jpg" alt="image-20210728103900058"></p>
<p>访存指令</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728103942211.jpg" alt="image-20210728103942211"></p>
<p>转移指令</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728104003240.jpg" alt="image-20210728104003240"></p>
<h3 id="组合逻辑设计"><a href="#组合逻辑设计" class="headerlink" title="组合逻辑设计"></a>组合逻辑设计</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728104233566.jpg" alt="image-20210728104233566"></p>
<h4 id="列出操作时间表"><a href="#列出操作时间表" class="headerlink" title="列出操作时间表"></a>列出操作时间表</h4><h5 id="取值周期"><a href="#取值周期" class="headerlink" title="取值周期"></a>取值周期</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728104423800.jpg" alt="image-20210728104423800"></p>
<h5 id="间址周期-1"><a href="#间址周期-1" class="headerlink" title="间址周期"></a>间址周期</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728104530650.jpg" alt="image-20210728104530650"></p>
<h5 id="执行周期-1"><a href="#执行周期-1" class="headerlink" title="执行周期"></a>执行周期</h5><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728104729864.jpg" alt="image-20210728104729864"></p>
<h4 id="微操作信号综合"><a href="#微操作信号综合" class="headerlink" title="微操作信号综合"></a>微操作信号综合</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728105806788.jpg" alt="image-20210728105806788"></p>
<h4 id="画出逻辑图"><a href="#画出逻辑图" class="headerlink" title="画出逻辑图"></a>画出逻辑图</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728110020898.jpg" alt="image-20210728110020898"></p>
<h3 id="硬布线控制器的设计-1"><a href="#硬布线控制器的设计-1" class="headerlink" title="硬布线控制器的设计"></a>硬布线控制器的设计</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728110254068.jpg" alt="image-20210728110254068"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210728110307116.jpg" alt="image-20210728110307116"></p>
<h2 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h2><h3 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h3><p>采用“存储程序”的思想，CPU出厂前将所有指令的“微程序”存入“控制器存储器”中</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729102726305.jpg" alt="image-20210729102726305"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729102743382.jpg" alt="image-20210729102743382"></p>
<p><strong>程序</strong>由<strong>机器指令</strong>序列组成</p>
<p><strong>微程序</strong>由<strong>微指令</strong>序列组成，<strong>每一种指令对应应该微程序</strong></p>
<p><strong>机器指令</strong>是程序执行步骤的描述</p>
<p><strong>微指令</strong>是对指令执行步骤的描述</p>
<h4 id="微命令与微操作"><a href="#微命令与微操作" class="headerlink" title="微命令与微操作"></a>微命令与微操作</h4><p><strong>微命令</strong>与<strong>微操作</strong>一一对应</p>
<p><strong>微指令</strong>中可能包含<strong>多个微命令</strong></p>
<h4 id="微程序与机器指令"><a href="#微程序与机器指令" class="headerlink" title="微程序与机器指令"></a>微程序与机器指令</h4><p><strong>微程序</strong>与<strong>机器指令</strong>一一对应</p>
<p>一个<strong>微程序</strong>由多个<strong>微指令</strong>序列构成</p>
<p><strong>机器指令</strong>是对<strong>微指令</strong>功能的“封装”</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729103423858.jpg" alt="image-20210729103423858"></p>
<h3 id="微程序控制器的基本结构"><a href="#微程序控制器的基本结构" class="headerlink" title="微程序控制器的基本结构"></a>微程序控制器的基本结构</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729104157450.jpg" alt="image-20210729104157450"></p>
<p>（1）由<strong>IR</strong>将<strong>机器指令操作码</strong>传入<strong>微地址形成部件</strong></p>
<p>（2）<strong>微地址形成部件</strong>根据传入的<strong>操作码</strong>确定这条<strong>机器指令</strong>对应的<strong>微指令序列</strong>的起始地址</p>
<p>（3）根据<strong>顺序逻辑</strong>的标志等确定接下来执行<strong>微指令</strong>的存放地址</p>
<p>（4）将<strong>微指令</strong>的存放地址放入<strong>CMAR</strong>中</p>
<p>（5）由<strong>地址译码</strong>将地址信息转为<strong>控制信号</strong>传入<strong>控制存储器CM</strong></p>
<p>（6）<strong>控制存储器CM</strong>确定地址信息所指向的<strong>微指令</strong>（一条微指令包含两部分信息，【本条微指令的控制信号|接下来要执行的微指令的地址（下地址）】）</p>
<p>（7）将选中的<strong>微指令</strong>放入<strong>CMDR</strong></p>
<p>（8）执行完本条<strong>微指令</strong>（硬件电路需要通过控制码向CPU的其他部件或向系统总线发送控制信号）</p>
<p>（9）将下地址信息传递至顺序逻辑</p>
<p>重复（3）~（9）</p>
<ul>
<li><input disabled="" type="checkbox"> <strong>所有机器指令的取指周期、间址周期、中断周期所对应的微指令序列都一样，是否可以共享使用？</strong></li>
</ul>
<h3 id="微程序控制器的工作原理"><a href="#微程序控制器的工作原理" class="headerlink" title="微程序控制器的工作原理"></a>微程序控制器的工作原理</h3><p><img src="/image-20210729181813952.jpg" alt="image-20210729181813952"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729182104676.jpg" alt="image-20210729182104676"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729182145215.jpg" alt="image-20210729182145215"></p>
<p>如果某指令系统中有n条机器指令，则CM中的微程序（段）的个数至少是n+1个</p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729182513663.jpg" alt="image-20210729182513663"></p>
<h2 id="微指令的设计"><a href="#微指令的设计" class="headerlink" title="微指令的设计"></a>微指令的设计</h2><h3 id="微指令的格式"><a href="#微指令的格式" class="headerlink" title="微指令的格式"></a>微指令的格式</h3><p><strong>相容性微命令</strong>：可以并行完成</p>
<p><strong>互斥性微命令</strong>：不允许并行完成的微命令</p>
<h4 id="水平型微指令"><a href="#水平型微指令" class="headerlink" title="水平型微指令"></a>水平型微指令</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205611725.jpg" alt="image-20210729205611725"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205732403.jpg" alt="image-20210729205732403"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205755139.jpg" alt="image-20210729205755139"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205742921.jpg" alt="image-20210729205742921"></p>
<h4 id="垂直型微指令"><a href="#垂直型微指令" class="headerlink" title="垂直型微指令"></a>垂直型微指令</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205712889.jpg" alt="image-20210729205712889"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205815319.jpg" alt="image-20210729205815319"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205828836.jpg" alt="image-20210729205828836"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729205850832.jpg" alt="image-20210729205850832"></p>
<h4 id="混合型微指令"><a href="#混合型微指令" class="headerlink" title="混合型微指令"></a>混合型微指令</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729210027405.jpg" alt="image-20210729210027405"></p>
<h3 id="微指令的编码方式"><a href="#微指令的编码方式" class="headerlink" title="微指令的编码方式"></a>微指令的编码方式</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729210128682.jpg" alt="image-20210729210128682"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729210113651.jpg" alt="image-20210729210113651"></p>
<h4 id="直接编码（直接控制）方式"><a href="#直接编码（直接控制）方式" class="headerlink" title="直接编码（直接控制）方式"></a>直接编码（直接控制）方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729211511059.jpg" alt="image-20210729211511059"></p>
<h4 id="字段直接编码方式"><a href="#字段直接编码方式" class="headerlink" title="字段直接编码方式"></a>字段直接编码方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729211720861.jpg" alt="image-20210729211720861"></p>
<p>例题：<img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729211856151.jpg" alt="image-20210729211856151"></p>
<p>解答：</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729211924228.jpg" alt="image-20210729211924228"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213402466.jpg" alt="image-20210729213402466"></p>
<h4 id="字段间接编码方式（隐式编码）"><a href="#字段间接编码方式（隐式编码）" class="headerlink" title="字段间接编码方式（隐式编码）"></a>字段间接编码方式（隐式编码）</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213457662.jpg" alt="image-20210729213457662"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213508419.jpg" alt="image-20210729213508419"></p>
<h3 id="微指令的地址形成方式"><a href="#微指令的地址形成方式" class="headerlink" title="微指令的地址形成方式"></a>微指令的地址形成方式</h3><h4 id="微指令的下地址字段指出"><a href="#微指令的下地址字段指出" class="headerlink" title="微指令的下地址字段指出"></a>微指令的<strong>下地址字段</strong>指出</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213822807.jpg" alt="image-20210729213822807"></p>
<h4 id="根据机器指令的操作码形成"><a href="#根据机器指令的操作码形成" class="headerlink" title="根据机器指令的操作码形成"></a>根据机器指令的操作码形成</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213835096.jpg" alt="image-20210729213835096"></p>
<h4 id="增量计数器法"><a href="#增量计数器法" class="headerlink" title="增量计数器法"></a>增量计数器法</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213847603.jpg" alt="image-20210729213847603"></p>
<h4 id="分支转移"><a href="#分支转移" class="headerlink" title="分支转移"></a>分支转移</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213856998.jpg" alt="image-20210729213856998"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213908415.jpg" alt="image-20210729213908415"></p>
<h4 id="通过网络测试网络"><a href="#通过网络测试网络" class="headerlink" title="通过网络测试网络"></a>通过网络测试网络</h4><h4 id="由硬件产生微程序人口地址"><a href="#由硬件产生微程序人口地址" class="headerlink" title="由硬件产生微程序人口地址"></a>由硬件产生微程序人口地址</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729213922731.jpg" alt="image-20210729213922731"></p>
<p>例题-断定方式</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729214107257.jpg" alt="image-20210729214107257"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729214202685.jpg" alt="image-20210729214202685"></p>
<p>解答</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729214122119.jpg" alt="image-20210729214122119"></p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729214323666.jpg" alt="image-20210729214323666"></p>
<h2 id="微程序控制单元的设计"><a href="#微程序控制单元的设计" class="headerlink" title="微程序控制单元的设计"></a>微程序控制单元的设计</h2><h3 id="设计步骤"><a href="#设计步骤" class="headerlink" title="设计步骤"></a>设计步骤</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729214412052.jpg" alt="image-20210729214412052"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729214754924.jpg" alt="image-20210729214754924"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729215408636.jpg" alt="image-20210729215408636"></p>
<p>取指周期的第一条微指令地址由硬件自动给出（指令a）</p>
<p>用微指令a的下地址表示b的地址</p>
<p><strong>还需考虑如何读出这3条微指令，以及如何转入下一个机器周期</strong><br>$$<br>\begin{align}<br>&amp;Ad(CMDR)\rightarrow CMAR\space\space用当前微指令的下地址表示找到下一条微指令\<br>&amp;OP(IR)\rightarrow 微地址形成部件\rightarrow CMAR\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729215313186.jpg" alt="image-20210729215313186"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729215717102.jpg" alt="image-20210729215717102"></p>
<h3 id="微程序设计的分类"><a href="#微程序设计的分类" class="headerlink" title="微程序设计的分类"></a>微程序设计的分类</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729215843611.jpg" alt="image-20210729215843611"></p>
<h3 id="硬布线控制器-微程序控制器比较"><a href="#硬布线控制器-微程序控制器比较" class="headerlink" title="硬布线控制器&amp;微程序控制器比较"></a>硬布线控制器&amp;微程序控制器比较</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729215951198.jpg" alt="image-20210729215951198"></p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729220056932.jpg" alt="image-20210729220056932"></p>
<h2 id="指令流水"><a href="#指令流水" class="headerlink" title="指令流水"></a>指令流水</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729220711583.jpg" alt="image-20210729220711583"></p>
<h3 id="指令流水的方式"><a href="#指令流水的方式" class="headerlink" title="指令流水的方式"></a>指令流水的方式</h3><h4 id="顺序执行方式"><a href="#顺序执行方式" class="headerlink" title="顺序执行方式"></a>顺序执行方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729220734905.jpg" alt="image-20210729220734905"></p>
<h4 id="一次重叠执行方式"><a href="#一次重叠执行方式" class="headerlink" title="一次重叠执行方式"></a>一次重叠执行方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729220806932.jpg" alt="image-20210729220806932"></p>
<h4 id="二次重叠执行方式"><a href="#二次重叠执行方式" class="headerlink" title="二次重叠执行方式"></a>二次重叠执行方式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729220909305.jpg" alt="image-20210729220909305"></p>
<h3 id="流水线的表示方式"><a href="#流水线的表示方式" class="headerlink" title="流水线的表示方式"></a>流水线的表示方式</h3><h4 id="指令执行过程图"><a href="#指令执行过程图" class="headerlink" title="指令执行过程图"></a>指令执行过程图</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221059504.jpg" alt="image-20210729221059504"></p>
<h4 id="时空图"><a href="#时空图" class="headerlink" title="时空图"></a>时空图</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221133380.jpg" alt="image-20210729221133380"></p>
<h3 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h3><h4 id="吞吐率"><a href="#吞吐率" class="headerlink" title="吞吐率"></a>吞吐率</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221356700.jpg" alt="image-20210729221356700"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221534115.jpg" alt="image-20210729221534115"></p>
<p><strong>装入时间</strong>：第一条时间从开始到结束的时间</p>
<p><strong>排空时间</strong>：最后一条指令从开始到结束的时间</p>
<h4 id="加速比"><a href="#加速比" class="headerlink" title="加速比"></a>加速比</h4><p> <img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221840108.jpg" alt="image-20210729221840108"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221902164.jpg" alt="image-20210729221902164"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729221915321.jpg" alt="image-20210729221915321"></p>
<h4 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729222016087.jpg" alt="image-20210729222016087"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729222044027.jpg" alt="image-20210729222044027"></p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210729222211865.jpg" alt="image-20210729222211865"></p>
<h2 id="指令流水线影响因素分类"><a href="#指令流水线影响因素分类" class="headerlink" title="指令流水线影响因素分类"></a>指令流水线影响因素分类</h2><h3 id="机器周期的设置"><a href="#机器周期的设置" class="headerlink" title="机器周期的设置"></a>机器周期的设置</h3><p><strong>Cache</strong>一般会被分为两部分，<strong>Instruction Cache</strong>和<strong>Data Cache</strong></p>
<p>通常Cache中会保存主存的副本</p>
<p>因此取指令和访存阶段会先在Cache中寻找</p>
<p>没有找到再去访问主存</p>
<p><strong>Imm</strong>为立即数寄存器</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730145625224.jpg" alt="image-20210730145625224"></p>
<h3 id="影响流水线的因素"><a href="#影响流水线的因素" class="headerlink" title="影响流水线的因素"></a>影响流水线的因素</h3><h4 id="结构相关（资源冲突）"><a href="#结构相关（资源冲突）" class="headerlink" title="结构相关（资源冲突）"></a>结构相关（资源冲突）</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730150329274.jpg" alt="image-20210730150329274"></p>
<p>类比操作系统互斥</p>
<h4 id="数据相关（数据冲突）"><a href="#数据相关（数据冲突）" class="headerlink" title="数据相关（数据冲突）"></a>数据相关（数据冲突）</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730150713416.jpg" alt="image-20210730150713416"></p>
<p>解决方法1：等待</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730150845363.jpg" alt="image-20210730150845363"></p>
<p>（1）硬件阻塞</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730150909499.jpg" alt="image-20210730150909499"></p>
<p>（2）软件插入</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730151024911.jpg" alt="image-20210730151024911"></p>
<p>解决方案2：数据旁路技术（转发机制）</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730151239611.jpg" alt="image-20210730151239611"></p>
<p>解决方案3：编译优化</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730151306737.jpg" alt="image-20210730151306737"></p>
<h4 id="控制相关（控制冲突）"><a href="#控制相关（控制冲突）" class="headerlink" title="控制相关（控制冲突）"></a>控制相关（控制冲突）</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730151634865.jpg" alt="image-20210730151634865"></p>
<h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730151736809.jpg" alt="image-20210730151736809"></p>
<h3 id="流水线的分类"><a href="#流水线的分类" class="headerlink" title="流水线的分类"></a>流水线的分类</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730151941937.jpg" alt="image-20210730151941937"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152011810.jpg" alt="image-20210730152011810"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152054563.jpg" alt="image-20210730152054563"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152121282.jpg" alt="image-20210730152121282"></p>
<h3 id="流水线的多发技术"><a href="#流水线的多发技术" class="headerlink" title="流水线的多发技术"></a>流水线的多发技术</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152255538.jpg" alt="image-20210730152255538"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152414045.jpg" alt="image-20210730152414045"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152508546.jpg" alt="image-20210730152508546"></p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730152616866.jpg" alt="image-20210730152616866"></p>
<h2 id="五段式指令流水线"><a href="#五段式指令流水线" class="headerlink" title="五段式指令流水线"></a>五段式指令流水线</h2><p>$$<br>\begin{align}<br>&amp;五段式指令\begin{cases}&amp;取指Fetch(IF)\&amp;译码Decode(ID)\&amp;执行Execute(EX)\&amp;访存Memory(M)\&amp;写回Writeback(WB)\\end{cases}\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730165925232.jpg" alt="image-20210730165925232"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730165935657.jpg" alt="image-20210730165935657"></p>
<h3 id="运算类指令的执行过程"><a href="#运算类指令的执行过程" class="headerlink" title="运算类指令的执行过程"></a>运算类指令的执行过程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170614844.jpg" alt="image-20210730170614844"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170006307.jpg" alt="image-20210730170006307"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730165943736.jpg" alt="image-20210730165943736"></p>
<h3 id="LOAD指令的执行过程"><a href="#LOAD指令的执行过程" class="headerlink" title="LOAD指令的执行过程"></a>LOAD指令的执行过程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170437769.jpg" alt="image-20210730170437769"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170507253.jpg" alt="image-20210730170507253"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170525648.jpg" alt="image-20210730170525648"></p>
<p>其他指令都是从寄存器中获得<strong>立即数</strong>进行运算</p>
<h3 id="STORE指令的执行过程"><a href="#STORE指令的执行过程" class="headerlink" title="STORE指令的执行过程"></a>STORE指令的执行过程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170840786.jpg" alt="image-20210730170840786"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730170858271.jpg" alt="image-20210730170858271"></p>
<h3 id="条件转移指令的执行过程"><a href="#条件转移指令的执行过程" class="headerlink" title="条件转移指令的执行过程"></a>条件转移指令的执行过程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730171512962.jpg" alt="image-20210730171512962"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730171550935.jpg" alt="image-20210730171550935"><br>$$<br>\begin{align}<br>&amp;（PC）+指令字长+（偏移量<em>指令字长）\rightarrow PC\<br>&amp;指令字长&#x3D;4B\<br>&amp;(PC)+4+(996</em>4)\rightarrow PC\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730171704622.jpg" alt="image-20210730171704622"></p>
<h3 id="无条件转移指令的执行过程"><a href="#无条件转移指令的执行过程" class="headerlink" title="无条件转移指令的执行过程"></a>无条件转移指令的执行过程</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730172158505.jpg" alt="image-20210730172158505"></p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730172518572.jpg" alt="image-20210730172518572"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210730172528293.jpg" alt="image-20210730172528293"></p>
<p>解答</p>
<p>（1）I3与I1和I2存在数据相关</p>
<p>（2）I4的IF段必须在I3进入ID段后才能开始，否则会覆盖IF段锁存器的内容</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/PCC_005_%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8CPU/" data-id="cll50ezze001jxpbid3lgd9mi" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PCC_004_第四章-指令系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/PCC_004_%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.060Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第四章-指令系统"><a href="#第四章-指令系统" class="headerlink" title="第四章 指令系统"></a>第四章 指令系统</h1><p>操作码：指明了“做什么”</p>
<p>地址码：指明了“对谁动手”</p>
<p>有的指令不需要地址码（停机）</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719164538219.jpg" alt="image-20210719164538219"></p>
<h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719164913952.jpg" alt="image-20210719164913952"></p>
<h3 id="零地址指令"><a href="#零地址指令" class="headerlink" title="零地址指令"></a>零地址指令</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165145721.jpg" alt="image-20210719165145721"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165157304.jpg" alt="image-20210719165157304"></p>
<h3 id="一地址指令"><a href="#一地址指令" class="headerlink" title="一地址指令"></a>一地址指令</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165500867.jpg" alt="image-20210719165500867"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165512030.jpg" alt="image-20210719165512030"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165525322.jpg" alt="image-20210719165525322"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165536655.jpg" alt="image-20210719165536655"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719165546982.jpg" alt="image-20210719165546982"></p>
<h3 id="二地址指令"><a href="#二地址指令" class="headerlink" title="二地址指令"></a>二地址指令</h3><p>四次访存</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215244141.jpg" alt="image-20210719215244141"></p>
<h3 id="三地址指令"><a href="#三地址指令" class="headerlink" title="三地址指令"></a>三地址指令</h3><p>四次访存</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215309772.jpg" alt="image-20210719215309772"></p>
<h3 id="四地址指令"><a href="#四地址指令" class="headerlink" title="四地址指令"></a>四地址指令</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215340253.jpg" alt="image-20210719215340253"><br>$$<br>\begin{align}<br>&amp;n位地址码的直接寻址范围&#x3D;2^n\<br>&amp;若指令总长度固定不变,则地址码数量越多,寻址能力越弱<br>\end{align}<br>$$</p>
<h3 id="指令按指令长度分类"><a href="#指令按指令长度分类" class="headerlink" title="指令按指令长度分类"></a>指令按指令长度分类</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215628985.jpg" alt="image-20210719215628985"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215644429.jpg" alt="image-20210719215644429"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215658975.jpg" alt="image-20210719215658975"></p>
<h4 id="定长操作码指令格式"><a href="#定长操作码指令格式" class="headerlink" title="定长操作码指令格式"></a>定长操作码指令格式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215733185.jpg" alt="image-20210719215733185"></p>
<h4 id="可变长操作码指令格式"><a href="#可变长操作码指令格式" class="headerlink" title="可变长操作码指令格式"></a>可变长操作码指令格式</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215742279.jpg" alt="image-20210719215742279"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215810369.jpg" alt="image-20210719215810369"></p>
<h3 id="指令按操作类型分类"><a href="#指令按操作类型分类" class="headerlink" title="指令按操作类型分类"></a>指令按操作类型分类</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215136560.jpg" alt="image-20210719215136560"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215152856.jpg" alt="image-20210719215152856"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215212428.jpg" alt="image-20210719215212428"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210719215849641.jpg" alt="image-20210719215849641"></p>
<h2 id="扩展操作码指令格式"><a href="#扩展操作码指令格式" class="headerlink" title="扩展操作码指令格式"></a>扩展操作码指令格式</h2><p>在设计扩展操作码指令格式时需注意：</p>
<p>（1）不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720075736535.jpg" alt="image-20210720075736535"></p>
<p>三地址指令前缀不能为1111</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720075850278.jpg" alt="image-20210720075850278"></p>
<p>（2）各指令的操作码一定不能重复</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720080003838.jpg" alt="image-20210720080003838"></p>
<h3 id="扩展操作码示例"><a href="#扩展操作码示例" class="headerlink" title="扩展操作码示例"></a>扩展操作码示例</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720080602698.jpg" alt="image-20210720080602698"><br>$$<br>\begin{align}<br>&amp;设地址长度为n，上一层留出m种状态，下一层可扩展出m*2^n种状态\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720080811923.jpg" alt="image-20210720080811923"></p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720080939403.jpg" alt="image-20210720080939403"></p>
<h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><p>下一条欲执行指令的地址（始终由程序计数器PC给出）</p>
<h3 id="顺序寻址"><a href="#顺序寻址" class="headerlink" title="顺序寻址"></a>顺序寻址</h3><h4 id="定长指令寻址"><a href="#定长指令寻址" class="headerlink" title="定长指令寻址"></a>定长指令寻址</h4><h4 id="按字编址"><a href="#按字编址" class="headerlink" title="按字编址"></a>按字编址</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720082608455.jpg" alt="image-20210720082608455"></p>
<h4 id="按字节编址"><a href="#按字节编址" class="headerlink" title="按字节编址"></a>按字节编址</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720082751297.jpg" alt="image-20210720082751297"></p>
<h4 id="变长指令寻址"><a href="#变长指令寻址" class="headerlink" title="变长指令寻址"></a>变长指令寻址</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720082902060.jpg" alt="image-20210720082902060"></p>
<h3 id="跳跃寻址"><a href="#跳跃寻址" class="headerlink" title="跳跃寻址"></a>跳跃寻址</h3><p>由转移指令指出（<strong>JMP</strong>）</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720083024428.jpg" alt="image-20210720083024428"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720082403409.jpg" alt="image-20210720082403409"></p>
<h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720083101072.jpg" alt="image-20210720083101072"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720083611833.jpg" alt="image-20210720083611833"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720083626464.jpg" alt="image-20210720083626464"></p>
<p>增加寻址特征</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720084605453.jpg" alt="image-20210720084605453"></p>
<h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>指令字中的形式地址A就是操作数的真实地址EA,即EA&#x3D;A</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720084933408.jpg" alt="image-20210720084933408"></p>
<p>一次指令的执行访存2次：</p>
<p>（1）取指令访存1次</p>
<p>（2）执行指令访存1次</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720085041217.jpg" alt="image-20210720085041217"></p>
<h3 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h3><p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，EA&#x3D;(A)</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720085949875.jpg" alt="image-20210720085949875"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090125561.jpg" alt="image-20210720090125561"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090238919.jpg" alt="image-20210720090238919"></p>
<h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>$$<br>\begin{align}<br>&amp;在指令字中直接给出操作数所在的寄存器编号，即EA&#x3D;R_i，其操作数在由R_i所指的寄存器内\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090525677.jpg" alt="image-20210720090525677"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090534892.jpg" alt="image-20210720090534892"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090546470.jpg" alt="image-20210720090546470"></p>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>$$<br>\begin{align}<br>&amp;寄存器R_i中给出的不是一个操作数,而是操作数所在主存单元的地址，即EA&#x3D;(R_i)\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090742765.jpg" alt="image-20210720090742765"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090752703.jpg" alt="image-20210720090752703"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090801102.jpg" alt="image-20210720090801102"></p>
<h3 id="隐含地址"><a href="#隐含地址" class="headerlink" title="隐含地址"></a>隐含地址</h3><p>不是显示的给出操作数的地址，而是在指令中隐含着操作数的地址</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720090907395.jpg" alt="image-20210720090907395"></p>
<h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>形式地址A就是操作数本身，又称立即数，一般采用补码形式</p>
<p>**#**表示立即寻址的特征</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720091049358.jpg" alt="image-20210720091049358"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720091107559.jpg" alt="image-20210720091107559"></p>
<h2 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h2><p>$$<br>\begin{align}<br>&amp;偏移寻址&#x3D;\begin{cases}&amp;基址寻址,EA&#x3D;(BR)+A\&amp;变址寻址,EA&#x3D;(IX)+A\&amp;相对寻址,EA&#x3D;(PC)+A\\end{cases}\<br>&amp;区别在于偏移的“起点”不一样\<br>&amp;BR-base\space address\space register\<br>&amp;EA-effective\space address\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720091911304.jpg" alt="image-20210720091911304"></p>
<h3 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h3><p>将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即EA&#x3D;(BR)+A</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720093111661.jpg" alt="image-20210720093111661"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720093223503.jpg" alt="image-20210720093223503"></p>
<p>根据通用寄存器总数判断要用几个bit指明寄存器</p>
<h4 id="基址寻址的作用"><a href="#基址寻址的作用" class="headerlink" title="基址寻址的作用"></a>基址寻址的作用</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720102839096.jpg" alt="image-20210720102839096"></p>
<p>当程序从0地址开始存储，可以使用直接寻址</p>
<p>但通常程序在内存非0地址起始，直接寻址就无法奏效</p>
<p>可以采用基址寻址</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720103226141.jpg" alt="image-20210720103226141"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720103257285.jpg" alt="image-20210720103257285"></p>
<p>采用基址寻址无需修改指令中的地址</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720104145301.jpg" alt="image-20210720104145301"></p>
<h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720110154521.jpg" alt="image-20210720110154521"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720105415955.jpg" alt="image-20210720105415955"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720110217176.jpg" alt="image-20210720110217176"></p>
<p>基址寻址中，BR保持不变作为基地址，A作为偏移量</p>
<h4 id="变址寻址的作用"><a href="#变址寻址的作用" class="headerlink" title="变址寻址的作用"></a>变址寻址的作用</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720110421096.jpg" alt="image-20210720110421096"></p>
<p>当实现循环时采用直接寻址需使用十条加法指令</p>
<p>使用变址寻址更为合适</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111102842.jpg" alt="image-20210720111102842"></p>
<h3 id="基址寻址变址寻址复合寻址"><a href="#基址寻址变址寻址复合寻址" class="headerlink" title="基址寻址变址寻址复合寻址"></a>基址寻址变址寻址复合寻址</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720105622746.jpg" alt="image-20210720105622746"></p>
<p>IX-Index Register</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720105840956.jpg" alt="image-20210720105840956"></p>
<p>先使用基址寻址将指令位置定位到100的基地址</p>
<p>再使用变址寄存器实现循环的偏移量增加</p>
<h3 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111139661.jpg" alt="image-20210720111139661"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111258098.jpg" alt="image-20210720111258098"></p>
<h4 id="相对寻址的作用"><a href="#相对寻址的作用" class="headerlink" title="相对寻址的作用"></a>相对寻址的作用</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111734831.jpg" alt="image-20210720111734831"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111552119.jpg" alt="image-20210720111552119"></p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111652115.jpg" alt="image-20210720111652115"></p>
<h3 id="硬件如何实现数的“比较”（扩展）"><a href="#硬件如何实现数的“比较”（扩展）" class="headerlink" title="硬件如何实现数的“比较”（扩展）"></a>硬件如何实现数的“比较”（扩展）</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720111936473.jpg" alt="image-20210720111936473"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720112027803.jpg" alt="image-20210720112027803"></p>
<p>无条件转移指令JMP2不会管PSW的各种标志位，直接跳转到2</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720112136118.jpg" alt="image-20210720112136118"></p>
<p>PSW也被称为标志寄存器</p>
<h2 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720112657424.jpg" alt="image-20210720112657424"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720112831093.jpg" alt="image-20210720112831093"></p>
<h3 id="硬堆栈与软堆栈"><a href="#硬堆栈与软堆栈" class="headerlink" title="硬堆栈与软堆栈"></a>硬堆栈与软堆栈</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720113010094.jpg" alt="image-20210720113010094"></p>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720112617142.jpg" alt="image-20210720112617142"></p>
<h2 id="CISC-RISC"><a href="#CISC-RISC" class="headerlink" title="CISC&amp;RISC"></a>CISC&amp;RISC</h2><h3 id="CISC"><a href="#CISC" class="headerlink" title="CISC"></a>CISC</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720113539947.jpg" alt="image-20210720113539947"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720113524873.jpg" alt="image-20210720113524873"></p>
<h3 id="RISC"><a href="#RISC" class="headerlink" title="RISC"></a>RISC</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720113613515.jpg" alt="image-20210720113613515"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720113622337.jpg" alt="image-20210720113622337"></p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210720113859181.jpg" alt="image-20210720113859181"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/PCC_004_%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" data-id="cll50ezzf001kxpbic6st7mdf" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PCC_003_第三章-存储系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/PCC_003_%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:41.016Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第三章-存储系统"><a href="#第三章-存储系统" class="headerlink" title="第三章 存储系统"></a>第三章 存储系统</h1><h2 id="存储器层次化结构"><a href="#存储器层次化结构" class="headerlink" title="存储器层次化结构"></a>存储器层次化结构</h2><h3 id="多级存储系统"><a href="#多级存储系统" class="headerlink" title="多级存储系统"></a>多级存储系统</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709102641709.jpg" alt="image-20210709102641709"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709102655653.jpg" alt="image-20210709102655653"></p>
<p>主存——辅存：实现<strong>虚拟存储系统</strong>，<em>解决了贮存容量不够的问题</em></p>
<p>Cache——主存：解决了主存与CPU速度不匹配问题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709102945108.jpg" alt="image-20210709102945108"></p>
<h3 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h3><h4 id="存储介质分类"><a href="#存储介质分类" class="headerlink" title="存储介质分类"></a>存储介质分类</h4><p>半导体存储器</p>
<p>磁表面存储器</p>
<p>光存储器</p>
<h4 id="存取方式"><a href="#存取方式" class="headerlink" title="存取方式"></a>存取方式</h4><p>相联存储器(Associative Memory)  如：”快表”，按照内容检索到存储位置进行读写</p>
<p>CAM(Content Addressed Memory)存储器</p>
<p>RAM(Random Access Memory)随机存取存储器</p>
<p>SAM(Sequential Access Memory)顺序存取存储器</p>
<p>DAM(Direct Access Memory)直接存取存储器</p>
<h4 id="信息的可改性"><a href="#信息的可改性" class="headerlink" title="信息的可改性"></a>信息的可改性</h4><p>读写存储器(Read&#x2F;Write Memory)可读可写（磁盘、内存、Cache）</p>
<p>只写存储器(Read Only Memory)可读不可写（CD-ROM，BIOS通常写在ROM）</p>
<h4 id="信息的可保存性"><a href="#信息的可保存性" class="headerlink" title="信息的可保存性"></a>信息的可保存性</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709104315290.jpg" alt="image-20210709104315290"></p>
<h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>$$<br>\begin{align}<br>&amp;1.存储容量&#x3D;存储字数<em>字长（1M</em>8位）\<br>&amp;2.单位成本：每位价格&#x3D;\frac{总成本}{总容量}\<br>&amp;3.存储速度：数据传输率&#x3D;\frac{数据的宽度}{存储周期}&#x3D;\frac{存储字长}{存储周期}\<br>&amp;主存带宽:又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字&#x2F;秒，字节&#x2F;秒(B&#x2F;s)，位&#x2F;秒(b&#x2F;s)\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709104942008.jpg" alt="image-20210709104942008"></p>
<h2 id="主存储体的基本组成"><a href="#主存储体的基本组成" class="headerlink" title="主存储体的基本组成"></a>主存储体的基本组成</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709153008450.jpg" alt="image-20210709153008450"></p>
<p>一行存储元就是一个存储字，存储字长：8bit</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709153156526.jpg" alt="image-20210709153156526"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709153808790.jpg" alt="image-20210709153808790"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709154211175.jpg" alt="image-20210709154211175"></p>
<p>计算引脚数量（数据线引脚+地址线引脚+读&#x2F;写控制线引脚+片选线引脚+等等）</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709154350099.jpg" alt="image-20210709154350099"></p>
<p>可以通过描述如<br>$$<br>\begin{align}<br>&amp;64K*16位\<br>&amp;数据线:16根\<br>&amp;地址线:16根\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709160051369.jpg" alt="image-20210709160051369"></p>
<p>将按字寻址转换为对应的按字节寻址：将字地址算术左移两位后转为相应的十进制</p>
<p>字地址：1</p>
<p>算数左移2位后：100</p>
<p>转为十进制：100 ——&gt;  4</p>
<h2 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h2><h3 id="存储器特性对比"><a href="#存储器特性对比" class="headerlink" title="存储器特性对比"></a>存储器特性对比</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709160541650.jpg" alt="image-20210709160541650"><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709160516570.jpg" alt="image-20210709160516570"><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709161754154.jpg" alt="image-20210709161754154"></p>
<h3 id="3-2-DRAM的刷新（由存储器独立完成，不需要CPU控制）"><a href="#3-2-DRAM的刷新（由存储器独立完成，不需要CPU控制）" class="headerlink" title="3.2 DRAM的刷新（由存储器独立完成，不需要CPU控制）"></a>3.2 DRAM的刷新（由存储器独立完成，不需要CPU控制）</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709160819688.jpg" alt="image-20210709160819688"></p>
<p>左侧为单个的行地址译码 直接将地址送到译码器<br>$$<br>\begin{align}<br>&amp;2^n根选通线\<br>\end{align}<br>$$</p>
<p>0000 0000 选择0号存储单元</p>
<p>右侧为行列译码 高位地址送到行地址译码器 低位地址送到列地址译码器<br>$$<br>\begin{align}<br>&amp;存储单元排成n*n的矩阵,2^{\frac{n}{2}}+2^{\frac{n}{2}}根选通线\<br>\end{align}<br>$$</p>
<p>0000 0000 选中0,0号存储单元</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709161710201.jpg" alt="image-20210709161710201"></p>
<h4 id="地址线复用"><a href="#地址线复用" class="headerlink" title="地址线复用"></a>地址线复用</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709161959829.jpg" alt="image-20210709161959829"></p>
<p><img src="/%5Cimage-20210709162041092.jpg" alt="image-20210709162041092"></p>
<h2 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h2><h3 id="ROM的类型"><a href="#ROM的类型" class="headerlink" title="ROM的类型"></a>ROM的类型</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709162521373.jpg" alt="image-20210709162521373"></p>
<h3 id="计算机内的重要ROM"><a href="#计算机内的重要ROM" class="headerlink" title="计算机内的重要ROM"></a>计算机内的重要ROM</h3><p>内存&#x3D;内存条+BIOS的芯片</p>
<p>RAM和ROM统一编制</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709162844813.jpg" alt="image-20210709162844813"></p>
<h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709163324682.jpg" alt="image-20210709163324682"></p>
<p>数据总线（宽度&#x3D;存储字长）</p>
<h3 id="位扩展（解决：数据总线宽度-存储芯片字长）"><a href="#位扩展（解决：数据总线宽度-存储芯片字长）" class="headerlink" title="位扩展（解决：数据总线宽度&gt;存储芯片字长）"></a>位扩展（解决：数据总线宽度&gt;存储芯片字长）</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709163618238.jpg" alt="image-20210709163618238"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709163633240.jpg" alt="image-20210709163633240"></p>
<p>带横线表示低电平有效，不带横线表示高电平有效</p>
<p><strong>CPU连接单个主存</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709164040888.jpg" alt="image-20210709164040888"></p>
<p><strong>CPU连接两块主存</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709164210718.jpg" alt="image-20210709164210718"></p>
<p>1号主存和2号主存连接相同的地址线，接收相同的地址，CPU可以同时对两块主存的同一地址进行读写</p>
<p><strong>CPU连接多块主存</strong></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709164429717.jpg" alt="image-20210709164429717"></p>
<h3 id="字扩展（增加主存的存储字数）"><a href="#字扩展（增加主存的存储字数）" class="headerlink" title="字扩展（增加主存的存储字数）"></a>字扩展（增加主存的存储字数）</h3><h4 id="线选法"><a href="#线选法" class="headerlink" title="线选法"></a>线选法</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709165436449.jpg" alt="image-20210709165436449"></p>
<p>高地址11和00时产生总线冲突  高地址为11和00时不能使用</p>
<h4 id="译码器片选法"><a href="#译码器片选法" class="headerlink" title="译码器片选法"></a>译码器片选法<img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709165255910.jpg" alt="image-20210709165255910"></h4><p> <img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709170229203.jpg" alt="image-20210709170229203"></p>
<h3 id="字位同时扩展法"><a href="#字位同时扩展法" class="headerlink" title="字位同时扩展法"></a>字位同时扩展法</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709170437088.jpg" alt="image-20210709170437088"></p>
<h3 id="译码器"><a href="#译码器" class="headerlink" title="译码器"></a>译码器</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210709171022499.jpg" alt="image-20210709171022499"></p>
<h2 id="双端口RAM和多模块存储器（优化多核CPU访问一根内存条的速度）"><a href="#双端口RAM和多模块存储器（优化多核CPU访问一根内存条的速度）" class="headerlink" title="双端口RAM和多模块存储器（优化多核CPU访问一根内存条的速度）"></a>双端口RAM和多模块存储器（优化多核CPU访问一根内存条的速度）</h2><h3 id="双端口RAM"><a href="#双端口RAM" class="headerlink" title="双端口RAM"></a>双端口RAM</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710155908929.jpg" alt="image-20210710155908929"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710160657540.jpg" alt="image-20210710160657540"> </p>
<p>问题：</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710160632516.jpg" alt="image-20210710160632516"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710160611419.jpg" alt="image-20210710160611419"><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710160717931.jpg" alt="image-20210710160717931"></p>
<p>优化多喝CPU访问一根内存条的速度</p>
<p>对比操作系统“读者”“写者”问题</p>
<p><strong>可以同时读不可同时写</strong></p>
<h3 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710161341565.jpg" alt="image-20210710161341565"></p>
<p>低位交叉编制可以降低存取时间</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710161553901.jpg" alt="image-20210710161553901"><br>$$<br>\begin{align}<br>&amp;m&#x3D;\frac{T}{r}满足\<br>\end{align}<br>$$<br>例题：</p>
<p>（1）计算连续取n个存储字的时间？</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710162114004.jpg" alt="image-20210710162114004"></p>
<p>（2）给定一个地址x，如何确定它属于第几个存储体？</p>
<p>例如：01101在哪个存储体？</p>
<p>法1：直接通过低位体号求得<br>$$<br>\begin{align}<br>&amp;01\Rightarrow M_1 \<br>\end{align}<br>$$</p>
<p>法2：对地址的十进制数求余<br>$$<br>\begin{align}<br>&amp;(01101)<em>2&#x3D;(13)</em>{10},13\pmod{4}&#x3D;1\Rightarrow M_1 \<br>\end{align}<br>$$</p>
<h3 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710162816363.jpg" alt="image-20210710162816363"></p>
<p>一次读一行</p>
<p>适用于连续读写</p>
<h2 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h2><h3 id="Cache工作原理"><a href="#Cache工作原理" class="headerlink" title="Cache工作原理"></a>Cache工作原理</h3><h3 id="程序的局部性原理"><a href="#程序的局部性原理" class="headerlink" title="程序的局部性原理"></a>程序的局部性原理</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710163921097.jpg" alt="image-20210710163921097"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710163946556.jpg" alt="image-20210710163946556"></p>
<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710164353024.jpg" alt="image-20210710164353024"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710164408453.jpg" alt="image-20210710164408453"></p>
<p>例题</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710164220590.jpg" alt="image-20210710164220590"><br>$$<br>\begin{align}<br>&amp;设Cache的访存周期为t,主存的存取周期为5t\<br>&amp;(1)Cache和主存同时访问:\<br>&amp;命中时访问时间为t,未命中访问时间为5t\<br>&amp;\bar t&#x3D;0.95t+5t(1-0.95)&#x3D;1.2t\<br>&amp;\eta&#x3D;\frac{5t}{\bar t}\sim4.17\<br>&amp;(2)先访问Cache再访问主存:\<br>&amp;命中时访问时间为t,未命中访问时间为t+5t\<br>&amp;\bar t&#x3D;0.95t+6t(1-0.95)&#x3D;1.25t\<br>&amp;\eta&#x3D;\frac{5t}{1.25t}&#x3D;4\<br>\end{align}<br>$$</p>
<h4 id="剩余问题"><a href="#剩余问题" class="headerlink" title="剩余问题"></a>剩余问题</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710210420887.jpg" alt="image-20210710210420887"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710210349239.jpg" alt="image-20210710210349239"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710210433763.jpg" alt="image-20210710210433763"></p>
<h2 id="Cache-主存映射方式"><a href="#Cache-主存映射方式" class="headerlink" title="Cache-主存映射方式"></a>Cache-主存映射方式</h2><h3 id="三种映射"><a href="#三种映射" class="headerlink" title="三种映射"></a>三种映射</h3><p>添加标记为和有效位</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710215134861.jpg" alt="image-20210710215134861"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710215455572.jpg" alt="image-20210710215455572"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710215530770.jpg" alt="image-20210710215530770"></p>
<h4 id="全相联映射"><a href="#全相联映射" class="headerlink" title="全相联映射"></a>全相联映射</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710215516325.jpg" alt="image-20210710215516325"></p>
<h4 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710220127614.jpg" alt="image-20210710220127614"></p>
<p>当两块冲突时无法解决</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710220109978.jpg" alt="image-20210710220109978"></p>
<p>对标记位进行优化：<br>$$<br>\begin{align}<br>&amp;主存块号%2^3\Leftrightarrow 留下最后三位二进制数\<br>&amp;即：Cache总块数&#x3D;2^n,则主存块号末尾n位反映它在Cache中的位置\<br>&amp;将主存块号的其余位作为标记\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710220724351.jpg" alt="image-20210710220724351"></p>
<p>CPU访存：</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710221911745.jpg" alt="image-20210710221911745"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710221918451.jpg" alt="image-20210710221918451"></p>
<h4 id="组相联映射"><a href="#组相联映射" class="headerlink" title="组相联映射"></a>组相联映射</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710222204893.jpg" alt="image-20210710222204893"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710222220339.jpg" alt="image-20210710222220339"></p>
<p>CPU访存：</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710222248750.jpg" alt="image-20210710222248750"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710222307630.jpg" alt="image-20210710222307630"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210710222439230.jpg" alt="image-20210710222439230"></p>
<h2 id="Cache替换算法（解决Cache被装满的问题）"><a href="#Cache替换算法（解决Cache被装满的问题）" class="headerlink" title="Cache替换算法（解决Cache被装满的问题）"></a>Cache替换算法（解决Cache被装满的问题）</h2><p>Cache完全装满了才需要替换，需要在全局选择替换哪一块</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711160553389.jpg" alt="image-20210711160553389"></p>
<p>如果对应位置非空，直接替换</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711160615752.jpg" alt="image-20210711160615752"></p>
<p>分组内满了才需要替换需要在分组内选择替换哪一块</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711160634017.jpg" alt="image-20210711160634017"></p>
<h3 id="随机算法-RAND"><a href="#随机算法-RAND" class="headerlink" title="随机算法(RAND)"></a>随机算法(RAND)</h3><p>随机选择一块替换</p>
<h4 id="算法性能："><a href="#算法性能：" class="headerlink" title="算法性能："></a>算法性能：</h4><p>实现简单，但完全没有考虑局部性原理，命中率低，实际效果很不稳定</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711164435610.jpg" alt="image-20210711164435610"></p>
<h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><p>替换最先调入Cache的块</p>
<p>实现简单，最开始#0#1#2#3放入Cache，之后轮流替换#0#1#2#3</p>
<h4 id="算法性能：-1"><a href="#算法性能：-1" class="headerlink" title="算法性能："></a>算法性能：</h4><p>没有考虑局部性原理，最先调入Cache的块也可能是被频繁访问的</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711164119361.jpg" alt="image-20210711164119361"></p>
<p><strong>抖动现象</strong>：频繁的换入换出现象（刚被替换掉块很快又被调入）</p>
<h3 id="近期最少使用算法-LRU"><a href="#近期最少使用算法-LRU" class="headerlink" title="近期最少使用算法(LRU)"></a>近期最少使用算法(LRU)</h3><p>为每一个Cache块设置一个计数器，用于记录每个Cache块已经有多久没有被访问了，当Cache满后替换计数器最大的<br>$$<br>\begin{align}<br>&amp;Cache块的总数&#x3D;2^n,则计数器只需要n位,且Cache装满后所有计数器的值一定不重复\<br>\end{align}<br>$$<br>（1）命中时，所命中的行的计数器清零，比其低的计数器加1，其余不变</p>
<p>（2）未命中且还有空闲行时，新装入的行的计数器置0，其余非空闲行全加1</p>
<p>（3）未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装行的块的计数器置0，其余全加1</p>
<h4 id="算法性能：-2"><a href="#算法性能：-2" class="headerlink" title="算法性能："></a>算法性能：</h4><p>基于局部性原理，近期被访问过的主存块，在不久的将来也很可能再次被访问，因此淘汰最久没访问过的块是合理的，实际运行效果优秀，Cache命中率高</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711165057274.jpg" alt="image-20210711165057274"></p>
<h3 id="最不经常使用算法-LFU"><a href="#最不经常使用算法-LFU" class="headerlink" title="最不经常使用算法(LFU)"></a>最不经常使用算法(LFU)</h3><p>为每一个Cache块设置一个计数器，用于记录每个Cache块被访问过几次，当Cache满后替换计数器最小的</p>
<h4 id="算法性能：-3"><a href="#算法性能：-3" class="headerlink" title="算法性能："></a>算法性能：</h4><p>曾经被经常访问的主存块在未来不一定会用到，算法实际运行效果不让LRU</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711165307359.jpg" alt="image-20210711165307359"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711170550046.jpg" alt="image-20210711170550046"></p>
<h2 id="Cache的写策略（如何保持Cache里的数据和内存里的数据保持一致）"><a href="#Cache的写策略（如何保持Cache里的数据和内存里的数据保持一致）" class="headerlink" title="Cache的写策略（如何保持Cache里的数据和内存里的数据保持一致）"></a>Cache的写策略（如何保持Cache里的数据和内存里的数据保持一致）</h2><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711170803320.jpg" alt="image-20210711170803320"></p>
<h3 id="写命中"><a href="#写命中" class="headerlink" title="写命中"></a>写命中</h3><h4 id="写回法"><a href="#写回法" class="headerlink" title="写回法"></a>写回法</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171649574.jpg" alt="image-20210711171649574"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171635987.jpg" alt="image-20210711171635987"></p>
<h4 id="全写法"><a href="#全写法" class="headerlink" title="全写法"></a>全写法</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171740689.jpg" alt="image-20210711171740689"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171728702.jpg" alt="image-20210711171728702"></p>
<h3 id="写不命中"><a href="#写不命中" class="headerlink" title="写不命中"></a>写不命中</h3><h4 id="写分配法"><a href="#写分配法" class="headerlink" title="写分配法"></a>写分配法</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171818049.jpg" alt="image-20210711171818049"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171805412.jpg" alt="image-20210711171805412"></p>
<h4 id="非写分配法"><a href="#非写分配法" class="headerlink" title="非写分配法"></a>非写分配法</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171901658.jpg" alt="image-20210711171901658"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171842837.jpg" alt="image-20210711171842837"></p>
<h3 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171945407.jpg" alt="image-20210711171945407"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711171935529.jpg" alt="image-20210711171935529"></p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711172016851.jpg" alt="image-20210711172016851"></p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><h3 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711174441630.jpg" alt="image-20210711174441630"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711174351441.jpg" alt="image-20210711174351441"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711174421728.jpg" alt="image-20210711174421728"></p>
<h4 id="虚地址与实地址"><a href="#虚地址与实地址" class="headerlink" title="虚地址与实地址"></a>虚地址与实地址</h4><p>Cache-主存分块是面向物理地址</p>
<p>程序的分页是面向逻辑地址</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711174630870.jpg" alt="image-20210711174630870"></p>
<h4 id="页表（记录逻辑页号与主存块号的关系）"><a href="#页表（记录逻辑页号与主存块号的关系）" class="headerlink" title="页表（记录逻辑页号与主存块号的关系）"></a>页表（记录逻辑页号与主存块号的关系）</h4><p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711175036358.jpg" alt="image-20210711175036358"></p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711175016518.jpg" alt="image-20210711175016518"></p>
<p>查询过程:</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711175220931.jpg" alt="image-20210711175220931"></p>
<h4 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h4><p>快表是一种相联存储器，可以按内容访存</p>
<p>将近期访问的页表项放入更高速的存储器中可加快地址转换的速度</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711175747460.jpg" alt="image-20210711175747460"></p>
<h5 id="快表和Cache的区别"><a href="#快表和Cache的区别" class="headerlink" title="快表和Cache的区别"></a>快表和Cache的区别</h5><p>快表中储存的是页表项的副本</p>
<p>Cache中储存的是主存块的副本</p>
<h5 id="访问策略"><a href="#访问策略" class="headerlink" title="访问策略"></a>访问策略</h5><p>访问快表根据页号查找</p>
<p>命中根据快表页表项得到主存块号</p>
<p>去Cache中寻找相应主存的副本</p>
<p>命中访存</p>
<p><img src="https://raw.githubusercontent.com/ebxeax/images/main/image-20210711181558957.jpg" alt="image-20210711181558957"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/PCC_003_%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F/" data-id="cll50ezz3001cxpbi2u2ege4m" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-PCC_002_data_expression_and_calculate" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/08/09/PCC_002_data_expression_and_calculate/" class="article-date">
  <time class="dt-published" datetime="2023-08-09T03:00:40.944Z" itemprop="datePublished">2023-08-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据表示和运算"><a href="#数据表示和运算" class="headerlink" title="数据表示和运算"></a>数据表示和运算</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li><strong>r进制</strong><br> $K_{n} K_{n-1} K_{n-2} \dots K_{0} K_{-1} \dots K_{-m}$<br>数值表示 $K_{n} r^{n} + K_{n-1} r^{n-1} + \dots + K_{0} r^{0} + K_{-1} r^{-1} + \dots + K_{-m} r^{-m} &#x3D; \sum_{i&#x3D;n}^{-m} K_{i} r^{i}$</li>
<li>二进制<br>$01 \space r&#x3D;2$</li>
<li>八进制<br>$01234567 \space r&#x3D;8&#x3D;2^3$</li>
<li>十六进制<br>$0123456789ABCDEF \space r&#x3D;16&#x3D;2^4$</li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>4位二进制数码与1位十六进制数码相对应<br>3位二进制数码与1位八进制数码相对应  </p>
<h2 id="原反补移"><a href="#原反补移" class="headerlink" title="原反补移"></a>原反补移</h2><ul>
<li><p>原码</p>
</li>
<li><p>反码</p>
</li>
<li><p>补码</p>
</li>
<li><p>移码</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://ebxeax.github.io/2023/08/09/PCC_002_data_expression_and_calculate/" data-id="cll50ezyz0019xpbi9sxo55qo" data-title="" class="article-share-link"><span class="fa fa-share">Teilen</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/interpreter-C/">interpreter C</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/09/%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/09/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/09/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%C2%B7%E9%A1%B5%E5%BC%8F%C2%B7%E6%AE%B5%E5%BC%8F%C2%B7%E6%AE%B5%E9%A1%B5%E5%BC%8F/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/09/YOLO_001_from-CNN-to-YOLOv1/">(no title)</a>
          </li>
        
          <li>
            <a href="/2023/08/09/PCC_007_%E7%AC%AC%E4%B8%83%E7%AB%A0-I%E2%81%84O/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 ebx<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>