<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>蓝翔技工(blueflylabor)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="blueflylabor">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝翔技工(blueflylabor)">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="蓝翔技工(blueflylabor)">
<meta property="og:description" content="blueflylabor">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝翔技工">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="蓝翔技工(blueflylabor)" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蓝翔技工(blueflylabor)</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机组成原理虚拟存储器页式段式和段页式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T04:01:51.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/">计算机组成原理虚拟存储器页式段式和段页式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>虚拟存储器·页式·段式·段页式</h1>
<p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>
用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>
实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>
<ul>
<li>实地址 = 主存页号 + 页内字地址</li>
<li>虚地址 = 虚存页号 + 页内字地址</li>
<li>辅存地址 = 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>
</ul>
<p>CPU使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>
<ul>
<li>在内存，通过地址变换，CPU可直接访问主存指示的数据单元</li>
<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>
</ul>
<h2 id="页式虚拟存储器">页式虚拟存储器</h2>
<p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong></p>
<h3 id="页表">页表</h3>
<p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>有效位</td>
<td>脏位</td>
<td>引用位</td>
<td>物理页</td>
</tr>
</tbody>
</table>
<ul>
<li>有效位（装入位）：表示对应页是否在主存</li>
<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>
<li>引用位（使用位）：配合替换算法进行设置</li>
</ul>
<p>CPU运行指令时，虚地址转实地址：</p>
<ul>
<li>页表基址寄存器存放进程的页表首地址</li>
<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>
<li>装入位为1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>
<li>装入位为0，说明缺页，需要操作系统进行缺页处理</li>
</ul>
<h3 id="快表-TLB">快表(TLB)</h3>
<p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>
快表通常采用组相联或全相联方式</p>
<table>
<thead>
<tr>
<th>t</th>
<th>r</th>
<th>p</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记</td>
<td>有效位</td>
<td>实页号</td>
</tr>
</tbody>
</table>
<h3 id="具有TLB和Cache的多级存储系统">具有TLB和Cache的多级存储系统</h3>
<p>三种缺失的情况</p>
<table>
<thead>
<tr>
<th></th>
<th>TLB</th>
<th>Page</th>
<th>Cache</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>命中</td>
<td>命中</td>
<td>命中</td>
<td>TLB命中则Page一定命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>2</td>
<td>命中</td>
<td>命中</td>
<td>缺失</td>
<td>TLB命中则Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>3</td>
<td>缺失</td>
<td>命中</td>
<td>命中</td>
<td>TLB缺失但Page可能命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>4</td>
<td>缺失</td>
<td>命中</td>
<td>缺失</td>
<td>TLB缺失但Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>5</td>
<td>缺失</td>
<td>缺失</td>
<td>缺失</td>
<td>TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache</td>
</tr>
</tbody>
</table>
<h2 id="段式虚拟存储器">段式虚拟存储器</h2>
<p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>段号</td>
<td>段首地址</td>
<td>装入位</td>
<td>段长</td>
</tr>
</tbody>
</table>
<p>CPU访存时：</p>
<ul>
<li>根据段号与段表基地址拼接成对应的段表行</li>
<li>根据段表行的装入位判断是否调入内存</li>
<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址</li>
</ul>
<h2 id="段页式虚拟存储器">段页式虚拟存储器</h2>
<p>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>
每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>段号</td>
<td>段内页号</td>
<td>页内地址</td>
</tr>
</tbody>
</table>
<p>CPU访存：</p>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成实地址</li>
</ul>
<h2 id="虚拟存储器与Cache的比较">虚拟存储器与Cache的比较</h2>
<table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody>
<tr>
<td>目的均为提供系统性能</td>
<td>Cache主要解决系统速度，虚拟存储器解决主存容量</td>
</tr>
<tr>
<td>均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大</td>
<td>Cache由硬件实现，对程序员透明，虚拟存储器由OS和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td>都有地址的映射、替换算法、更新策略</td>
<td></td>
</tr>
<tr>
<td>均依据程序的局部性原理</td>
<td></td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/" data-id="clyp3okze000d0vdqhwf021ix" data-title="计算机组成原理虚拟存储器页式段式和段页式" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理Cache和主存的映射替换算法和写策略" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E5%86%99%E7%AD%96%E7%95%A5/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T04:01:51.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E5%86%99%E7%AD%96%E7%95%A5/">计算机组成原理Cache和主存的映射替换算法和写策略</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>Cache和主存的映射·替换算法·写策略</h1>
<h2 id="映射">映射</h2>
<p>Cache行中的信息是主存某个块的副本<br>
地址映射：将主存地址空间映射到Cache地址空间，按某种规则将主存的信息装入Cache<br>
Cache的行数比主存块少的多，只有一部分主存块的信息可以装入Cache中，因此在Cache中需要为每块加一个<strong>标记</strong>，指明它是主存的哪一块的副本，此标记相当于主存块的编号。为了说明Cache行中的信息是否有效还需要一个<strong>有效位</strong>，地址映射以下3种：</p>
<ul>
<li>直接映射</li>
<li>全相联映射</li>
<li>组相联映射</li>
</ul>
<h3 id="直接映射">直接映射</h3>
<p>Cache 行号 = 主存块号 mod Cache 总行数<br>
假设 Cache : $2^c$行 主存 : $2^m$块<br>
$0,2^c,2^{c+1},\dots$块映射到第0行<br>
$1,2^c+1,2^{c+1}+1$块映射到第1行<br>
低c位为装入的Cache行号，给每行设置一个长为t=m-c的标记，当某个主存块调入Cache后，将主存块号的高t位设置为对应Cache行中的标记</p>
<table>
<thead>
<tr>
<th>t</th>
<th>c</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记</td>
<td>Cache行号</td>
<td>块内地址</td>
</tr>
</tbody>
</table>
<p>CPU访存过程：</p>
<ul>
<li>根据访存地址中间的c位找到对应Cache行</li>
<li>Cache行标记与主存地址高t位标记比较，确定是否有效</li>
<li>相等且有效位为1，访问Cache命中，根据主存地址低b位的块内地址，在对应Cache行中存取信息</li>
<li>不相等或有效位为0，不命中，CPU将主存读出该地址所在的一块信息送到相应的Cache行中，置有效位1，并将标记设置为地址高t位，同时将地址中的内容送CPU</li>
</ul>
<h3 id="全相联映射">全相联映射</h3>
<p>主存的每一块可以装入Cache中的任何位置，每行<strong>标记</strong>用于指出该行取自主存的哪一块，CPU访存时需要与所有Cache行的标记进行对比</p>
<table>
<thead>
<tr>
<th>t</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记</td>
<td>块内地址</td>
</tr>
</tbody>
</table>
<h3 id="组相联映射">组相联映射</h3>
<p>将Cache分为Q个大小相等的组，每个主存块可以装入固定组的任意一行，即组间采用直接映射，而组内采用全相联映射，Q=1变为全相联映射，Q=Cache行数变为直接映射<br>
假设r个Cache行，则称之为r路组相联映射<br>
Cache组号=主存块号 mod Cache组数(Q)</p>
<table>
<thead>
<tr>
<th>t</th>
<th>g</th>
<th>b</th>
</tr>
</thead>
<tbody>
<tr>
<td>标记</td>
<td>组号</td>
<td>块内地址</td>
</tr>
</tbody>
</table>
<p>CPU访存：</p>
<ul>
<li>根据访存地址中间的g位组号找到对应的Cache组</li>
<li>将对应的Cache组的每个行标记与主存的高t位标记进行比较</li>
<li>相等且有效位为1，命中，根据主存地址中的低b位块内地址，在对应的Cache行中存取信息</li>
<li>不相等或有效位为0，未命中，CPU从主存读出该地址所在的一块信息送到对应的Cache组的任意一个空行，有效位置1，设置标记，同时将地址中的内容送CPU</li>
</ul>
<h2 id="替换算法">替换算法</h2>
<p>在采用全相联映射或组相联映射方式时，主存向Cache传送一个新块，Cache或Cache组空间已满替换的策略</p>
<ul>
<li>RAND</li>
<li>FIFO</li>
<li>LRU</li>
</ul>
<h2 id="写策略">写策略</h2>
<p>因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就需选用写操作策略，使Cache内容和主存保持一致<br>
对于Cache写命中：</p>
<ul>
<li>全写法：当CPU对Cache写命中时，必须八数据同时写入Cache和内存。当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖。</li>
<li>回写法：当CPU对Cache写命中时，只把数据写入Cache，而不立即写入主存，只有当此块被换出时，才写入主存。每个Cache行设置一个修改位（脏位），若修改位为1，Cache行被修改过，替换时需要写回主存，若为0，则说明Cache行中的块未被命中，替换时无需写回</li>
</ul>
<p>对于Cache写不命中：</p>
<ul>
<li>写分配法：加载主存中的块到Cache中，然后更新这个Cache块</li>
<li>非写分配法：只写入主存，不进行调块</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E5%92%8C%E5%86%99%E7%AD%96%E7%95%A5/" data-id="clyp3okze000e0vdq1908epi9" data-title="计算机组成原理Cache和主存的映射替换算法和写策略" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理指令系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T04:01:51.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">计算机组成原理指令系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>指令系统</h1>
<h2 id="指令系统">指令系统</h2>
<p>是指令集体系结构ISA的核心<br>
ISA主要包括：</p>
<ul>
<li>指令格式</li>
<li>数据类型及格式</li>
<li>操作数的存放方式</li>
<li>程序可访问的寄存器个数、位数和编号</li>
<li>存储空间大小和编址方式</li>
<li>寻址方式</li>
<li>指令执行过程的控制方式等</li>
</ul>
<h3 id="指令的基本格式">指令的基本格式</h3>
<p>一条指令包括操作码和地址码字段</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>操作码</td>
<td>地址码</td>
</tr>
</tbody>
</table>
<p>操作码:</p>
<ul>
<li>指出指令应执行的操作</li>
<li>识别指令</li>
<li>了解指令功能</li>
<li>区分操作数地址内容的组成和使用方法</li>
</ul>
<p>地址码：</p>
<ul>
<li>给出被操作的信息的地址</li>
<li>参加运算的一个或多个操作数所在的地址</li>
<li>运算结果的保存地址</li>
<li>程序的转移地址</li>
<li>被调用的子程序的入口地址等</li>
</ul>
<p>指令长度是指一条指令中包含的二进制代码的位数<br>
指令字长取决于</p>
<ul>
<li>操作码的长度</li>
<li>操作数地址码的长度</li>
<li>操作数地址个数</li>
</ul>
<p>单字长指令：等于机器字长<br>
半字长指令：一半机器字长<br>
双字长指令：二倍机器字长<br>
定长指令字结构：一个指令系统所有指令的长度都是相等的</p>
<h4 id="零地址指令：无显示地址">零地址指令：无显示地址</h4>
<table>
<thead>
<tr>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
</tr>
</tbody>
</table>
<ul>
<li>不需要操作数的指令</li>
<li>零地址运算指令仅用于堆栈计算机，通常参与运算的两个操作数隐含的从栈顶和次栈顶弹出，送至运算器，运算结果再隐含的压入堆栈</li>
</ul>
<p>一地址指令：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
</tr>
</tbody>
</table>
<p>OP($A_1$) $\to$ $A_1$</p>
<ul>
<li>只有目的操作数，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址</li>
</ul>
<p>(ACC)OP($A_1$) $\to$ ACC</p>
<ul>
<li>隐含约定目的地址的双操作数指令，按指令地址$A_1$地址读取操作数，指令可隐含约定另一个操作数由ACC提供，运算结果也将存放在ACC中</li>
<li>若指令长度为32位，操作码占8位，1个地址码字段占24位，指令操作数直接寻址范围$2^{24}=16M$</li>
</ul>
<h4 id="二地址指令">二地址指令</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
</tr>
</tbody>
</table>
<p>($A_1$)OP($A_2$) $\to$ $A_1$</p>
<ul>
<li>常用的算术和逻辑运算指令，需要两个操作数，需要分别给出目的操作数和源操作数，其中目的操作数地址还用于存放本次运算结果</li>
<li>指令字长位32位，操作码占8位，两个地址码各占12位，则指令操作数的直接寻址范围$2^{12}=4K$</li>
</ul>
<h4 id="三地址指令">三地址指令</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$(结果)</td>
</tr>
</tbody>
</table>
<p>($A_1$)OP($A_2$) $\to$ $A_3$</p>
<ul>
<li>指令字长位32位，操作码占8位，3个地址码各占8位，直接寻址范围$2^8=256$，地址字段为主存地址，则完成一条三地址需要4次访存，取指令1次，取两个操作数2次，存放结果1次</li>
</ul>
<h4 id="四地址指令">四地址指令</h4>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>$A_4$</td>
</tr>
</tbody>
</table>
<p>($A_1$)OP($A_2$) $\to$ $A_3$ ，$A_4$ = 下一条执行指令的地址</p>
<ul>
<li>地址字长为32位，操作码占8位，4个地址码各占6位，直接寻址范围$2^6=64$</li>
</ul>
<h3 id="定长操作码指令格式">定长操作码指令格式</h3>
<p>在指令字的最高位部分分配固定的若干位（定长）表示操作码。<br>
n位操作码字段的指令系统最大能表示$2^{n}$条指令</p>
<h3 id="扩展操作码指令格式">扩展操作码指令格式</h3>
<ul>
<li>不允许短码是长码的前缀</li>
<li>各指令的操作码一定不能重复</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>0000</td>
<td>0001</td>
<td>0010</td>
<td>0011</td>
</tr>
<tr>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
</tr>
<tr>
<td>1000</td>
<td>1001</td>
<td>1010</td>
<td>1011</td>
</tr>
<tr>
<td>1100</td>
<td>1101</td>
<td>1110</td>
<td>1111</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>操作码情况</td>
<td>OP</td>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$A_3$</td>
<td>说明</td>
</tr>
<tr>
<td>15条三地址</td>
<td>0000-1110</td>
<td></td>
<td></td>
<td></td>
<td>余出16-15=1，1*2^4=16种</td>
</tr>
<tr>
<td>12条二地址</td>
<td>1111</td>
<td>0000-1011</td>
<td></td>
<td></td>
<td>余出16-12=4，4*2^4=64种</td>
</tr>
<tr>
<td>62条一地址</td>
<td>1111</td>
<td>(1100-1110)/1111</td>
<td>(0000-1111)/(0000-1101)</td>
<td></td>
<td>余出64-62=2，2*2^4=32种</td>
</tr>
<tr>
<td>32条零地址</td>
<td>1111</td>
<td>1111</td>
<td>1110-1111</td>
<td>0000-1111</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="指令的操作类型">指令的操作类型</h3>
<ul>
<li>数据传送</li>
<li>算术和逻辑运算</li>
<li>移位</li>
<li>转移</li>
<li>输入输出</li>
</ul>
<h2 id="指令寻址方式">指令寻址方式</h2>
<p>确定本条指令的数据地址以及下一条待执行指令的地址，分为：</p>
<ul>
<li>
<p>指令寻址：寻找下条要执行的指令<br>
（1）顺序寻址<br>
通过PC+(1)，自动形成下一条指令<br>
（2）跳跃寻址<br>
通过转移指令实现，下条指令的地址不由PC自动给出，而由本条指令给出下条指令地址的计算方式。是否可跳跃受到状态寄存器和操作数的控制，跳跃的结果是当前指令修改PC值，下一条指令仍通过PC给出</p>
</li>
<li>
<p>数据寻址：寻找本条指令的数据<br>
通常在指令字中设一个字段指明寻址方式</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>操作码</td>
<td>寻址特征</td>
<td>形式地址A</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h3 id="常见数据寻址方式">常见数据寻址方式</h3>
<h4 id="隐含寻址">隐含寻址</h4>
<p>不明显的给出操作数，在指令中隐含操作数地址</p>
<ul>
<li>优：有利于缩短指令字长</li>
<li>缺：需要增加存储操作数或隐含地址的硬件</li>
</ul>
<h4 id="立即（数）寻址">立即（数）寻址</h4>
<p>指令的地址字段指出的不是操作数地址，而是操作数本身，又称立即数，#表示立即寻址特征，使用补码表示</p>
<ul>
<li>优：指令在执行阶段不访问主存，指令执行时间最短</li>
<li>缺：A的位数限制立即数的范围</li>
</ul>
<h4 id="直接寻址">直接寻址</h4>
<p>指令中的形式地址A是操作数的真实地址EA，EA=A</p>
<ul>
<li>优：简单，访存1次，不需要专门计算操作数的地址</li>
<li>缺：A的位数决定了指令操作数的寻址范围，操作数的地址不易修改</li>
</ul>
<h4 id="间接寻址">间接寻址</h4>
<p>指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址的存储单元地址，EA=(A)，间接寻址可以迭代多次<br>
间接寻址，主存第一位表示是否为多次间址</p>
<ul>
<li>优：可扩大寻址范围（有效地址EA的位数大于形式地址A的位数），便于编制程序（用间址寻址可方便的完成子程序返回）</li>
<li>缺：访问速度慢</li>
</ul>
<h4 id="寄存器寻址">寄存器寻址</h4>
<p>指令字中直接给出操作数所在的寄存器编号EA= $R_i$，操作数在由$R_i$所指的寄存器内</p>
<ul>
<li>优：指令执行阶段不访存，只访问寄存器，寄存器对应地址码长度较小，使得指令字短且因不用访存，所以执行速度快，支持向量/矩阵运算</li>
<li>缺:寄存器昂贵，有限</li>
</ul>
<h4 id="寄存器间接寻址">寄存器间接寻址</h4>
<p>寄存器$R_i$中给出的不是一个操作数，而是操作数所在主存单元的地址EA=($R_i$)</p>
<ul>
<li>优：与一般间址寻址速度快</li>
<li>缺：需要访存</li>
</ul>
<h4 id="相对寻址">相对寻址</h4>
<p>PC的内容加上指令格式的形式地址A而形成操作数的有效地址EA=(PC)+A，A是相对于当前PC的值的位移量，可正可负，用补码表示，A的位数决定寻址范围</p>
<ul>
<li>操作数的地址是不固定的，随PC的值变化而变化，且与指令地址之间相差一个固定值，便于程序浮动，广泛用于转移指令</li>
<li>JMP A，CPU从存储器取出一字节，自动执行(PC)+1 $\to$ PC，若转移指令的地址为X，且占2B，取出该指令后，PC自增2，(PC)=X+2，执行完该指令，会自动跳转至X+2+A的地址继续执行</li>
</ul>
<h4 id="基址寻址">基址寻址</h4>
<p>将CPU的基址寄存器BR的内容加上指令格式的形式地址A形成操作数的有效地址EA=(BR)+A，基址寄存器可采用专用寄存器也可为通用寄存器</p>
<ul>
<li>
<p>基址寄存器面向操作系统，内容通过操作系统或管理程序确定，主要用于解决程序逻辑空间与存储器物理空间的无关性</p>
</li>
<li>
<p>执行过程中基址寄存器内容不变，形式地址可变（偏移量）</p>
</li>
<li>
<p>采用通用寄存器作为基址寄存器，用户可决定使用哪个寄存器，内容由操作系统确定</p>
</li>
<li>
<p>优：可扩大寻址范围（基址寄存器位数大于形式地址A的位数），用户不必考虑自己的程序存于主存哪个区域，有利于多道程序设计，可用于制成浮动程序</p>
</li>
<li>
<p>缺：偏移量位数较短</p>
</li>
</ul>
<h4 id="变址寻址">变址寻址</h4>
<p>有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容之和，EA=(IX)+A</p>
<ul>
<li>IX可使用专用寄存器或通用寄存器</li>
<li>变址寄存器面向用户，在程序执行过程，变址寄存器内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）</li>
<li>可扩大寻址范围（变址寄存器位数大于形式地址A的位数），适合编制循环程序，偏移量的位数（IX）足以表示整个存储空间</li>
</ul>
<h4 id="堆栈寻址">堆栈寻址</h4>
<p>堆栈是存储器（或专用寄存器组）中一块特定的、按照后进先出（LIFO）的原则管理的存储区，存储区读写单元地址是用一个特定寄存器给出的称为堆栈指针(SP)，分为硬堆栈（不适合做大容量堆栈）和软堆栈（主存划出一段区域）</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>有效地址</th>
<th>访存次数</th>
</tr>
</thead>
<tbody>
<tr>
<td>隐含寻址</td>
<td>程序指定</td>
<td>0</td>
</tr>
<tr>
<td>立即寻址</td>
<td>A是操作数</td>
<td>0</td>
</tr>
<tr>
<td>直接寻址</td>
<td>EA=A</td>
<td>1</td>
</tr>
<tr>
<td>一次间接寻址</td>
<td>EA=(A)</td>
<td>2</td>
</tr>
<tr>
<td>寄存器寻址</td>
<td>EA= $R_i$</td>
<td>0</td>
</tr>
<tr>
<td>寄存器间接一次寻址</td>
<td>EA = ($R_i$)</td>
<td>1</td>
</tr>
<tr>
<td>相对寻址</td>
<td>EA=(PC)+A</td>
<td>1</td>
</tr>
<tr>
<td>基址寻址</td>
<td>EA=(BR)+A</td>
<td>1</td>
</tr>
<tr>
<td>变址寻址</td>
<td>EA=(IX)+A</td>
<td>1</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" data-id="clyp3okzg000i0vdq6eond33u" data-title="计算机组成原理指令系统" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">数据结构基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>数据结构的基本概念</p>
<p>1.数据</p>
<p>2.数据元素：</p>
<p>数据的基本单位，一个数据元素可有若干个数据项构成，数据项是不可分割的最小单位</p>
<p>3.数据类型</p>
<p>4.抽象数据类型(ADT[Abstract Data Type]):</p>
<p>数学模型在计算机的一种实现，包括数据对象、数据关系、基本操作，如建立一个有限状态机模型</p>
<p>5.数据结构：数据元素之间的关系称之为结构，数据结构包括三方面：逻辑结构、存储结构、数据运算(程序=算法+数据结构)</p>
<p>6.逻辑结构：数据间的逻辑关系，与数据存储独立，分为线性结构和非线性结构</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">逻辑结构--线性结构</span><br><span class="line">逻辑结构--非线性结构</span><br><span class="line">线性结构--一般线性表</span><br><span class="line">线性结构--受限线性表</span><br><span class="line">线性结构--线性表推广</span><br><span class="line">受限线性表--栈和队列</span><br><span class="line">受限线性表--串</span><br><span class="line">线性表推广--数组</span><br><span class="line">线性表推广--广义表</span><br><span class="line">非线性结构--非线性表</span><br><span class="line">非线性表--集合</span><br><span class="line">非线性表--树形结构</span><br><span class="line">非线性表--图形结构</span><br><span class="line">树形结构--一般树</span><br><span class="line">树形结构--二叉树</span><br><span class="line">图形结构--有向图</span><br><span class="line">图形结构--无向图</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>7.物理结构：数据元素的表示以及关系的表示，主要有：顺序存储、链式存储、索引存储、散列存储</p>
<p>8.算法评估</p>
<p>（1）特性：有穷、确定、可行、输入、输出</p>
<p>（2）时间复杂度：衡量算法随问题规模的增大，算法执行的时间增长的快慢</p>
<p>T(n)=O(f(n))，f(n)为算法运算频度，一般采用最坏情况下的时间复杂度</p>
<p>计算方法：取算法时间增长最快的函数项，忽略其系数</p>
<p>a加法规则：</p>
<pre><code>$$
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
$$

多项式相加，只保留最高阶的项，且系数变为1
</code></pre>
<p>b乘法规则：</p>
<pre><code>$$
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
$$

多项式相乘，都保留
</code></pre>
<p>从左到右性能依次降低：</p>
<pre><code>$$
O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)
$$
</code></pre>
<p>单循环体型：</p>
<pre><code>例题1：计算下列程序的时间复杂度

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,sum	<span class="comment">//执行1次</span></span><br><span class="line">sum=<span class="number">0</span>	<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//int i=0执行1次，i&lt;=n执行n+2次，i++执行n+1次</span></span><br><span class="line">	sum+=i;	<span class="comment">//执行n+1次</span></span><br></pre></td></tr></table></figure>

时间分析： 该算法执行了3n+6个语句。 假设每个语句执行时间一致，均为常数t。则总时间 
$$
T=(3n+6)*t
$$
随着问题规模n的增大，总时间的增长率与n的增长率一致，所以复杂度为
$$
O(n)
$$


结论： 

 复杂度是关于增长率的，所以可以直接忽视常数项

  一般可以直接关注循环段基本操作语句

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=i;</span><br></pre></td></tr></table></figure>
 
  

 的执行次数
</code></pre>
<p>例题2：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum,i;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= n;i=<span class="number">2</span>*i)&#123;</span><br><span class="line">	sum=sum+i;</span><br></pre></td></tr></table></figure>
<p>时间分析：</p>
<p>i 取值：1,2,4,8…<br>
满足条件：2^𝑘 ≤ n<br>
K𝑙𝑜𝑔_2𝑛时， 跳出循环<br>
所以循环体执行次数：⌈𝑙𝑜𝑔_2𝑛⌉ 故时间复杂度为O(logn).i 取值：1,2,4,8</p>
<p>多循环体型</p>
<p>两个运算法则：乘法规则（嵌套循环）、加法规则（若干循环）</p>
<p>例题3：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	x++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		y++;</span><br></pre></td></tr></table></figure>
<p>两个循环体是独立的，采用加法规则：<br>
$$<br>
T(n)=T_1(n)+T_2(n)<br>
$$</p>
<p>$$<br>
=max(T_1(n),T_2(n)) =O(n^2)<br>
$$</p>
<p>例题4：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j,sum;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j=<span class="number">2</span>*j)</span><br><span class="line">		sum=sum+j;</span><br></pre></td></tr></table></figure>
<p>两个循环体是嵌套的，采用乘法规则：</p>
<p>$$<br>
T(n)=T_1(n)*T_2(n)<br>
$$</p>
<p>$$<br>
=O(nlogn)<br>
$$</p>
<p>（3）空间复杂度：衡量算法随问题规模的增大，算法所需空间的快慢</p>
<p>S(n)=O(g(n))，算法所需空间的增长率和g(n)的增长率相同</p>
<p>空间复杂度S(n)指算法运行过程中所使用的辅助空间的大小</p>
<p>线性表</p>
<p>1.定义：线性表是具有相同数据类型的n个数据类型的有限序列，n为表长</p>
<p>线性表中第一个元素称为表头元素，最后一个元素称为表位元素</p>
<p>除第一个元素外，每个元素仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继</p>
<p>顺序存储</p>
<p>线性表的顺序存储又称顺序表</p>
<p>使用一组地址连续的存储单元(数组等)依次存储线性表的数据元素，从而使得逻辑相邻的两个元素在物理位置上也相邻</p>
<p>三个属性：</p>
<p>1.存储空间的起始位置</p>
<p>2.顺序表最大存储容量</p>
<p>3.顺序表当前的长度</p>
<p>宏定义</p>
<p>静态分配大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Elemtype elem[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>动态分配大小(这里动态指空间大小运行时决定，但分配大小后，空间大小被固定)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Elemtype *elem;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
<p>优点：访问效率高、存储密度高</p>
<p>缺点：插入删除操作复杂</p>
<p>顺序存储线性表操作</p>
<p>1.初始化顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initLinklist</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	L.elem=<span class="keyword">new</span> Elemtype[MaxSize];</span><br><span class="line"><span class="keyword">if</span>(!L.elem)</span><br><span class="line">   <span class="built_in">exit</span>(OVERFLOWS);</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）创建一个顺序存储表后，需要初始化，首先根据数组大小通过new在堆空间开辟一段连续的空间赋值于先前创建的顺序存储表的elem空间</p>
<p>（2）检查elem是否存在，不存在溢出退出程序</p>
<p>（3）将length元素赋值为0，即设置顺序存储线性表长度为0</p>
<p>2.销毁顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.elem)</span><br><span class="line">   <span class="built_in">delete</span>(L.elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果线性表存在，删除线性表elem开辟的空间</p>
<p>3.清空顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将线性表的长度置为0</p>
<p>4.判断顺序存储线性表是否为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断线性表长度是否为0，并返回相应bool值</p>
<p>5.引用类型按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i,type&amp;e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> e=L.elem[i<span class="number">-1</span>];</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）先检查传递参数下标量是否正确</p>
<p>（2）通过访问elem内数据存入引用类型变量内</p>
<p>6.按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> <span class="keyword">return</span> L.elem[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）先检查传递参数下标量是否正确</p>
<p>（2）通过访问elem内数据并返回</p>
<p>7.引用类型按值查询顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e,<span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量赋值于引用类型下标变量</p>
<p>8.按值获取顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量返回</p>
<p>9.按下标插入元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listInsert</span><span class="params">(SqList &amp;L,type e,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> ++L.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j=i<span class="number">-1</span>;j--)</span><br><span class="line">     L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line"> L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）先检查传递参数下标量是否正确</p>
<p>（2）增加线性表长度</p>
<p>（3）按照目标元素位置，将其尾部元素后移1偏移量</p>
<p>（4）将目标元素存入下标位置</p>
<p><strong>时间复杂度分析:</strong></p>
<p>（1）<br>
$$<br>
最好情况：在表尾插入(即i=n+1)<br>
$$</p>
<p>$$<br>
元素后移语句执行的时间复杂度为O(1)<br>
$$</p>
<p>（2）<br>
$$<br>
最坏情况：在表头插入(即i=1)<br>
$$</p>
<p>$$<br>
元素后移语句执行n次，时间复杂度为O(n)<br>
$$</p>
<p>（3）<br>
$$<br>
平均情况：假设p_i(p_i=1/(n+1))<br>
$$</p>
<p>$$<br>
是第i个位置上插入一个结点的概率<br>
$$</p>
<p>$$<br>
则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>
$$</p>
<p>$$<br>
\begin{equation*}</p>
<p>f = \sum_{i=1}^{n+1}p_i(n-i-1)</p>
<p>\end{equation*}<br>
$$</p>
<p>$$<br>
\begin{equation*}</p>
<p>=\sum_{i=1}^{n+1}{\frac{n+1}{n-i+1}}</p>
<p>\end{equation*}<br>
$$</p>
<p>$$<br>
\begin{equation*}</p>
<p>=\frac{1}{n+1} \sum_{i=1}^{n+1}(n-i-1)</p>
<p>\end{equation*}<br>
$$</p>
<p>$$<br>
=\frac{1}{n+1}\frac{n(n+2)}{2}=\frac{n}{2}<br>
$$</p>
<p>$$<br>
因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>
$$</p>
<p>10.按下标删除元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i  L.length))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; i &lt;= L.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">		--L.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）先检查传递参数下标量是否正确</p>
<p>（2）按照目标元素位置，将其头部元素前移1偏移量</p>
<p>（3）减少线性表长度</p>
<p><strong>时间复杂度分析:</strong></p>
<p>（1）<br>
$$<br>
最好情况：在表尾插入(即i=n)<br>
$$</p>
<p>$$<br>
无需移动元素，时间复杂度为O(1)<br>
$$</p>
<p>（2）<br>
$$<br>
最坏情况：在表头插入(即i=1)<br>
$$</p>
<p>$$<br>
需移动除第一个元素外的所有元素，时间复杂度为O(n)<br>
$$</p>
<p>（3）<br>
$$<br>
平均情况：假设p_i(p_i=1/(n+1))<br>
$$</p>
<p>$$<br>
是第i个位置上插入一个结点的概率<br>
$$</p>
<p>$$<br>
则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>
$$</p>
<p>$$<br>
\begin{equation*}</p>
<p>f = \sum_{i=1}^{n}p_i(n-i)</p>
<p>\end{equation*}<br>
$$</p>
<p>$$<br>
\begin{equation*}</p>
<p>=\sum_{i=1}^{n}{\frac{n}{n-i}}</p>
<p>\end{equation*}<br>
$$</p>
<p>$$<br>
\begin{equation*}</p>
<p>=\frac{1}{n} \sum_{i=1}^{n}(n-i)</p>
<p>\end{equation*}<br>
$$</p>
<p>$$<br>
=\frac{1}{n}\frac{n(n-1)}{2}=\frac{n-1}{2}<br>
$$</p>
<p>$$<br>
因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>
$$</p>
<p>11.创建顺序存储线性表</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	type e;</span><br><span class="line">	L.length = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please in put an element:&quot;</span>;</span><br><span class="line">		cin  e;</span><br><span class="line">		L.elem[i] = e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>11.打印顺序存储线性表内元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nList&#x27;s element：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;elem[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] =&quot;</span> &lt;&lt; L.elem[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="clyp3okz500030vdqgwbo3hm2" data-title="数据结构基本概念" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构查找算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">数据结构查找算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>查找</h1>
<h2 id="1-顺序查找">1.顺序查找</h2>
<h3 id="一般表">一般表</h3>
<p>（1）代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> tableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchSeq</span><span class="params">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[e] = key;   <span class="comment">//设置哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;ST.tableLen; i++)</span><br><span class="line">        <span class="keyword">return</span> i;   <span class="comment">//存在返回, 不存在返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）设置哨兵：可以不必判断是否越界，注意数据下表从1开始<br>
（3）ASL<br>
$$<br>
如果不能知道查找概率，可先对记录的查找概率进行排序，是表中的记录按查找概率从小到大\<br>
ASL_{success} = \sum_{i=1}^{n} P_i(n-i+1) = \frac{n+1}{2}\<br>
ASL_{unsuccess} = n+1\<br>
$$<br>
（4）优缺点<br>
优点：对数据的存储无要求，顺序存储或者链式存储皆可<br>
缺点：当n较大，平均查找长度较大，效率低</p>
<h3 id="有序表">有序表</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1((10))--id2((20))</span><br><span class="line">id1((10)).--infinity,10</span><br><span class="line">id2((20))--id3((30))</span><br><span class="line">id2((20)).--infinity,20</span><br><span class="line">id3((30))--id4((40))</span><br><span class="line">id3((30)).--infinity,30</span><br><span class="line">id4((40))--id5((50))</span><br><span class="line">id4((40)).--infinity,40</span><br><span class="line">id5((50))--id6((60))</span><br><span class="line">id5((50)).--infinity,50</span><br><span class="line">id6((60))--60,=</span><br><span class="line">id6((60)).--infinity,60</span><br></pre></td></tr></table></figure>
<p>（1）一旦查到某个元素大于该元素便停止查找<br>
（2）方框是虚构的节点，查找长度=方框上的圆环<br>
（3)ASL<br>
$$<br>
ASL_{success} = \sum_{i=1}^{n} P_i(n-i+1) = \frac{n+1}{2}\<br>
ASL_{unsuccess} = \sum_{j=1}^{n} Q_j(l_j-1) =  \frac{1+2+…+n+n}{n+1} = \frac{n}{2} +  \frac{n}{n+1}\<br>
$$</p>
<h3 id="折半查找（二分查找）">折半查找（二分查找）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id29((29))--id37((37))--id41((41))--id43((43))</span><br><span class="line">id43((43))--43,+infinity</span><br><span class="line">id43((43))--37,43</span><br><span class="line">id37((37))--id32((32))--id33((33))</span><br><span class="line">id32((32))--29,32</span><br><span class="line">id33((33))--33,37</span><br><span class="line">id33((33))--32,33</span><br><span class="line">id13((13))--id16((16))--id19((19))--19,29</span><br><span class="line">id19((19))--16,19</span><br><span class="line">id29((29))--id13((13))--id7((7))--id10((10))--10,13</span><br><span class="line">id10((10))--7,10</span><br><span class="line">id7((7))---infinity,7</span><br></pre></td></tr></table></figure>
<p>（1）仅适用于顺序表<br>
（2）代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid = <span class="number">0</span>, L.tableLen, <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]  key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）ASL<br>
$$<br>
ASL = \frac{1}{n}\sum_{i=1}^{n} l_i = \frac{1}{n}(1<em>1+2</em>2+…+h*2^{h-1}) = \frac{n+1}{n} log_2(n+1)-1 = log_2(n+1)-1\<br>
h=[log_2(n+1)]（向上取整）<br>
$$</p>
<h4 id="查找11">查找11</h4>
<h5 id="low-7-high-43-mid-29">low=7, high=43, mid=29</h5>
<h5 id="11-29">11&lt;29</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29--mid</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43--high</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-7-high-mid-1-19-mid-13">low=7, high=mid-1=19, mid=13</h5>
<h5 id="11-13">11&lt;13</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13--mid</span><br><span class="line">16</span><br><span class="line">19--high</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-7-high-mid-1-7-mid-10">low=7, high=mid-1=7, mid=10</h5>
<h5 id="117">117</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low--mid</span><br><span class="line">10--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-mid-1-10-high-10-mid-10">low=mid+1=10, high=10, mid=10</h5>
<h5 id="1010-×">1010 ×</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7</span><br><span class="line">10--low--mid--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="没找到，停在low">没找到，停在low</h5>
<h3 id="分块查找">分块查找</h3>
<p>（1）将查找表分为若干子块，块内可以无序，但块之间有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">id24((24))--id((索引块24,54,78,88))</span><br><span class="line">id21((21))</span><br><span class="line">id6((6))</span><br><span class="line">id11((11))</span><br><span class="line">id8((8))</span><br><span class="line">id22((22))</span><br><span class="line">id32((32))--id((索引块24,54,78,88))</span><br><span class="line">id31((31))</span><br><span class="line">id54((54))</span><br><span class="line">id72((72))--id((索引块24,54,78,88))</span><br><span class="line">id61((61))</span><br><span class="line">id78((78))</span><br><span class="line">id88((88))--id((索引块24,54,78,88))</span><br><span class="line">id83((83))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）ASL<br>
$$<br>
n:长度\<br>
b:分块个数\<br>
s:每块s个记录\<br>
P:等概率\<br>
ASL = L_I+L_S = \frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}\<br>
s=\sqrt{n},ASL=\sqrt{n}+1\<br>
采用折半查找：ASL=L_I+L_S=[log_2(b+1)]+\frac{s+1}{2}（向上取整）<br>
$$</p>
<p>###B树（多路平衡查找树）<br>
$$<br>
m阶B树或空树\<br>
每棵子树至多m棵子树，最多包含m-1个关键字\<br>
若根节点不是终端节点，至少两棵子树\<br>
除根结点外所有非叶节点至少[\frac{m}{2}]（向上取整）棵子树（关键字）\<br>
$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">id[22]--id0[5,11]</span><br><span class="line">id[22]--id1[36,45]</span><br><span class="line">id0[5,11]--id00[1,3]</span><br><span class="line">id0[5,11]--id01[6,8,9]</span><br><span class="line">id0[5,11]--id02[13,15]</span><br><span class="line">id1[36,45]--id10[30,35]</span><br><span class="line">id1[36,45]--id11[40,42]</span><br><span class="line">id1[36,45]--id12[47,48,50,56]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" data-id="clyp3okz600040vdqhi314l1y" data-title="数据结构查找算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构栈和队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">数据结构栈和队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>栈</h1>
<ul>
<li>栈(Stack)：只允许在一端插入或删除的线性表</li>
<li>栈顶：线性表允许进行插入或删除的那一端</li>
<li>栈底：固定的，不允许进行插入和删除的另一端</li>
<li>特点：是受限的线性表，拥有线性关系；后进先出<strong>LIFO</strong></li>
</ul>
<h1>顺序栈</h1>
<ul>
<li>使用顺序存储，自底向上存储数据元素，指针指向栈顶元素的位置</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.top = <span class="number">-1</span>;             <span class="comment">//判空</span></span><br><span class="line">s.data[++s.top] = x;    <span class="comment">//进栈</span></span><br><span class="line">x = s.data[s.top--];    <span class="comment">//出栈</span></span><br><span class="line">x = s.data[s.top];      <span class="comment">//读取栈顶元素</span></span><br></pre></td></tr></table></figure>
<h1>共享栈</h1>
<ul>
<li>两个栈共享一个一维数组空间</li>
<li>两个栈分别设置在共享空间两端</li>
<li>栈顶指向中间延伸位置</li>
<li>有利于空间使用</li>
</ul>
<h1>链式栈</h1>
<ul>
<li>采用链式存储</li>
<li>便于多个栈共享存储空间</li>
<li>效率高</li>
</ul>
<h1>队列</h1>
<ul>
<li>允许在一端插入，另一端删除的线性表</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>先进先出<strong>FIFO</strong></li>
</ul>
<h1>顺序队列</h1>
<ul>
<li>连续的存储单元</li>
<li>头指针指向队头元素</li>
<li>尾指针指向队尾元素</li>
</ul>
<h1>循环队列</h1>
<ul>
<li>首尾相连的顺序存储的队列</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q.rear = Q.front = <span class="number">0</span>;                           <span class="comment">// 初始化</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % MaxSize;                    <span class="comment">// 入队</span></span><br><span class="line">front = (front + <span class="number">1</span>) % MaxSize;                  <span class="comment">// 出队</span></span><br><span class="line">queueLen = (rear + MaxSize - front) % MaxSize;  <span class="comment">// 队列长度</span></span><br></pre></td></tr></table></figure>
<ul>
<li>判断空队列或满队列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个单元区分队空或队满</span></span><br><span class="line">(Q.rear + <span class="number">1</span>) % MaxSize = Q.front;   <span class="comment">//</span></span><br><span class="line">Q.front = Q.rear;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 类型中增加表示个数的数据成员</span></span><br><span class="line">Q.size = <span class="number">0</span>;                         <span class="comment">//</span></span><br><span class="line">Q.size = MaxSize;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 增加tag成员</span></span><br><span class="line">tag = <span class="number">0</span>;                            <span class="comment">//</span></span><br><span class="line">tag = <span class="number">1</span>;                            <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h1>链式队列</h1>
<h1>双端队列</h1>
<ul>
<li>允许两端可以入队和出队</li>
<li>输出受限的双端队列：允许一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h1>应用</h1>
<h2 id="栈在括号匹配的应用">栈在括号匹配的应用</h2>
<h3 id="算法思想">算法思想</h3>
<ul>
<li>空栈，一次读入一个符号</li>
<li>右括号：使栈顶元素消解，或不合法（序列不匹配，退出程序）</li>
<li>左括号：放入栈顶，作为更高优先级的一个元素，栈为空，否则括号序列不匹配</li>
</ul>
<h3 id="栈在表达式中的应用">栈在表达式中的应用</h3>
<ul>
<li>中缀表达式转换后缀表达式</li>
</ul>
<h3 id="栈在递归中的应用">栈在递归中的应用</h3>
<ul>
<li>原理：将原始问题转换为相同属性的小规模问题</li>
<li>求出递归表达式</li>
<li>边界条件（递归出口）</li>
</ul>
<h2 id="队列">队列</h2>
<h3 id="队列在层次遍历的应用">队列在层次遍历的应用</h3>
<h3 id="队列在计算机系统中的应用">队列在计算机系统中的应用</h3>
<ul>
<li>解决主机与外设之间速度不匹配的问题</li>
<li>解决多用户引起的资源竞争问题</li>
</ul>
<h1>特殊矩阵压缩存储</h1>
<h2 id="数组的存储结构">数组的存储结构</h2>
<ul>
<li>行优先：先存储行号较小的元素，行号相等先存储列号小的元素</li>
<li>列优先：先存储列好较小的元素，列号相等先存储行号小的元素</li>
</ul>
<h2 id="n阶对称矩阵">n阶对称矩阵</h2>
<ul>
<li>上三角、主对角线、下三角，其中上下三角元素相同</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k$</li>
<li>元素下标之间的对于关系<br>
$i \ge j , k = \frac{i*(i-1)}{2+j}-1(下三角区和主对角线元素)$<br>
$i &lt; j , k = \frac{j*(j-1)}{2+i}-1(上三角区元素)$</li>
</ul>
<h2 id="n阶三角矩阵">n阶三角矩阵</h2>
<ul>
<li>下三角矩阵（上三角区元素为常量）和上三角矩阵（下三角矩阵元素为常量）</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k</li>
<li>下三角矩阵的的元素下表之间的对应关系</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" data-id="clyp3okz700050vdq201mduoh" data-title="数据结构栈和队列" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构简述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/">数据结构简述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>数据结构绪论</h1>
<h2 id="一、数据结构：相互存在一种或多种特定关系的集合">一、数据结构：相互存在一种或多种特定关系的集合</h2>
<ul>
<li>结构：任何问题，数据元素不孤立存在，之间存在关系</li>
<li>逻辑结构</li>
<li>存储结构（物理结构）</li>
<li>数据的运算</li>
<li>逻辑结构和存储结构密不可分</li>
<li>算法设计取决于逻辑结构，实现依赖存储结构</li>
</ul>
<h2 id="二、逻辑结构：数据元素之间的逻辑关系">二、逻辑结构：数据元素之间的逻辑关系</h2>
<ul>
<li>与存储无关，独立于计算机</li>
<li>分为线性结构和非线性结构<br>
线性结构：线性表、栈、队列、串、数组、广义表<br>
非线性结构：树、二叉树、有向图、无向图</li>
</ul>
<h2 id="三、存储结构（物理结构）：数据结构在计算机中的映像">三、存储结构（物理结构）：数据结构在计算机中的映像</h2>
<ul>
<li>数据结构的表示</li>
<li>关系的表示</li>
<li>依赖于计算机语言</li>
<li>分为顺序存储、链式存储、索引存储、散列存储</li>
</ul>
<h3 id="1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻">1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻</h3>
<ul>
<li>优：实现随机存取、每个元素占用的内存少</li>
<li>缺：只能使用相邻的一块存储单元，产生较多的外部碎片</li>
</ul>
<h3 id="2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素">2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素</h3>
<ul>
<li>优：无碎片产生、充分利用存储单元</li>
<li>缺：只能顺序存储</li>
</ul>
<h3 id="3-索引存储：类似目录">3. 索引存储：类似目录</h3>
<h3 id="4-散列存储：通过关键字直接计算出元素的物理地址">4. 散列存储：通过关键字直接计算出元素的物理地址</h3>
<h2 id="四、数据运算">四、数据运算</h2>
<h2 id="五、算法的五个特征">五、算法的五个特征</h2>
<ul>
<li>有穷性：执行有限步后结束</li>
<li>确定性：每条指令都有确定的含义，相同输入得到相同的输出</li>
<li>可行性：通过实现的基本运算执行有限次得到确定的结果</li>
<li>输入：有零或多个输入</li>
<li>输出：一个或多个程序输出结果</li>
</ul>
<h2 id="六、算法的复杂度">六、算法的复杂度</h2>
<h3 id="1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢">1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢</h3>
<h3 id="2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢">2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢</h3>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/" data-id="clyp3okz800060vdqemqi7m01" data-title="数据结构简述" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构线性表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构线性表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>线性表</h1>
<h2 id="一、逻辑结构和基本操作">一、逻辑结构和基本操作</h2>
<h3 id="1-逻辑结构">1. 逻辑结构</h3>
<ul>
<li>具有相同数据类型的n个数据元素的有限序列，表长n，n=0为空表</li>
<li>表头：第一个元素</li>
<li>表尾：最后一个元素</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>
<li>除最后一个元素外，每个元素有且仅有一个直接后继</li>
</ul>
<h3 id="2-基本操作">2. 基本操作</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initList</span>(&amp;L);</span><br><span class="line"><span class="built_in">len</span>(L);</span><br><span class="line"><span class="built_in">locateElem</span>(L, i);</span><br><span class="line"><span class="built_in">getElem</span>(L, i);</span><br><span class="line"><span class="built_in">listInsert</span>(&amp;L, i, e);</span><br><span class="line"><span class="built_in">listDelete</span>(&amp;L, i, &amp;e);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"><span class="built_in">isEmptyList</span>(L);</span><br><span class="line"><span class="built_in">destroyList</span>(&amp;L);</span><br></pre></td></tr></table></figure>
<h2 id="二、顺序存储结构">二、顺序存储结构</h2>
<h3 id="1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻">1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻</h3>
<ul>
<li>存储空间的起始位置data[ ]</li>
<li>顺序表最大存储容量MaxSize</li>
<li>顺序表当前最大长度len<br>
特点</li>
<li>随机访存，O(1)时间复杂度访问</li>
<li>存储密度高，每个结点只存储数据元素</li>
<li>无需花费空间建立数据之间的逻辑关系，由物理位置相邻特性决定</li>
<li>逻辑上物理上均相邻，插入删除操作需要移动大量元素</li>
</ul>
<h3 id="2-基本操作-2">2. 基本操作</h3>
<p>（1）插入元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.len = MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = L.len; j  i; j--)</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">	L.len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>最好情况：在表尾插入 <strong>(i=n+1)</strong>，不需要移动元素，时间复杂度为O(1)</li>
<li>最坏情况：在表头插入 <strong>(i=1)</strong>，元素后移n次，时间复杂度O(n)</li>
<li>平均情况：假设$P_i$ <strong>($P_i = \frac{1}{n+1}$)</strong>，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n}{2}$，其时间复杂度为O(n)<br>
（2）删除元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	e = L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.len; j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">	L.len--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>最好情况：在表尾插入 <strong>(i=n)</strong>，不需要移动元素，时间复杂度为O(1)</li>
<li>最坏情况：在表头插入 <strong>(i=1)</strong>，元素后移n次，时间复杂度O(n)</li>
<li>平均情况：假设$P_i$ <strong>($P_i = \frac{1}{n+1}$)</strong>，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n-1}{2}$，其时间复杂度为O(n)<br>
（3）查找元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList &amp;L, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.len; i++)</span><br><span class="line">		<span class="keyword">if</span>(e == L.data[i])</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>最好情况：查找的元素在表头，仅需比较1次，时间复杂度O(1)</li>
<li>最坏情况：查找的元素在表尾或不存在，需要比较n次，时间复杂度O(n)</li>
<li>平均情况：假设$P_i$ **($P_i = \frac{1}{n}$)**是在第i个位置上结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n+1}{2}$，其时间复杂度为O(n)</li>
</ul>
<h1>链式存储结构</h1>
<h2 id="1-创建单链表">1.创建单链表</h2>
<h3 id="（1）头插法">（1）头插法</h3>
<ul>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表头(头结点位置)</li>
<li>链表结点的次序与输入的顺序相反</li>
</ul>
<h3 id="（2）尾插法">（2）尾插法</h3>
<ul>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表尾(尾结点位置)</li>
<li>链表中的结点顺序与输入顺序一致</li>
</ul>
<h2 id="2-按值查找结点">2.按值查找结点</h2>
<ul>
<li>在链表中从第一个结点出发，顺指针next逐个向下搜索，直到找到第i个结点，否则返回最后一个结点的指针域NULL</li>
</ul>
<h2 id="3-按序号查找结点">3.按序号查找结点</h2>
<ul>
<li>从链表第一个结点开始，由前往后按照序号递增定位到相应结点的位置，返回该值，需检查序号是否越界</li>
</ul>
<h2 id="4-插入">4.插入</h2>
<ul>
<li>插入操作是将值为x的新结点插入到单链表的第i个位置</li>
<li>先检查插入位置是否合法</li>
<li>找到待插入位置的前驱结点</li>
<li>在其后将结点插入</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">s-next = p-next;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></table></figure>
<h2 id="5-删除">5.删除</h2>
<ul>
<li>将单链表的第i个结点删除</li>
<li>先检查插入位置是否合法</li>
<li>找到待删除位置的前驱结点</li>
<li>删除其后结点</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">q = p-next;</span><br><span class="line">q-next = p-next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<h1>双链表</h1>
<ul>
<li>双链表有两个指针prior和next，分别指向前驱和后继结点</li>
<li>插入操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-next = p-next;</span><br><span class="line">p-next-prior = s;</span><br><span class="line">s-prior = p;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-next = q-next;</span><br><span class="line">q-next-prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure>
<h1>循环链表</h1>
<ul>
<li>循环双链表和循环单链表</li>
<li>静态链表使用数组来描述线性表的链式存储结构</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/" data-id="clyp3okz900070vdqawrtchu2" data-title="数据结构线性表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-高等数学不定积分与定积分与反常积分" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/" class="article-date">
  <time class="dt-published" datetime="2018-09-06T04:01:51.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/">高等数学不定积分与定积分与反常积分</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1>不定积分、定积分与反常积分</h1>
<h2 id="不定积分">不定积分</h2>
<h3 id="一、不定积分概念">一、不定积分概念</h3>
<h4 id="1-定义">1.定义</h4>
<p>$$<br>
\begin{align}<br>
&amp;原函数：设对于区间I上的任意一点x均有F’(x)=f(x),则称F(x)为f(x)在区间I上的一个原函数\<br>
&amp;不定积分：设函数f(x)于区间I上有原函数,则其余原函数的全体称为f(x)于区间I上的不定积分,记为\int{f(x)dx}\<br>
&amp;线性：\int[\alpha f(x)+\beta g(x)]dx=\alpha\int f(x)dx+\beta\int g(x)dx\<br>
\end{align}<br>
$$</p>
<h4 id="2-计算">2.计算</h4>
<p>$$<br>
\begin{align}<br>
&amp;计算方法\begin{cases}&amp;1.基本公式\&amp;2.线性\&amp;3.积分法\begin{cases}&amp;1.换元法\&amp;2.分部积分法\\end{cases}\\end{cases}\<br>
\end{align}<br>
$$</p>
<h5 id="1-第一换元法-凑微分">(1)第一换元法(凑微分)</h5>
<p>$$<br>
\begin{align}<br>
&amp;设F’(u)=f(u),则\int{f(\Phi(x))\Phi’(x)}dx=\int{f(\Phi(x))d(\Phi(x))}=F(\Phi(x))+C\<br>
&amp;注解：找到合适的凑微分\Phi’(x)dx=d(\Phi(x))<br>
\end{align}<br>
$$</p>
<p>常见凑微分：<br>
$$<br>
\begin{align}<br>
&amp;1.\int{f(ax+b)dx=\frac{1}{a}\int{f(ax+b)d(ax+b)}}(a\neq0)\<br>
&amp;eg1.\int{\sin (2x+3)}dx=\frac{1}{2}\int\sin (2x+3)d(2x+3)=\frac{1}{2}\cos{(2x+3)}+C\<br>
&amp;2.\int{f(ax^n+b)x^{n-1}dx}=\frac{1}{na}\int{f(ax^n+b)d(ax^n+b)}\<br>
&amp;eg2.\int{\cos(2x^4+3)x^3dx}=\frac{1}{4*2}\int{\cos(2x^4+3)d(2x^4+3)}=\frac{1}{8}\cos{(2x^4+3)}+C\<br>
&amp;3.\int{f(a^x+c)a^xdx}=\frac{1}{\ln{a}}\int{f(a^x+c)}d(a^x+c)\<br>
&amp;eg3.\int{\sin(2^x+3)2^xdx}=\frac{1}{\ln2}\int{\sin{(2^x+3)}d(2^x+3)}=\frac{1}{\ln 2}\cos{(2^x+3)}\<br>
&amp;4.\int{f(\frac{1}{x})\frac{1}{x^2}}dx=-\int{f(\frac{1}{x})}d(\frac{1}{x})\<br>
&amp;eg4.\int{\ln(\frac{1}{x})}\frac{1}{x^2}dx=-\int\ln (\frac{1}{x})d({\frac{1}{x}})+C\<br>
&amp;5.\int{f(\ln |x|})\frac{1}{x}d(x)=\int{f(\ln{|x|)}}{d(\ln|x|)}\<br>
&amp;eg5.\int{\sin ({\ln{|x|}}})\frac{1}{x}dx=\int{\sin(\ln(|x|)d(\ln{|x|})}=\cos(\ln x)+C\<br>
&amp;6.\int{f(\sqrt x)\frac{1}{\sqrt x}}dx=2\int{f(\sqrt x)}d(\sqrt x)\<br>
&amp;7.\int f(\sin x)\cos xdx=-\int{(\sin x)}d(\sin x)\<br>
&amp;8.\int{f(\cos x)\sin dx}=\int{f(\cos x)d(\cos x)}\<br>
&amp;9.\int{f(\tan x)\sec^2 xdx}=\int{f(\tan x)d(\tan x)}\<br>
&amp;10.\int{f(\cot x)\csc^2xdx}=-\int{f(\cot x)d{(\cot x)}}\<br>
&amp;11.\int{f{(\arcsin x)\frac{1}{\sqrt{1-x^2}}}}dx=\int{f(\arcsin x)d({\arcsin x})}\<br>
&amp;12.\int{f(\arccos x)(-\frac{1}{\sqrt{1-x^2}}})dx=\int{f(\arccos x)d(\arccos x)}\<br>
&amp;13.\int{f(\arctan x)\frac{1}{1+x^2}dx}=\int{f(\arctan x)d(\arctan x)}\<br>
&amp;14.\int{f(\sqrt{x^2+a})}\frac{x}{\sqrt{x^2+a}}dx=\int{f(\sqrt{x^2+a})}d(\sqrt{x^2+a})\<br>
&amp;注解：(\sqrt{x^2\pm a})‘=\frac{x}{\sqrt{x^2+a}},(\sqrt{a^2-x^2})’=\frac{-x}{\sqrt{a^2-x^2}}\<br>
\end{align}<br>
$$</p>
<h5 id="2-第二换元法">(2)第二换元法</h5>
<p>$$<br>
\begin{align}<br>
&amp;设F’(u)=f(\Phi(u))\Phi’(u),则\<br>
&amp;\int{f(x)dx}\overset{x=\Phi(u)}{=}\int{f(\Phi(u))\Phi’(u)du}=F(u)+C=F(\Phi^{-1}(x))+C\<br>
&amp;注解：找到合适的x=\Phi(u)\<br>
\end{align}<br>
$$</p>
<p>1)三角换元<br>
$$<br>
\begin{align}<br>
&amp;x=a\sin u,x=a\tan u,x=a \sec u\<br>
&amp;\sqrt{a^2-x^2}\overset{x=a\sin u}{=}a\cos u,u\in[-\frac{\pi}{2},\frac{\pi}{2}],x\in[-a,a]\<br>
&amp;\sqrt{a^2+x^2}\overset{x=a\tan u}{=}a\sec u,u\in{(-\frac{\pi}{2},\frac{\pi}{2})},x\in{(-\infty,\infty)}\<br>
&amp;\sqrt{x^2-a^2}\overset{x=a\sec u}{=}a\tan u,u\in(\frac{\pi}{2},\pi]\cup(0,\frac{\pi}{2}]\<br>
\end{align}<br>
$$<br>
2)倒变换<br>
$$<br>
\begin{align}<br>
&amp;x=\frac{1}{u}常用于含\frac{1}{x}的函数\<br>
\end{align}<br>
$$<br>
3）指数(或对数)变换<br>
$$<br>
\begin{align}<br>
&amp;a^x=u或x=\frac{\ln u}{\ln a}常用于含a^x的函数\<br>
\end{align}<br>
$$<br>
4）用于有理化的变换<br>
$$<br>
\begin{align}<br>
&amp;\frac{1}{\sqrt{x}+\sqrt[3]{x}}用x=u^6\<br>
&amp;\sqrt[n]{\frac{ax+b}{cx+d}}用u=\sqrt[n]{\frac{ax+b}{cx+d}}或x=-\frac{du^n-b}{cu^n-a}\<br>
\end{align}<br>
$$</p>
<h5 id="3-分部积分法">(3)分部积分法</h5>
<p>$$<br>
\begin{align}<br>
&amp;\int{u(x)v’(x)dx}=\int{u(x)d(v(x))}=u(x)v(x)-\int{v(x)u’(x)dx}\<br>
&amp;注解：找到合适的u(x),v(x)\<br>
\end{align}<br>
$$</p>
<p>1)降幂法<br>
$$<br>
\begin{align}<br>
&amp;\int{x^ne^{ax}dx},\int{x^n\sin axdx},\int{x^n\cos ax dx}\<br>
&amp;取u(x)=x^n\<br>
\end{align}<br>
$$<br>
2)升幂法<br>
$$<br>
\begin{align}<br>
&amp;\int{x^a\ln xdx},\int{x^a\arcsin xdx},\int{x^a\arccos x dx},\int{x^a\arctan x dx}\<br>
&amp;取u(x)=\ln x\<br>
\end{align}<br>
$$<br>
3)循环法<br>
$$<br>
\begin{align}<br>
&amp;\int{e^{ax}\sin ax dx},\int{e^{ax}\cos {ax} dx}\<br>
&amp;取u(x)=e^{ax}或\sin{ax}<br>
\end{align}<br>
$$<br>
4)递推公式法<br>
$$<br>
\begin{align}<br>
&amp;与n有关的结果I_n，建立递推关系I_n=f(I_{n-1})或f(I_{n-2})\<br>
\end{align}<br>
$$</p>
<h2 id="定积分">定积分</h2>
<h3 id="一、定积分概念">一、定积分概念</h3>
<h4 id="1-定义-2">1.定义</h4>
<p>$$<br>
\begin{align}<br>
&amp;定义:设函数f(x)在区间[a,b]上有定义且有界\<br>
&amp;(1)分割：将[a,b]分成n个[x_{i-1},x_{i}]小区间\<br>
&amp;(2)求和：[x_{i-1},x_{i}]上取一点\xi_{i},\sum_{i=1}^{n}{f(\xi_{i})\Delta x_i},\lambda=\max{\Delta x_{1},\Delta x_{2},…,\Delta x_{n}}\<br>
&amp;(3)取极限：若\lim_{\lambda \rightarrow 0}{\sum_{i=1}^{n}f(\xi_{i})\Delta x}\exist,且极值不依赖区间[a,b]分发以及点\xi_{i}的取法,则称f(x)在区间[a,b]上可积,\<br>
&amp;\int^{b}<em>{a}{f(x)dx}=\lim</em>{\lambda \rightarrow 0}{f(\xi)\Delta x_{i}}<br>
&amp;\<br>
&amp;注解：\<br>
&amp;(1)\lambda \rightarrow0 \rightarrow \nleftarrow n\rightarrow \infty\<br>
&amp;(2)定积分表示一个值,与积分区间[a,b]有关,与积分变化量x无关\<br>
&amp;\int_{a}^{b}{f(x)dx}=\int_{a}^{b}{f(t)dt}\<br>
&amp;(3)如果积分\int_{0}^{1}{f(x)dx}\exist,将[0,1]n等分，此时\Delta{x_{i}}=\frac{1}{n},取\xi_{i}=\frac{i}{n},\<br>
&amp;\int_{0}^{1}f(x)dx=\lim_{\lambda \rightarrow 0}{\sum_{i=1}{n}{f(\xi_{i})\Delta x_{i}}}=\lim_{n\rightarrow \infty}\sum_{i=1}^{n}f(\frac{i}{n})\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;\int^{b}<em>{a}{f(x)dx}=\lim</em>{\lambda \rightarrow 0}\sum^{n}<em>{i=1}f(\xi_i)\Delta_i=\begin{cases}&amp;\lim</em>{n\rightarrow \infty}{\sum_{i=1}^{n}{f(a+(i-1)\frac{b-a}{n})\frac{b-a}{n}}},左侧\&amp;\lim_{n\rightarrow \infty}{\sum_{i=1}^{n}{f(a+i\frac{b-a}{n})\frac{b-a}{n}}},右侧\\end{cases}\<br>
&amp;中点：\Phi_i=a+(i-1)\frac{b-a}{n}+\frac{b-a}{2n}\<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210613172601984.jpg" alt="image-20210613172601984"></p>
<p>定理：(线性)<br>
$$<br>
\begin{align}<br>
&amp;\int[\alpha f(x)+\beta g(x)]dx=\alpha\int f(x)dx+\beta\int g(x)dx\<br>
\end{align}<br>
$$<br>
注解：积分无小事<br>
$$<br>
\begin{align}<br>
&amp;\int{e^{\pm x^2}dx,\int{\frac{\sin x}{x}}}积不出来\<br>
&amp;F’(x)=f(x),x\in I,连续函数一定存在原函数，无穷多个\<br>
&amp;[F(x)+C]'=f(x)<br>
\end{align}<br>
$$</p>
<h4 id="2-定积分存在的充分条件">2.定积分存在的充分条件</h4>
<p>$$<br>
\begin{align}<br>
&amp;若f(x)在[a,b]上连续,则\int^{b}<em>{a}{f(x)dx}必定存在\<br>
&amp;若f(x)在[a,b]上有上界,且只有有限个间断点,则\int^{b}</em>{a}{f(x)dx}必定存在\<br>
&amp;若f(x)在[a,b]上只有有限个第一类间断点,则\int^{b}_{a}{f(x)dx}必定存在\<br>
\end{align}<br>
$$</p>
<h4 id="3-定积分的几何意义">3.定积分的几何意义</h4>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405155729433.jpg" alt="image-20210405155729433"><br>
$$<br>
\begin{align}<br>
&amp;(1)f(x)\geqslant{0},\int_{a}^{b}{f(x)dx}=S\<br>
\end{align}<br>
$$<br>
<img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405155859329.jpg" alt="image-20210405155859329"><br>
$$<br>
\begin{align}<br>
&amp;(2)f(x)\leqslant{0},\int_{a}^{b}{f(x)dx}=-S\<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405155556537.jpg" alt="image-20210405155556537"><br>
$$<br>
\begin{align}<br>
&amp;(3)f(x)\geqslant{0}\cup f(x)\leqslant{0},\int_{a}^{b}{f(x)dx}=S_1+S_3-S_2\</p>
<p>\end{align}<br>
$$</p>
<p>注解：<br>
$$<br>
\begin{align}<br>
&amp;（1）当f(x)\geq0时,定积分的几何意义是,以区间[a,b]为底,y=f(x)为曲边的曲边梯形面积\<br>
&amp;（2）定积分是一个常数，只与f和区间[a,b]有关,与积分变量用什么字母无关\<br>
&amp;\int_a^b{f(x)}dx=\int_a^b{f(t)dt}\<br>
&amp;（3）\int_a^bdx=b-a\<br>
&amp;（4）\int_{a}^{a}f(x)=0,\int_a^bf(x)dx=-\int_b^a{f(t)}dt<br>
\end{align}<br>
$$</p>
<h3 id="二、定积分的性质">二、定积分的性质</h3>
<h4 id="1-不等式性质">1.不等式性质</h4>
<p>$$<br>
\begin{align}<br>
&amp;(1)保序性：若在区间[a,b]上f(x)\leqslant{g(x)},则\int_a^{b}{f(x)dx}\leqslant{\int_a^{b}{g(x)dx}}\<br>
&amp;推论：\<br>
&amp;(1)f(x)\geq0,\forall x\in[a,b],则\int_a^b{f(x)dx}\geq0\<br>
&amp;(2)f(x)\geq0,\forall x\in[a,b],且[c,d]\subset[a,b],则\int_a^b{f(x)dx}\geq\int_c^d{f(x)dx}\<br>
&amp;(3)|\int_a^bf(x)dx|\leq\int_a^b{|f(x)|dx}\<br>
&amp;-|f|\leq f\leq |f|\Rightarrow \int_a^b-|f|\leq \int_a^bf\leq \int_a^b|f|\Rightarrow |\int_a^bf|\leq\int_a^b|f|\<br>
&amp;如：x^2\leq x^3,x\in[0,1],则\int_0^1{x^3dx}\leq\int_0^1{x^2dx}\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;(4)(估值不等式)若M及m分别是f(x)在[a,b]上的最大值和最小值,\<br>
&amp;则m(b-a)\leqslant{\int_a^{b}{f(x)dx}\leqslant{M(b-a)}}\<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/geogebra-export.jpg" alt="geogebra-export"><br>
$$<br>
\begin{align}<br>
&amp;证明：M(b-a)=S_{AFDC}=S_1+S_2+S_3\<br>
&amp;m(b-a)=S_{EBDC}=S_3\<br>
&amp;\int_a^{b}{f(x)dx}=S_{ADBC}=S_2+S_3\<br>
&amp;S_3\leqslant{S_2+S_3\leqslant{S_1+S_2+S_3}}\<br>
&amp;\Leftrightarrow{m(b-a)\leqslant{\int_a^{b}{f(x)dx}\leqslant{M(b-a)}}}\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;(3)|\int_a^{b}{f(x)dx}|\leqslant{\int_a^{b}{|f(x)|dx}}\<br>
\end{align}<br>
$$</p>
<h4 id="2-中值定理">2.中值定理</h4>
<p>$$<br>
\begin{align}<br>
&amp;(1)若f(x)在[a,b]上连续,则\int_a^{b}{f(x)dx}=f(\xi)(b-a),(a&lt;\xi&lt;b)\<br>
&amp;称\frac{1}{b-a}{\int_{a}^{b}{f(x)dx}为函数y=f(x)在区间[a,b]上的平均值}\<br>
&amp;注解：F’(x)=f(x),F(b)-F(a)=\int_a^b{f(x)dx},f(\xi)(b-a)=F’(\xi)(b-a)\<br>
&amp;(2)若f(x),g(x)在[a,b]上连续，g(x)不变号,则\int_{a}^{b}{f(x)g(x)dx}=f(\xi)\int_a^b{g(x)dx}\<br>
\end{align}<br>
$$</p>
<p>注解：<br>
$$<br>
\begin{align}<br>
&amp;\int_0^1{\frac{x}{\sin x}}dx\<br>
&amp;f(x)=\begin{cases}&amp;\frac{x}{\sin x},x\in[0,1]\&amp;1,x=0\\end{cases}\<br>
&amp;结论：有限处点的函数不影响定积分\<br>
&amp;f(x)={\begin{cases}&amp;x+1,[1,2]\&amp;x,[0,1]\\end{cases}}\<br>
&amp;\int_0^2{f(x)dx}=\int_0^1{xdx}+\int_1^2{(x+1)dx}\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;证明：\frac{1}{2}\leq\int_0^{\frac{1}{2}}\frac{1}{\sqrt{1-x^n}}dx\leq\frac{\pi}{6}\<br>
&amp;估值积分：x\in[0,\frac{1}{2}]\<br>
&amp;\<br>
\end{align}<br>
$$</p>
<p>例题：<br>
$$<br>
\begin{align}<br>
&amp;1.求极限\lim_{n\rightarrow \infty}\int_0^1{\frac{x^ne^x}{1+e^x}dx}\<br>
&amp;根据积分容易知道0\leq\frac{x^ne^x}{1+e^x}\leq x^n,x\in[0,1],n\in N^*\<br>
&amp;用积分的保号性\<br>
&amp;0\leq\int_0^1{\frac{x^ne^x}{1+e^x}dx}\leq \int_0^1{x^n}dx=\frac{1}{n+1}\<br>
&amp;用夹逼定理\<br>
&amp;\lim_{n\rightarrow\infty}\frac{1}{n+1}=0\<br>
&amp;\lim_{n\rightarrow \infty}\int_0^1{\frac{x^ne^x}{1+e^x}dx}=0\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;2.设I_1=\int_0^{\frac{4}{\pi}}\frac{\tan x}{x}dx,I_2=\int_0^{\frac{4}{\pi}}\frac{x}{\tan x}dx则\<br>
&amp;(A)I_1I_21(B)1I_1I_2©I_2I_11(D)1I_2I_1\<br>
&amp;解：用保序性a&lt;b,f(x)\leq g(x),\int_a^b f(x)\leq \int_a^b g(x)\<br>
&amp;\tan xx,x\in[0,\frac{\pi}{2}]\<br>
&amp;\frac{\tan x}{x}1\frac{x}{\tan x},x\in[0,\frac{\pi}{4}]\<br>
&amp;根据保序性\<br>
&amp;\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}dx\int_0^{\frac{\pi}{4}}1dx=\frac{\pi}{4}\int_0^{\frac{\pi}{4}}\frac{x}{\tan x},x\in[0,\frac{\pi}{4}]\<br>
&amp;证：\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}与1的关系\<br>
&amp;积分中值定理\<br>
&amp;\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}=f(\xi)(\frac{\pi}{4}-0)=\frac{\tan \xi}{\xi}*\frac{\pi}{4},\xi\in{[0,\frac{\pi}{4}]}\<br>
&amp;根据\frac{\tan x}{x}在x\in[0,\frac{\pi}{4}]上单调递增\<br>
&amp;0&lt;f(\xi)&lt;\frac{4}{\pi},0&lt;\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}&lt;1\<br>
&amp;选(B)\<br>
\end{align}<br>
$$</p>
<h3 id="三、积分上限函数">三、积分上限函数</h3>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405152647772.jpg" alt="image-20210405152647772"><br>
$$<br>
\begin{align}<br>
&amp;如果f(x)在区间[a,b]上连续,则\Phi(x)=\int_a^b{f(t)dt}在[a,b]上可导,且\int_a^b{f(t)dt})\<br>
&amp;(\int_a^xf(t)dt)‘=f(x),(\int_a^{x^2}f(t)dt)’=f(x^2)<em>2x\<br>
&amp;如果f(x)在区间[a,b]上连续,\phi_1(x),\phi_2(x)为可导函数,则\Phi(x)=\int_a^b{f(t)dt}在[a,b]上可导,且(\int_{\phi_1(x)}^{\phi_2(x)}{f(t)dt})'\<br>
&amp;=f[\phi_2(x)]</em>\phi_2’(x)-f[\phi_1(x)]*\phi_1’(x)=(\int_{\phi_1(x)}^0{f(t)dt}+\int_{\phi_2(x)}^0{f(t)dt})'\<br>
&amp;设函数f(x)在[-l,l]上连续,则\<br>
&amp;如果f(x)为奇函数,那么\int_0^xf(t)dt必为偶函数\<br>
&amp;如果f(x)为偶函数,那么\int_0^xf(t)dt必为奇函数\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;任取x\in[a,b),取\Delta x0,使x+\Delta x\in[a,b)\<br>
&amp;\frac{\Delta F}{\Delta x}=\frac{F(x+\Delta x)-F(x)}{\Delta x}=\frac{1}{\Delta x}[\int_a^{x+\Delta x}f(t)dt-\int_a^xf(t)dt]=\frac{1}{\Delta x}\int_x^{x+\Delta x}f(t)dt=f(x+\sigma\Delta x)\rightarrow f(x)(\Delta x\rightarrow 0^+)\<br>
\end{align}<br>
$$<br>
推论：<br>
$$<br>
\begin{align}<br>
&amp;若f(x)、\phi’(x)、\psi(x)于[a,b]上连续,则\<br>
&amp;(1)(\int_a^{\phi(x)}f(t)dt)‘=f(\phi(x))\phi’(x)\<br>
&amp;(2)(\int_b^{\psi(x)}f(t)dt)‘=-f(\psi(x))\psi’(x)\<br>
&amp;(3)(\int_{\psi(x)}^{\phi(x)}f(t)dt)‘=f(\phi(x))\phi’(x)-f(\psi(x))\psi’(x)\<br>
\end{align}<br>
$$<br>
例题<br>
$$<br>
\begin{align}<br>
&amp;1.设函数f(x)在R上连续,且是奇函数,则其原函数均是偶函数.当f(x)是偶函数时？是周期函数？\<br>
&amp;证：\<br>
&amp;令F_0(x)\int_0^xf(t)dt,x\in R\<br>
&amp;F_0(-x)=\int_0^{-x}f(t)dt\overset{t=-u}{=}\int_0^xf(-u)d(u)=\int_0^xf(u)du=F_0(x)\Rightarrow F_0(x)为偶函数\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;求变现积分导数\<br>
&amp;(1)F(x)=\int_x^{e^{-x}}f(t)dt\<br>
&amp;(2)F(x)=\int_0^{x^2}(x^2-t)f(t)dt\<br>
&amp;(3)F(x)=\int_0^{x}f(x^2-t)dt\<br>
&amp;(4)设函数y=y(x)由参数方程\begin{cases}&amp;x=1+2t^2\&amp;y=\int_1^{1+2\ln t}\frac{e^u}{u}du\\end{cases}(t1),求\frac{d^2y}{dx^2}|_{x=9}\<br>
&amp;解:\<br>
&amp;(1)F(x)‘=(\int_x^{e^{-x}}f(t)dt)’=f(e^{-x})(-e^{-x})-f(x)\<br>
&amp;(2)F(x)‘=(\int_0^{x^2}(x^2-t)f(t)dt)’=(\int_0^{x^2}x^2f(t)dt-\int_0^{x^2}tf(t)dt)‘\<br>
&amp;=2x\int_0^{x^2}f(t)dt+x^2f(x^2)2x-x^2f(x^2)2x=2x\int_0^{x^2}f(t)dt\<br>
&amp;(3)F(x)=\int_0^{x}f(x^2-t)dt=-\frac{1}{2}\int_0^xf(x^2-t^2)d(x^2-t^2)\overset{u=x^2-t^2}{=}-\frac{1}{2}\int_0^xf(u)du\<br>
&amp;F(x)’=\frac{1}{2}f(x^2)2x=xf(x^2)\<br>
&amp;(4)\frac{dy}{dx}=\frac{\frac{e^{1+2\ln t}}{1+2\ln t}\frac{2}{t}}{4t^2}=\frac{e}{2(1+2\ln t)}\<br>
&amp;\frac{d^2y}{dx^2}=\frac{d(\frac{dy}{dx})}{dx}=\frac{e}{2}(-\frac{\frac{2}{t}}{(1+2\ln t)^2})\frac{1}{4t}\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;2.求变现积分的积分:\<br>
&amp;(1)设f(x)=\int_0^x{\frac{\sin t}{\pi -t}dt},求\int_0^\pi{f(x)}dx\<br>
&amp;解:\<br>
&amp;\int_0^\pi{f(x)}dx=\int_0^{\pi}\int_0^x\frac{\sin t}{\pi -t}dt\space dx\<br>
&amp;=x\int_0^x\frac{\sin t}{\pi t}|<em>0^{\pi}-\int_0^{\pi}x\frac{\sin x}{\pi -x}dx\<br>
&amp;=\pi\int_0^{\pi}\frac{\sin x}{\pi t}+\int_0^{\pi}\frac{[(\pi-x)-\pi]\sin x}{\pi-x}dx=\int_0^{\pi}\sin xdx=2\<br>
&amp;(2)\lim</em>{x\rightarrow\infty}{\frac{(\int_0^x{e^{t^2}}dt)^2}{\int_0^xe^{2t^2}dt}}=\lim_{x\rightarrow\infty}{\frac{(2\int_0^{x}e^{t^2}dt)e^{x^2}}{e^{2x^2}}}=\lim_{x\rightarrow\infty}\frac{2\int_0^{x}e^{t^2}}{e^{x^2}}=\lim_{x\rightarrow\infty}\frac{1}{2x}=0\<br>
\end{align}<br>
$$ { }</p>
<p>$$<br>
\begin{align}<br>
&amp;(3)设f(x)连续,\phi(x)=\int_0^1{f(tx)dt},且\lim_{x\rightarrow0}\frac{f(x)}{x}=A(常数),求\phi’(x)并讨论\phi’(x)在x=0处的连续性\<br>
&amp;当x\neq0时\<br>
&amp;令u=tx,t\in[0,1],u=tx\in[0,x],\phi(x)=\int_0^1f(tx)dt\overset{tx=u}{=}\int_0^x{f(u)d(\frac{u}{x})}=\frac{\int_0^xf(u)du}{x}\<br>
&amp;\phi’(x)=\frac{xf(x)-\int_0^xf(u)du}{x^2}\<br>
&amp;当x=0时,f(0)=0,\phi(0)=f(0)=0,\phi’(0)=\lim_{x\rightarrow0}\frac{\phi(x)\phi(0)}{x-0}=\lim_{x\rightarrow0}\frac{\int_0^xf(u)du}{x^2}=\lim_{x\rightarrow 0}\frac{f(x)}{2x}=\frac{1}{2}A\<br>
&amp;\lim_{x\rightarrow0}\phi’(x)=\lim_{x\rightarrow 0}{\frac{xf(x)-\int_0^xf(u)du}{x^2}}=A-\frac{1}{2}A=\frac{1}{2}A=\phi’(0)\Leftrightarrow\phi’(x)在x=0处连续\<br>
\end{align}<br>
$$</p>
<p>注解：<br>
$$<br>
\begin{align}<br>
&amp;注意变限积分进行正逆运算时上下限的映射\<br>
&amp;例如F(x)=\int_0^x{f(t)dt}\overset{t=-u}{=}\int_{-a}^{x}f(-u)d(-u)\<br>
\end{align}<br>
$$</p>
<h3 id="四、定积分的计算">四、定积分的计算</h3>
<h4 id="1-牛顿莱布尼茨公式">1.牛顿莱布尼茨公式</h4>
<p>$$<br>
\int_a^bf(x)dx=F(x)|_a^b=F(b)-F(a)<br>
$$</p>
<h4 id="2-换元积分法">2.换元积分法</h4>
<p>$$<br>
\int_a^bf(x)dx=\int_\alpha^\beta{f(\Phi(t))\Phi’(t)dt}<br>
$$</p>
<h4 id="3-分部积分法-2">3.分部积分法</h4>
<p>$$<br>
\int_a^budv=uv|_a^b-\int_a^bvdu<br>
$$</p>
<h4 id="4-奇偶性和周期性">4.奇偶性和周期性</h4>
<p>$$<br>
\begin{align}<br>
&amp;直接使用奇偶性周期性定义证明\<br>
&amp;(1)设f(x)为[-a,a]上的连续函数(a0),则\<br>
&amp;\int_{-a}{a}f(x)dx=\begin{cases}0,&amp;f(x)奇函数\2\int_0^af(x)dx,&amp;f(x)偶函数\end{cases}\<br>
&amp;证：\int_{-a}^0{f(x)dx}\overset{x=-t}{=}\int_0^a{f(-t)d(-t)}=-\int_{0}^{a}f(t)d(t)=-\int_0^a{f(x)dx}\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;(2)设f(x)是以T为周期的连续函数,则对\forall A，有\int_a^{a+T}f(x)=\int_0^T{f(x)dx}\<br>
&amp;\int_a^{a+T}f(x)dx\overset{x=a+t}{=}\int_0^T{f(a+t)d(a+t)}=\int_0^{a+t}f(a+t)dt\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;\Phi:x\in[a,b]\rightarrow y\in[c,d],令\frac{x-a}{b-a}=\frac{y-c}{d-c},y=c+\frac{d-c}{b-a}(x-a)\<br>
\end{align}\<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210617160041903.jpg" alt="image-20210617160041903"></p>
<h4 id="5-奇偶函数积分后的奇偶性-奇偶函数求导后的奇偶性">5.奇偶函数积分后的奇偶性(奇偶函数求导后的奇偶性)</h4>
<h5 id="1-奇偶函数求导后的奇偶性">1.奇偶函数求导后的奇偶性</h5>
<p>$$<br>
\begin{align}<br>
&amp;(1)f(x)为奇函数:\<br>
&amp;f(-x)=-f(x)\<br>
&amp;\Leftrightarrow f’(-x)(-1)=-f’(x)\<br>
&amp;\Leftrightarrow f’(-x)=f’(x)\<br>
&amp;\Leftrightarrow f’(x)为偶函数\<br>
&amp;(2)f(x)为偶函数:\<br>
&amp;f(-x)=f(x)\<br>
&amp;\Leftrightarrow f’(-x)=f’(x)\<br>
&amp;\Leftrightarrow f’(-x)(-1)=f’(x)\<br>
&amp;\Leftrightarrow f’(-x)=-f’(x)\<br>
&amp;\Leftrightarrow f’(x)为奇函数\<br>
\end{align}<br>
$$</p>
<h5 id="2-奇偶函数求积分后的奇偶性">2.奇偶函数求积分后的奇偶性</h5>
<p>$$<br>
\begin{align}<br>
&amp;设F(x)为f(x)的原函数\<br>
&amp;(1)f(x)为奇函数:\<br>
&amp;f(-x)=-f(x)\<br>
&amp;\Leftrightarrow \int f(-x)dx=-\int f(x)dx\<br>
&amp;\Leftrightarrow -\int f(-x)d(-x)=-\int f(x)dx\<br>
&amp;\Leftrightarrow F(-x)=F(x)\<br>
&amp;\Leftrightarrow F(x)为偶函数\<br>
&amp;(2)f(x)为偶函数:\<br>
&amp;f(-x)=f(x)\<br>
&amp;\Leftrightarrow \int f(-x)dx=\int f(x)dx\<br>
&amp;\Leftrightarrow -\int f(-x)d(-x)=\int f(x)dx\<br>
&amp;\Leftrightarrow F(-x)=-F(x)\<br>
&amp;\Leftrightarrow F(x)为奇函数\<br>
\end{align}<br>
$$</p>
<h5 id="3-奇偶函数复合后的奇偶性">3.奇偶函数复合后的奇偶性</h5>
<p>$$<br>
\begin{align}<br>
&amp;\exist f(x),g(x),F(x)=f(g(x))\<br>
&amp;设f(x)为奇函数\<br>
&amp;(1)g(x)为偶函数\<br>
&amp;F(-x)=f(g(-x))=f(g(x))=F(x),F(x)为偶函数\<br>
&amp;(2)g(x)为奇函数\<br>
&amp;F(-x)=f(g(-x))=f(-g(x))=-f(g(x))=-F(x),F(x)为奇函数\<br>
&amp;设f(x)为偶函数\<br>
&amp;(1)g(x)为奇函数\<br>
&amp;F(-x)=f(g(-x))=f(g(x))=F(x),F(x)为偶函数\<br>
&amp;(2)g(x)为偶函数\<br>
&amp;F(-x)=f(g(-x))=f(g(x))=F(x),F(x)为偶函数\<br>
&amp;注解:外偶全偶,外奇奇偶\<br>
\end{align}<br>
$$</p>
<p>例题：<br>
$$<br>
\begin{align}<br>
&amp;1.设M=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}{\frac{\sin x}{1+x^2}\cos^4xdx},N=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}{(\sin x^3+\cos^4x)dx},P=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(x^2\sin^3x-\cos^4x)dx,则\<br>
&amp;(A)N&lt;P&lt;M(B)M&lt;P&lt;N©N&lt;M&lt;P(D)P&lt;M&lt;N\<br>
&amp;根据对称性判断\<br>
&amp;M:f_M(x)为奇函数，F_M(x)为偶函数\<br>
&amp;N:N=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}{(\sin x^3+\cos^4x)dx}=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\sin ^3xdx+\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos ^4xdx\<br>
&amp;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\sin ^3xdx=0,\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos ^4xdx\geq 0,\Rightarrow N\geq 0\<br>
&amp;P:P=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(x^2\sin^3x-\cos^4x)dx=\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}x^2\sin^3xdx-\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos^4xdx\<br>
&amp;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}x^2\sin^3xdx=0,\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos^4xdx\geq0,\Rightarrow P\leq0\<br>
&amp;\Leftrightarrow P&lt;M&lt;N,\space\space选(D)\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;2.设f(x)=\begin{cases}&amp;kx,0\leq x\leq \frac{1}{2}a\&amp;c,\frac{1}{2}a&lt;x\leq a\\end{cases},求F(x)=\int_0^xf(t)dt,x\in[0,a]\<br>
&amp;F(x)=\begin{cases}&amp;\int_0^xktdt=\frac{1}{2}kt^2|<em>0^x=\frac{1}{2}kx^2,0\leq x\leq \frac{1}{2}a\&amp;\int_0^{\frac{1}{2}a}ktdt+\int</em>{\frac{1}{2}a}^c cdt=\frac{1}{8}ka^2+c^2-\frac{1}{2}ac,\frac{1}{2}a&lt;x\leq a\\end{cases}\<br>
\end{align}<br>
$$</p>
<p>$$<br>
\begin{align}<br>
&amp;3.证明：\int_0^{2\pi}f(|\cos x|)dx=4\int_0^{\frac{\pi}{2}}f(|\cos x|)dx\<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/e0e1f27ff16b0cf00a8f3d155bfc3423.jpg" alt="1111"></p>
<h4 id="6-已有公式">6.已有公式</h4>
<p>$$<br>
\begin{align}<br>
&amp;(1)\int_0^{\frac{\pi}{2}}{\sin^nxdx=\int_0^{\frac{\pi}{2}}\cos^n xdx=\begin{cases}\frac{n-1}{n}<em>\frac{n-3}{n-2}</em>…<em>\frac{1}{2}</em>\frac{\pi}{2},&amp;n为偶数\\frac{n-1}{n}<em>\frac{n-3}{n-2}</em>…*\frac{2}{3},&amp;n为大于1的奇数\\end{cases}}\<br>
&amp;(2)\int_0^{\pi}xf(\sin x)dx=\frac{\pi}{2}\int_0^{\pi}f(\sin x)dx(f(x)为连续函数)\<br>
\end{align}<br>
$$</p>
<h4 id="7-与定积分有关的证明">7.与定积分有关的证明</h4>
<h4 id="8-经典例题：">8.经典例题：</h4>
<h5 id="例题1">例题1:</h5>
<p>$$<br>
\begin{align}<br>
&amp;\lim_{n\rightarrow \infty}{(\frac{1}{n+1}+\frac{1}{n+2}+…+\frac{1}{n+n})}\<br>
&amp;法1：夹逼定理+基本不等式\<br>
&amp;\frac{1}{1+x}&lt;\ln(x+1)&lt;x\<br>
&amp;令x=\frac{1}{n}\<br>
&amp;得\frac{1}{n+1}=\frac{\frac{1}{n}}{\frac{1}{n}+1}&lt;\ln(\frac{1}{n}+1)=\ln(n+1)-\ln(n)&lt;\frac{1}{n}\<br>
&amp;得\frac{1}{n+2}&lt;ln(n+2)-ln(n+1)&lt;\frac{1}{n+1}\<br>
&amp;得\frac{1}{n+n}&lt;\ln(n+n)-\ln(n+n-1)&lt;\frac{1}{n+n-1}\<br>
&amp;得\frac{1}{n+1}+\frac{1}{n+2}+…+\frac{1}{n+n}&lt;ln(2n)-ln(n)=ln2\<br>
&amp;法2：\lim_{n\rightarrow \infty}{(\frac{1}{n+1}+\frac{1}{n+2}+…+\frac{1}{n+n})}中\<br>
&amp;\frac{1}{n+1}中n为主体，1为变体\<br>
&amp;\frac{变体}{主体}\rightarrow^{n \rightarrow{\infty}}\begin{cases}0,次(夹逼定理)\A\neq 0,同(定积分)\end{cases}\<br>
&amp;\lim_{\lambda \rightarrow 0}{\sum_{i=1}^{n}{f(\xi_i)\Delta x_i}=\lim_{n\rightarrow \infty}\frac{1}{n}\sum_{i=1}^{n}f(\xi_i)(b-a)}=\int_0^1\frac{1}{1+x}=\ln(1+x)|_{0}^{1}=\ln2\<br>
\end{align}<br>
$$</p>
<h5 id="例题2">例题2</h5>
<p>$$<br>
\begin{align}<br>
&amp;设f(x)=\int_0^{\pi}{\frac{\sin x}{\pi-t}dt},计算\int_0^{\pi}f(x)dx.\<br>
&amp;法1：分部积分+换元法\<br>
&amp;原式=xf(x)|_0^{\pi}-\int_0^{\pi}{\frac{x\sin x}{\pi-x}dx}\<br>
&amp;=\pi{\int_0^{\pi}{\frac{\sin{t}}{\pi-t}dt}-\int_0^{\pi}{\frac{x\sin x}{\pi-x}}dx}\<br>
&amp;=\int_0^{\pi}{\frac{(\pi-x)\sin x}{\pi-x}dx}=2\<br>
&amp;法2：\<br>
&amp;原式=\int_0^\pi{f(x)d(x-{\pi})}=(x-\pi)f(x)|_0^{\pi}-\int_0^{\pi}{\frac{(x-\pi)\sin x}{\pi-x}dx}=2\<br>
&amp;法3：二重积分转化为累次积分\<br>
&amp;原式=\int_0^{\pi}{\int_0^{\pi}\frac{x\sin t}{\pi-t}dt}dx\<br>
\end{align}<br>
$$</p>
<h5 id="例题3">例题3</h5>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/AN%25L6IJ6TF%5B%251UB3OUWMRCR.jpg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/123.jpg" alt="123"><br>
$$<br>
\begin{align}<br>
&amp;法1：构造辅助函数\<br>
&amp;根据题意f(1)=f(-1)=1,f(0)=-1\Rightarrow f(x)为偶函数,f最低点函数值为-1\<br>
&amp;可以构造符合题意的辅助函数f(x)=2x^2-1\<br>
&amp;法2：根据函数的性质直接判断<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210408160543049.jpg" alt="image-20210408160543049"></p>
<h5 id="例题4">例题4</h5>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/Q8%7DOT_25(HC79%5BS_21)AZZK.jpg" alt="img"></p>
<p>$$<br>
\begin{align}<br>
&amp;因为\lim_{x\rightarrow 0}{\frac{ax-\sin x}{\int_b^x{\frac{\ln{1+t^3}}{t}dt}}}=c(c\neq 0)\<br>
&amp;所以\lim_{x\rightarrow 0}{ax-\sin x}=0并且\lim_{x \rightarrow 0}{\int_b^x{\frac{\ln{1+t^3}}{t}dt}}=0\<br>
&amp;化简,使用洛必达法则上下求导\<br>
&amp;\lim_{x\rightarrow 0}{\frac{ax-\sin x}{\int_b^x{\frac{\ln{1+t^3}}{t}dt}}}=\lim_{x\rightarrow 0}{\frac{a-\cos x}{\frac{\ln{1+x^3}}{x}}}=\lim_{x\rightarrow 0}{\frac{a-\cos x}{x^2}}\<br>
&amp;\Rightarrow a=1,c=\frac{1}{2},b=0\<br>
\end{align}<br>
$$</p>
<h2 id="反常积分">反常积分</h2>
<h3 id="一、无穷区间上的反常积分">一、无穷区间上的反常积分</h3>
<p>$$<br>
\begin{align}<br>
&amp;(1)\int_a^{+\infty}{f(x)}dx=\lim_{t\rightarrow +\infty}{\int_{a}^{t}f(x)dx}\<br>
&amp;(2)\int_{-\infty}^{b}{f(x)}dx=\lim_{t\rightarrow -\infty}{\int_{t}^{b}f(x)dx}\<br>
&amp;(3)\int_{-\infty}^{0}{f(x)}dx和{\int_{0}^{+\infty}f(x)dx}都收敛,则{\int_{-\infty}^{+\infty}f(x)dx}收敛\<br>
&amp;且{\int_{-\infty}^{+\infty}f(x)dx}=\int_{-\infty}^{0}{f(x)}dx+{\int_{0}^{+\infty}f(x)dx}\<br>
&amp;如果其中一个发散,结果也发散\<br>
&amp;常用结论：\int_a^{+\infty}{\frac{1}{x^p}dx}\begin{cases}&amp;p1,收敛\&amp;p\leq1 ,发散\\end{cases},(a0)\<br>
\end{align}<br>
$$</p>
<h3 id="二、无界函数的反常积分">二、无界函数的反常积分</h3>
<p>$$<br>
\begin{align}<br>
&amp;如果函数f(x)在点a的任一领域内都无界,那么点a为函数f(x)的瑕点(也称为无界点).无界函数的反常积分也成为瑕积分\<br>
&amp;(1)设函数f(x)在(a,b]上连续,点a为f(x)的瑕点.如果极限\lim_{t\rightarrow a^+}{\int_{t}^{b}{f(x)dx}}\exist,\<br>
&amp;则称此极限为函数f(x)在区间[a,b]上的反常区间,记作\int_{a}^{b}f(x)dx,即\int_{a}^{b}f(x)dx=\lim_{t\rightarrow a^+}{\int_{t}^{b}{f(x)dx}}\<br>
&amp;这时也称反常积分\int_a^b{f(x)dx}收敛,如果上述极限不存在，则反常积分\int_a^b{f(x)dx}发散\<br>
&amp;(2)设函数f(x)在[a,b)上连续,点b为函数f(x)的瑕点,则可以类似定义函数f(x)在区间[a,b]上的反常积分\int_a^bf(x)dx=\lim_{t\rightarrow b^-}{\int_a^tf(x)dx}\<br>
&amp;设函数f(x)在[a,b]上除点c(a&lt;c&lt;b)外连续,点c为函数f(x)的瑕点,如果反常积分\int_a^c{f(x)dx}和\int_c^b{f(x)dx}都收敛\<br>
&amp;则称反常积分\int_a^b{f(x)dx}收敛,且\int_a^b{f(x)dx}=\int_a^c{f(x)dx}+\int_c^b{f(x)dx}\<br>
&amp;如果至少一个发散,则称\int_a^b{f(x)dx}发散\<br>
&amp;常用结论：\<br>
&amp;\int_a^b{\frac{1}{(x-a)^p}}\begin{cases}&amp;p&lt;1,收敛\&amp;p\geq 1,发散\\end{cases}\<br>
&amp;\int_a^b{\frac{1}{(x-a)^p}}\begin{cases}&amp;p&lt;1,收敛\&amp;p\geq 1,发散\\end{cases}\<br>
\end{align}<br>
$$</p>
<h3 id="三、例题">三、例题</h3>
<h5 id="例题1-2">例题1</h5>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/12edsadada.jpg" alt="12edsadada"><br>
$$<br>
\begin{align}<br>
&amp;\int\frac{1}{\ln^{\alpha}x}d(\ln x)\rightarrow^{\ln x=u}\int{\frac{du}{u^{\alpha+1}}}\begin{cases}&amp;{\alpha-1&lt; 1}\&amp;{\alpha+11}\\end{cases}\Rightarrow 0&lt;\alpha&lt;2\<br>
\end{align}<br>
$$</p>
<h2 id="定积分的应用">定积分的应用</h2>
<h4 id="微元法">微元法</h4>
<p>$$<br>
\begin{align}<br>
&amp;\<br>
\end{align}<br>
$$</p>
<h3 id="一、几何应用">一、几何应用</h3>
<h4 id="1-平面图形的面积">1.平面图形的面积</h4>
<p>$$<br>
\begin{align}<br>
&amp;(1)若平面域D由曲线y=f(x),y=g(x)(f(x)\geq g(x)),x=a,x=b(a&lt;b)所围成,则平面域D的面积为\<br>
&amp;S=\int_a^b{[f(x)-g(x)]dx}\<br>
&amp;(2)若平面域D由曲线由\rho=\rho(\theta),\theta=\alpha,\theta=\beta(\alpha&lt;\beta)所围成,则其面积为S=\frac{1}{2}\int_{\alpha}^{\beta}{\rho^2(\theta)d\theta}<br>
\end{align}<br>
$$</p>
<h4 id="2-旋转体的体积">2.旋转体的体积</h4>
<p>$$<br>
\begin{align}<br>
&amp;若区域D由曲线y=f(x)(f(x)\geq 0)和直线x=a,x=b(0\leq a&lt;b)及x轴所围成,则\<br>
&amp;(1)区域D绕x轴旋转一周所得到的旋转体体积为V_x=\pi\int_a^b{f^2(x)dx}\<br>
&amp;(2)区域D绕y轴旋转一周所得到的旋转体体积为V_y=2\pi\int_a^b{xf(x)dx}\<br>
&amp;(3)区域D绕y=kx+b轴旋转一周所得到的旋转体体积为V=2\pi\int_D\int{r(x,y)d\sigma}\<br>
&amp;例如：求y=x,y=x^2在第一象限的封闭图形绕转轴的体积\<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/U1%7D97(ZE)HIN4FCVUKI$%5DZB.jpg" alt="img"><br>
$$<br>
\begin{align}<br>
&amp;V_x=2\pi\int_D\int yd\sigma=2\pi\int_0^1{dx}\int_{x^2}^{x}ydy\<br>
&amp;V_y=2\pi\int_D\int xd\sigma=2\pi\int_0^1{dx}\int_{x^2}^{x}xdy\<br>
&amp;V_{x=1}=2\pi\int_D\int (1-x)d\sigma\<br>
&amp;V_{y=2}=2\pi\int_D\int (2-y)d\sigma\<br>
\end{align}<br>
$$</p>
<h4 id="3-曲线弧长">3.曲线弧长</h4>
<p>$$<br>
\begin{align}<br>
&amp;(1)C:y=y(x),a\leq x\leq b,s=\int_a^b{\sqrt{1+y’^2}dx}\<br>
&amp;(2)C:\begin{cases}&amp;x=x(t)\&amp;y=y(t)\\end{cases},\alpha \leq t\leq  \beta,s=\int_{\alpha}^{\beta}{\sqrt{x’^2+y’^2}dx}\<br>
&amp;(3)C:\rho=\rho(\theta),\alpha \leq \theta\leq  \beta,s=\int_{\alpha}^{\beta}{\sqrt{\rho^2+\rho’^2}dx}\<br>
\end{align}<br>
$$</p>
<h4 id="4-旋转体侧面积">4.旋转体侧面积</h4>
<p>$$<br>
\begin{align}<br>
&amp;曲线y=f(x)(f(x)\geq 0)和直线x=a,x=b(0\leq a&lt;b)及x轴所围成的区域绕x轴旋转所得到的旋转体的侧面积为\<br>
&amp;S=2\pi\int_a^b{f(x)\sqrt{1+f’^2(x)}dx}\<br>
\end{align}<br>
$$</p>
<h3 id="二、物理应用">二、物理应用</h3>
<h4 id="1-压力">1.压力</h4>
<h4 id="2-变力做功">2.变力做功</h4>
<h4 id="3-引力（较少考）">3.引力（较少考）</h4>
<h4 id="例题1img">例题1<img src="https://raw.githubusercontent.com/blueflylabor/images/main/X2PPU~%25@L@NM4Y%7DW6GZTT_R.jpg" alt="img"></h4>
<p>$$<br>
\begin{align}<br>
&amp;分析题意可知,该容器由x^2+y^2=1的圆和x^2+(y-1)^2=1的偏心圆组成\<br>
&amp;根据图像的对称性可以避免不同表达式带来的困难\<br>
&amp;对圆的小带子进行积分，带子长度为x，积分区间为-1到\frac{1}{2}，\int_{-1}^{\frac{1}{2}}{\pi x^2dy}\<br>
&amp;由于图像的对称性，将积分结果乘二\<br>
&amp;(1)V=2\pi\int_{-1}^{\frac{1}{2}}{x^2}dy=2\pi\int_{-1}^{\frac{1}{2}}{(1-y^2)dy}=\frac{9\pi}{4}\<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-19%20203327.jpg" alt="屏幕截图 2021-04-19 203327"><br>
$$<br>
\begin{align}<br>
&amp;(2)W=F<em>S=G</em>S=mg<em>S=\rho VSg\<br>
&amp;上部为W_1=\int_{\frac{1}{2}}^{2}(2y-y^2)(2-y)dy</em>\rho g\<br>
&amp;下部为W_2=\int^{\frac{1}{2}}_{-1}(1-y^2)(2-y)dy*\rho g\<br>
&amp;W=W_1+W_2\<br>
\end{align}<br>
$$<br>
<img src="https://raw.githubusercontent.com/blueflylabor/images/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-19%20204534.jpg" alt="屏幕截图 2021-04-19 204534"></p>
<h4 id="例题2-2">例题2</h4>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210419211039410.jpg" alt="image-20210419211039410"><br>
$$<br>
\begin{align}<br>
&amp;F_p=P<em>A=\rho gh</em>A\<br>
&amp;将图像分为上部和下部，上部为矩形区域和下部的抛物线围成的面积区域，对其进行依次求解\<br>
&amp;P_1=2\rho gh\int_1^{h+1}{h+1-y}dy=\rho gh^2\<br>
&amp;P_2=2\rho gh\int_0^1{(h+1-y)\sqrt{y}dy=4\rho g(\frac{1}{3}h+\frac{2}{15})}\<br>
&amp;\frac{P_1}{P_2}=\frac{4}{5}\Rightarrow h=2,h=-\frac{1}{3}(舍去)<br>
\end{align}<br>
$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/1618837868(1).jpg" alt="1618837868(1)"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/" data-id="clyp3okzf000g0vdqb08r799z" data-title="高等数学不定积分与定积分与反常积分" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-高等数学二元函数可微与偏导的联系​" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%81%8F%E5%AF%BC%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%8B/" class="article-date">
  <time class="dt-published" datetime="2018-09-06T04:01:51.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%81%8F%E5%AF%BC%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%8B/">高等数学二元函数的可偏导</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>1.二元函数的可偏导</strong></p>
<p>在二元函数中，一元函数的可导的概念变为可偏导，导函数的概念变为偏导函数，具体看下例：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/9d82d158ccbf6c818200af6499c37c3132fa400c.jpeg" alt="img"></p>
<p>二元函数f(x,y)对x、y的偏导函数分别为：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/728da9773912b31b5d52d2cda3e5fb7edbb4e11e.jpeg" alt="img"></p>
<p>在求二元函数的偏导函数时，都是假设另外一个变量为常量，然后对余下那个变量求导数。例如，f(x,y)对x的偏导函数，就是假设y为常量，然后f(x,y)对变量x求导数即得。</p>
<p>对于某一点，函数f(x, y)在该点的两个偏导数可能都存在、可能只存在一个、也可能都不存在。</p>
<p>在点(0, 0)的两个偏导数只存在一个的函数例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/2cf5e0fe9925bc31f7e7c860782240b5c9137096.jpeg" alt="img"></p>
<p>在点(0, 0)的两个偏导数都不存在的函数例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/023b5bb5c9ea15ce6c2fde3c90fdf7f73887b2c7.jpeg" alt="img"></p>
<p>在点(0, 0)的两个偏导数都存在的函数例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/0824ab18972bd407221931d55d7453550eb30939.jpeg" alt="img"></p>
<p>对于上面三个例子，小编建议大家亲手去算算偏导数，这样能加深对二元函数偏导数的理解。</p>
<p><strong>2.二元函数的可微</strong></p>
<p>某一点可微描述的是函数增量与自变量增量之间的线性关系。在一元函数中，若线性主部的系数只与该点有关，则可微。以此类推，在二元函数中，若多个自变量的线性主部的系数都只与该点有关，则可微。下面分别列出一元函数、二元函数函数增量与自变量增量之间的关系式：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/d439b6003af33a877c62e124e1a1dd3c5243b587.jpeg" alt="img"></p>
<p>对于一特定点，当A、B为常数时，即A、B与自变量增量无关，则函数在该点可微，且A、B分别为函数在该点对x、y求偏导后的偏导数。</p>
<p><strong>3.可微、可偏导、连续、导函数连续之间的关系</strong></p>
<p>为了方便比较一元函数，小编先给出一元函数在某点C上关于可微、可导、连续、导函数连续的关系图。在图1中，函数f(x)可微与可导等价，因此可微与可导之间是双向箭头；在点C可微、可导必能得出函数f(x)在点C连续，但连续不能推出f(x)在点C可导、可微。因此可微、可导与连续之间是单向箭头。而导函数在点C连续，很明显就能推出函数在点C可导、可微、连续，但反过来，无法推出导函数在点C连续。</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/7acb0a46f21fbe09fc1d4d2f4d9dc1378644ad48.jpeg" alt="img">图1.一元函数可微、可导关系示意图</p>
<p>小编提醒大家，一定要经常记忆上图，而且是要理解性地记忆，比如说一元函数可微，要能明白可微是什么，关系式如何写！</p>
<p>相比于一元函数，二元函数就复杂多了，下面先给出二元函数可微、可偏导、连续、导函数连续的关系图。</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/3c6d55fbb2fb43165d025ae105598b2708f7d309.jpeg" alt="img">图2.多元函数可微、可偏导关系示意图</p>
<p>当然在记忆这些关系时，我们通常要花时间记忆的是那些不容易理解的关系，而这些不容易理解的关系是与一元函数相比较后的那些不同之处。</p>
<p><strong>3.1可微与可偏导不等价</strong></p>
<p>在阐述二元函数可微与可偏导不等价前，不妨先回顾下，为什么一元函数中可微与可导是等价的？</p>
<p>在一元函数中，如果函数f(x)在x=x0处可导，则有如下关系式：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/242dd42a2834349b8a998272ec17d8ca34d3bea8.jpeg" alt="img"></p>
<p>假设在一元函数中，函数增量与自变量存在如下关系：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/6a600c338744ebf8019d6c0aff041a2e6159a71c.jpeg" alt="img"></p>
<p>上式两边同除以△x，然后两边对△x取极限，可知A=m，则根据一元函数可微的定义，A只与x=x0有关，与△x无关，所以f(x)在x=x0可微。同理，不难得出在一元函数中，可微亦可推出可导。</p>
<p>那么在二元函数中，如何论证可微必可推导呢？</p>
<p>假设二元函数在点C(x0, y0)可微，则由可微的定义，必存在(x0, y0)的某邻域，使得下式成立：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/203fb80e7bec54e7797010c09cc556544dc26a55.jpeg" alt="img"></p>
<p>不妨分别令△x=0、△y=0，根据①式可得：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/f703738da977391283a65691dde44b1c347ae244.jpeg" alt="img"></p>
<p>之所以可以令△x=0、△y=0，是因为点(x0, y0+△y)和(x0+△x, y0)都在点(x0, y0)的可微邻域内。</p>
<p>对②中两式求极限，可得:</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/e850352ac65c103845d7a20797ec5e17b27e894f.jpeg" alt="img"></p>
<p>结合偏导数的定义和③中的两个极限，可知可微情况下，函数在点C的两个偏导数都存在，因此可微必可偏导。</p>
<p>尽管可微必可偏导，但反过来不成立，请看下面这个例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/08f790529822720ef5a584c15d36c742f31faba0.jpeg" alt="img"></p>
<p>函数F在(0, 0)的两个偏导数都存在且为0，现在用反证法证明函数F在点(0, 0)不可微。假设函数F在原点可微，则根据可微定义，下列极限必存在，但是下列极限可以通过列举两条路径很容易验证不存在，原假设错误，所以可偏导不一定可微。</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/c8177f3e6709c93d685e88a4b9c035d8d0005432.jpeg" alt="img"></p>
<p><strong>3.2 可偏导不一定连续</strong></p>
<p>在二元函数关系图中，另外一个很让人费解的地方，是二元函数在某点的两个偏导数都存在，但是函数在这一点却不一定连续。为了说明这一点，请看下面这个函数：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/0b46f21fbe096b6339eceea129ce4a40e9f8ac48.jpeg" alt="img"></p>
<p>相信大家都能很熟练地计算出函数F在原点对x、y的偏导数均为0，但是当曲线沿着y=x的路径趋于原点时，函数值会趋于1，不等于0，因此函数F在原点不连续。</p>
<p>从抽象的角度看，二元函数在某一点的两个偏导数都存在，只能说明二元函数沿x方向、沿y方向趋于该点的值等于函数在该点的定义值，但无法保证沿其它方向趋于该点的值也等于函数值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%81%8F%E5%AF%BC%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%8B/" data-id="clyp3okzh000j0vdqg7bp8505" data-title="高等数学二元函数的可偏导" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/14/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEUbuntu22.04%E5%AE%89%E8%A3%85Nodejs/">环境配置Ubuntu22.04安装Nodejs</a>
          </li>
        
          <li>
            <a href="/2023/10/06/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/">考研英语作文模板</a>
          </li>
        
          <li>
            <a href="/2023/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络网络层</a>
          </li>
        
          <li>
            <a href="/2023/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络传输层</a>
          </li>
        
          <li>
            <a href="/2021/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">操作系统同步问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 蓝翔技工<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>