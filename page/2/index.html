<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>蓝翔技工(blueflylabor)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="blueflylabor">
<meta property="og:type" content="website">
<meta property="og:title" content="蓝翔技工(blueflylabor)">
<meta property="og:url" content="http://blueflylabor.github.io/page/2/index.html">
<meta property="og:site_name" content="蓝翔技工(blueflylabor)">
<meta property="og:description" content="blueflylabor">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="蓝翔技工">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="蓝翔技工(blueflylabor)" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">蓝翔技工(blueflylabor)</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blueflylabor.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-计算机组成原理中央处理器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T04:01:51.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/">计算机组成原理中央处理器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="中央处理器"><a href="#中央处理器" class="headerlink" title="中央处理器"></a>中央处理器</h1><p>控制器：负责协调并控制计算机各部件执行程序的指令序列：取指令、分析指令、执行指令<br>运算器：对数据加工</p>
<ul>
<li>指令控制</li>
<li>操作控制</li>
<li>数据加工</li>
<li>时间控制</li>
<li>中断处理</li>
</ul>
<h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p>运算器和控制器两大部分组成<br>运算器：</p>
<ul>
<li>算术逻辑单元（ALU）</li>
<li>暂存寄存器</li>
<li>累加寄存器（ACC）</li>
<li>通用寄存器组（AX&#x2F;BX&#x2F;CX&#x2F;DX&#x2F;SP）</li>
<li>程序状态字寄存器（PSW：OF&#x2F;SF&#x2F;ZF&#x2F;CF）</li>
<li>移位器</li>
<li>计数器</li>
</ul>
<p>控制器（CU）：</p>
<ul>
<li>程序计数器（PC）</li>
<li>指令寄存器（IR）</li>
<li>指令译码器</li>
<li>存储器地址寄存器</li>
<li>存储器数据寄存器</li>
<li>时序系统</li>
<li>微操作信号发生器</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><h3 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h3><p>CPU从主存取出并执行一条指令的时间，指令周期通常使用若干机器周期表示，每个机器周期可等长或不等，一个机器周期包含若干时钟周期（节拍），每个机器周期内的时钟周期数可以不等</p>
<ul>
<li>无条件转移指令：执行阶段不需要访存，只包含取指阶段（取指和分析）和执行阶段</li>
<li>间接寻址指令：为了取操作数，需要先访1次，取出有效地址，然后访存，取出操作数，所有需要包含间址周期，介于取指和执行之间</li>
<li>CPU采用中断方式实现主机和I&#x2F;O设备的信息交换，CPU在每条指令结束前，都要发送中断查询信号，若有中断请求，CPU进入中断响应阶段（中断周期）</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>取指周期</td>
<td>间址周期</td>
<td>执行周期</td>
<td>中断周期</td>
</tr>
</tbody></table>
<p>只有访存的目的不同，取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点<br>CPU内设置了4个标志触发器FE&#x2F;IND&#x2F;EX&#x2F;INT</p>
<table>
<thead>
<tr>
<th>FE</th>
<th>IND</th>
<th>EX</th>
<th>INT</th>
</tr>
</thead>
<tbody><tr>
<td>Fetch</td>
<td>Index</td>
<td>Execute</td>
<td>Interrupt</td>
</tr>
<tr>
<td>取值</td>
<td>间址</td>
<td>执行</td>
<td>中断</td>
</tr>
</tbody></table>
<h3 id="指令周期的数据流"><a href="#指令周期的数据流" class="headerlink" title="指令周期的数据流"></a>指令周期的数据流</h3><h4 id="取指周期"><a href="#取指周期" class="headerlink" title="取指周期"></a>取指周期</h4><p>根据PC中的内容从主存取出指令代码放入IR  </p>
<ul>
<li>PC $\to$ IR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\to$ DataBus $\to$ MDR $\to$ Mem</li>
<li>Mem $\to$ DataBus $\to$ MDR $\to$ IR（存放指令）</li>
<li>CU $\stackrel{SignalControl::FE}{\longrightarrow}$ [(PC) + 1 $\to$ PC]</li>
</ul>
<h4 id="间址周期"><a href="#间址周期" class="headerlink" title="间址周期"></a>间址周期</h4><p>取操作数有效地址，间址为例：指令中的地址码送到MAR并送至地址总线，CU向存储器发送读命令，以获取有效地址并存在MDR  </p>
<ul>
<li>Addr(IR) &#x2F; MDR $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI&#x2F;O::READ}{\longrightarrow}$ ControlBus $\to$ Mem（存放有效地址）</li>
<li>Mem $\to$ DataBus $\to$ MDR</li>
</ul>
<h4 id="执行周期"><a href="#执行周期" class="headerlink" title="执行周期"></a>执行周期</h4><p>取操作数，根据IR的指令字的操作码通过ALU操作产生执行结果</p>
<ul>
<li>无统一的数据流向</li>
</ul>
<h4 id="中断周期"><a href="#中断周期" class="headerlink" title="中断周期"></a>中断周期</h4><p>处理中断请求，假设程序断点存入堆栈，用SP指示栈顶地址，入栈操作是先修改栈顶指针，后存入数据</p>
<ul>
<li>CU $\stackrel{SignalStack::SP}{\longrightarrow}$ [(SP) - 1 $\to$ SP] $\to$ MAR $\to$ AddrBus $\to$ Mem</li>
<li>CU $\stackrel{SignalI&#x2F;O::WRITE}{\longrightarrow}$ ControlBus $\to$ Mem</li>
<li>PC $\to$ MDR $\to$ DataBus $\to$ Mem（程序断点存入主存）</li>
<li>CU $\to$ PC（中断服务程序的入口地址送至PC）</li>
</ul>
<h3 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h3><ul>
<li>单指令周期</li>
<li>多指令周期</li>
<li>流水线方案</li>
</ul>
<h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>数据通路：数据在功能部件之间传输的路径<br>由控制部件控制，控制部件根据每条指令功能的不同生成对数据通路的控制信号<br>数据通路功能：实现CPU内部的运算器与寄存器以及寄存器之间的数据交换</p>
<h3 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h3><ul>
<li>CPU内部单总线模式<br>所有寄存器的输入输出端都连接在一条公共通路上，结构简单但数据传输存在较多的冲突现象，性能较低。连接各部件的总线只有一条时，称为单总线结构，CPU中有两条或更多的总线时，构成双总线结构或多总线结构</li>
<li>CPU内部多总线模式<br>所有寄存器的输入输出端都连接在多条公共通路上，相比之下单总线在一个时钟内只允许传一个数据，因此指令执行效率很低，因此在多总线方式，同时在多总线上传输不同的数据，提高效率</li>
<li>专用数据通路方式<br>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大</li>
</ul>
<h4 id="寄存器之间的数据传输"><a href="#寄存器之间的数据传输" class="headerlink" title="寄存器之间的数据传输"></a>寄存器之间的数据传输</h4><p>通过内部总线完成<br>寄存器AX的输入输出由AXout和AXin控制  </p>
<ul>
<li>(PC) $\to$ MAR，PCout和MARin有效</li>
</ul>
<h4 id="主存与CPU之间的数据传输"><a href="#主存与CPU之间的数据传输" class="headerlink" title="主存与CPU之间的数据传输"></a>主存与CPU之间的数据传输</h4><p>主存与CPU之间的数据传输需要借助CPU内部总线完成<br>主存内读取</p>
<ul>
<li>(PC) $\to$ MAR，PCout和MARin有效  </li>
<li>1 $\to$ R，CU发出读命令  </li>
<li>MEM(MAR) $\to$ MDR，MDRin有效  </li>
<li>(MDR) $\to$ IR，MDRout和IRin有效</li>
</ul>
<h4 id="执行算术或逻辑算术"><a href="#执行算术或逻辑算术" class="headerlink" title="执行算术或逻辑算术"></a>执行算术或逻辑算术</h4><p>由于ALU没有内部存储功能，执行加法操作，相加的两个数必须在ALU的两个输入输出端同时有效</p>
<ul>
<li>(MDR) $\to$ MAR，MDRout和MARin有效  </li>
<li>1 $\to$ R，CU读命令</li>
<li>MEM(MAR) $\to$ 操作数从主存送至MDR</li>
<li>(MDR) $\to$ Y，MDRout和Yin有效</li>
<li>(ACC) + (Y) $\to$ Z ACCout和ALUin有效</li>
<li>(Z) $\to$ ACC，Zout和ACCin有效</li>
</ul>
<h2 id="控制器功能与原理"><a href="#控制器功能与原理" class="headerlink" title="控制器功能与原理"></a>控制器功能与原理</h2><h3 id="结构和功能"><a href="#结构和功能" class="headerlink" title="结构和功能"></a>结构和功能</h3><ul>
<li>运算器部件通过数据总线与内存储器、输入设备和输出设备传送数据</li>
<li>输入设备和输出设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备通过接口电路与总线相连接</li>
<li>内存储器、输入设备和输出设备从地址总线接收地址信息，从控制总线得到控制信号，通过数据总线与其他部件传输数据</li>
<li>控制器部件从数据总线接受指令信息，从运算器部件接收指令转移地址，送出指令地址到地址总线，还要向系统中的部件通过运算所需的控制信号</li>
</ul>
<p>控制器功能：</p>
<ul>
<li>从主存取指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、主存、输入输出设备之间的数据流动方向</li>
</ul>
<p>根据控制器产生微操作控制信号的方式不同，控制器可分为</p>
<ul>
<li>硬布线控制器</li>
<li>微程序控制器</li>
</ul>
<p>两类控制器的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制部件各部件运算所需控制信号的方案不同</p>
<h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><ul>
<li>根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号</li>
<li>由复杂的组合逻辑门电路和一些触发器构成</li>
</ul>
<h4 id="硬布线控制单元"><a href="#硬布线控制单元" class="headerlink" title="硬布线控制单元"></a>硬布线控制单元</h4><p>指令的操作码是决定控制单元发出不同操作命令（控制信号）的关键<br>CU的输入信号来源：</p>
<ul>
<li>经指令译码器译码产生的信息指令</li>
<li>时序系统产生的机器周期信号和节拍信号</li>
<li>来自执行单元的反馈信号（标志）</li>
<li>系统总线（控制总线）控制信号（中断请求、DMA请求）</li>
</ul>
<h4 id="硬布线控制器的时序系统及微操作"><a href="#硬布线控制器的时序系统及微操作" class="headerlink" title="硬布线控制器的时序系统及微操作"></a>硬布线控制器的时序系统及微操作</h4><ul>
<li>时钟周期<br>用时钟信号控制节拍发生器，可以产生节拍，每个节拍的宽度对应一个时钟周期，每个节拍内机器可以完成一个或几个需要同时执行的操作</li>
<li>机器周期<br>是所有指令执行过程的一个基准时间，访问一次存储器的时间是固定的，因此通常以存取周期作为基准时间，即内存中读取一个指令字的最短时间作为机器周期，在存储字长等于指令字长前提下，取指周期视为机器周期</li>
<li>指令周期</li>
<li>微操作命令分析<br>控制单元具有发出各种操作命令（控制信号）序列的功能，这些命令与指令有关</li>
</ul>
<p>执行过程，一条指令分为3个工作周期：取指周期、间址周期、执行周期  </p>
<p>取指周期  </p>
<ul>
<li>(PC) $\to$ MAR  </li>
<li>1 $\to$ R  </li>
<li>M(MAR) $\to$ MDR</li>
<li>(MDR) $\to$ IR</li>
<li>OP(IR) $\to$ CU</li>
<li>(PC) + 1  $\to$ PC</li>
</ul>
<p>间址周期</p>
<ul>
<li>Addr(IR) $\to$ MAR</li>
<li>1  $\to$ R</li>
<li>M(MAR)  $\to$ MDR</li>
</ul>
<p>执行周期  </p>
<ul>
<li>非访存指令  </li>
<li>访存指令</li>
</ul>
<h4 id="CPU控制方式"><a href="#CPU控制方式" class="headerlink" title="CPU控制方式"></a>CPU控制方式</h4><ul>
<li>同步控制方式<br>具有统一的时钟，所有控制信号均来自统一的时钟信号</li>
<li>异步控制方式<br>不存在基准时标信号，各部件按自身固有的速度工作，以应答方式联络</li>
<li>联合控制方式<br>大部分采用同步控制，小部分采用异步控制</li>
</ul>
<h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>采用存储逻辑实现,把微操作信号代码化,使每条机器指令转化为一段微程序并存入一个专门的存储器（控制存储器），微操作控制信号由微指令产生</p>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>微操作和微命令<br>一条机器指令可以分解为一系列微操作序列，微操作是计算机中最基本、不可再分解的操作；微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为微命令，是构成控制系列的最小单位<br>微命令有相容性和互斥性</p>
</li>
<li><p>微指令和微周期<br>微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为微地址<br>一条微地址包括：<br>（1）操作控制字段（微操作码）：用于产生某一步操作所需的各种操作控制信号<br>（2）顺序控制字段（微地址码）：用于控制产生下一条要执行的微指令地址<br>微周期是执行一条微指令所需的时间，通常为一个时钟周期  </p>
</li>
<li><p>主存储器和控制存储器<br>主存储器M，用于存放程序和数据，在CPU外部，用RAM实现<br>控制存储器CM，用于存放微程序，在CPU内部，用ROM实现</p>
</li>
<li><p>程序和微程序<br>程序是指令的有序集合，用于完成某些特定的功能<br>微程序是微指令的有序集合，一条指令的给你由一段微程序实现<br>微程序和程序是两个不同的概念，微程序由微指令组成，描述机器指令，微程序实质是机器指令的实时解释器，由计算机设计者实现编制并存放于控制存储器CM中，无需知道，而程序最终由机器指令组成，由软件设计人员事先编制并存放于主存储器或辅助存储器</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>MAR</td>
<td>存放主存的读写地址</td>
<td>CMAR</td>
<td>存放控制存储器的读写微指令地址</td>
</tr>
<tr>
<td>IR</td>
<td>存放从主存中读出的指令</td>
<td>CMDR&#x2F;$\mu$IR</td>
<td>存放控制存储器中读出的微指令</td>
</tr>
</tbody></table>
<h4 id="组成-过程"><a href="#组成-过程" class="headerlink" title="组成&amp;过程"></a>组成&amp;过程</h4><ul>
<li>控制存储器：存放各指令对应的微程序</li>
<li>微指令寄存器：用于存放从CM中取出的微指令，位数同微指令字长相等</li>
<li>微地址形成部件：产生初始微地址和后继微地址，以保证微指令的连续执行</li>
<li>微地址寄存器：接收微地址形成部件送来的微地址，为在CM中读取微指令作准备</li>
</ul>
<p>在微程序控制器的控制下计算器执行机器指令的过程：  </p>
<ul>
<li>执行取微指令：自动将取指微程序的入口地址送入CMAR，从CM中读取相应的微指令送入CMDR（取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完成，从主存取出的机器指令就已经存入指令寄存器中）</li>
<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令对应的微程序入口地址，并送入CMAR</li>
<li>从CM中逐条读取对应的微指令并执行</li>
<li>执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第一步</li>
</ul>
<p>微程序和机器指令：<br>一条机器指令对应一个微程序，由于机器指令的取指令操作都是相同的，因此可将取指令操作的微命令统一编制为一个微程序，这个微程序只负责将指令从主存单元取出送入指令寄存器，也可编制对应的间址周期和中断周期的微程序<br>控制存储器CM中的微程序个数 &#x3D; 机器指令数+取指+间址+中断</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p>又称微指令的控制方式，如何对微指令的控制字段进行编码，以形成控制信号  </p>
<ul>
<li><p>直接编码（直接控制）<br>无需进行译码，微指令的微命令字段中每位代表一个微命令，设计微指令，选用某个微命令只需将微命令对应的字段设置为1或0<br>优：简单直观速度快<br>缺：微指令字长过长，n个微命令要求微指令的操作字段有n位，造成控制存储器容量极大</p>
</li>
<li><p>字段直接编码<br>将微指令的微命令字段分成若干小字段，互斥性微命令组合在同一字段，相容性微命令组合在不同字段，每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关<br>优:可以缩短微指令字长<br>缺：需要通过编译电路后发出微命令，较直接编译慢</p>
</li>
</ul>
<h4 id="地址形成方式"><a href="#地址形成方式" class="headerlink" title="地址形成方式"></a>地址形成方式</h4><ul>
<li>直接由微指令的下地址字段指出，微指令格式中设置一个下地址字段，由微指令的下地址字段直接指出后继微指令的地址（断定方式）</li>
<li>根据机器指令的操作码形成，机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成</li>
<li>增量计算器法：(CMAR) + 1 $\to$ CMAR</li>
<li>根据各种标志决定微指令分支转移地址</li>
<li>通过测试网络形成</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul>
<li>水平型：直接编码、字段直接编码、字段间接编码、混合编码</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>$A_1$</td>
<td>$A_2$</td>
<td>$\dots$</td>
<td>$A_{n-1}$</td>
<td>$A_{n}$</td>
<td>判断测试字段</td>
<td>后继地址字段</td>
</tr>
<tr>
<td>操作控制</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>顺序控制</td>
<td></td>
</tr>
</tbody></table>
<p>优：微程序短，执行速快<br>缺：微指令长，编写微程序复杂  </p>
<ul>
<li>垂直型：采用类似机器指令操作码的方式，在微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能</li>
</ul>
<table>
<thead>
<tr>
<th>$\mu$OP</th>
<th>Rd</th>
<th>Rs</th>
</tr>
</thead>
<tbody><tr>
<td>微操作码</td>
<td>目的地址</td>
<td>源地址</td>
</tr>
</tbody></table>
<p>优：微指令短、简单、规整，便于编写微程序<br>缺：微程序长，执行速度慢，工作效率低  </p>
<ul>
<li>混合型<br>在垂直型的基础上增加一些不太复杂的并行操作</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>水平型</th>
<th>垂直型</th>
</tr>
</thead>
<tbody><tr>
<td>并行能力</td>
<td>并行能力强、灵活性高、效率高</td>
<td>较差</td>
</tr>
<tr>
<td>执行时间</td>
<td>短</td>
<td>长</td>
</tr>
<tr>
<td>长度</td>
<td>微指令字较长，微程序较短</td>
<td>微指令字较短，微程序较长</td>
</tr>
<tr>
<td>难易程度</td>
<td>难</td>
<td>易</td>
</tr>
</tbody></table>
<h4 id="动态微程序设计和毫微程序设计"><a href="#动态微程序设计和毫微程序设计" class="headerlink" title="动态微程序设计和毫微程序设计"></a>动态微程序设计和毫微程序设计</h4><ul>
<li><p>动态微程序设计：根据用户的要求改变微程序，需要可写控制寄存器，使用EPROM</p>
</li>
<li><p>毫微程序设计：硬件不由微程序直接控制，通过存放在第二级控制存储器中的毫微程序来解释</p>
</li>
</ul>
<h4 id="微程序控制器和硬布线控制器比较"><a href="#微程序控制器和硬布线控制器比较" class="headerlink" title="微程序控制器和硬布线控制器比较"></a>微程序控制器和硬布线控制器比较</h4><table>
<thead>
<tr>
<th></th>
<th>微程序控制器</th>
<th>硬布线控制器</th>
</tr>
</thead>
<tbody><tr>
<td>工作原理</td>
<td>微操作控制信号以微程序的形式存放在控制存储器中，执行指令时读出即可</td>
<td>微操作控制信号由组合逻辑电路根据当前的指令码、状态和时序，即时产生</td>
</tr>
<tr>
<td>执行速度</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>规整性</td>
<td>较规整</td>
<td>烦琐、不规整</td>
</tr>
<tr>
<td>应用场合</td>
<td>CISC CPU</td>
<td>RISC CPU</td>
</tr>
<tr>
<td>易扩充性</td>
<td>容易</td>
<td>困难</td>
</tr>
</tbody></table>
<h3 id="异常（内中断）和中断"><a href="#异常（内中断）和中断" class="headerlink" title="异常（内中断）和中断"></a>异常（内中断）和中断</h3><p>异常是由CPU内部产生的意外事件，分为硬故障中断和程序性异常<br>硬故障中断：是由硬连线出现异常引起（存储器校验异常、总线错误）<br>程序性异常（软件中断）：CPU内部因执行指令而引起的（整除0、溢出、断点、单步跟踪、非法指令）<br>按照异常发生的原因和返回方式，可进一步分为故障、自陷、终止</p>
<ul>
<li><p>故障（Fault）<br>引起故障的指令启动后、执行结束前被检测到的异常，因为无法通过异常处理程序恢复故障，因此不能回到原断点处执行，必须终止进程的执行  </p>
</li>
<li><p>自陷（Trap）<br>事先安排的一种异常事件，事先在程序中用一条特殊指令或通过某种方式设定特殊控制标志人为设置一个陷阱，当执行到被设置了陷阱的指令时，CPU在执行陷阱指令后，自动根据不同的陷阱类型进行相应的处理，然后返回到自陷程序下一条指令执行。当自陷指令是转移指令时，并不是返回到下一条指令执行，而不是返回到转移目标指令执行</p>
</li>
<li><p>终止（Abort）<br>如果在执行指令的过程中发生了使计算机无法继续执行的硬件故障，程序将无法继续执行，只能终止，此时调出中断服务程序来重启系统，终止异常和外中断属于硬件中断</p>
</li>
</ul>
<p>中断是来自CPU外部、与CPU执行指令无关的事件引起的中断<br>中断的分类：</p>
<ul>
<li><p>可屏蔽中断<br>通过可屏蔽中断请求线INTR向CPU发出中断请求，CPU可通过设置相应的屏蔽字来屏蔽或不屏蔽某个中断</p>
</li>
<li><p>不可屏蔽中断<br>通过专门的不可屏蔽中断请求NMI向CPU发出的中断请求，通常是非常紧急的硬件故障</p>
</li>
</ul>
<p>中断和异常的不同：  </p>
<ul>
<li><p>缺页或溢出等异常事件是由特定指令在执行过程中产生的，而中断不和任何指令相关联，也不阻止任何指令的完成  </p>
</li>
<li><p>异常的检测由CPU完成，不通过外部的某个信号通知CPU，中断CPU必须通过中断请求线获取中断源信息，才能知道哪个设备发生了何种中断</p>
</li>
</ul>
<h3 id="异常和中断响应过程"><a href="#异常和中断响应过程" class="headerlink" title="异常和中断响应过程"></a>异常和中断响应过程</h3><ul>
<li>关中断</li>
<li>保存断点和程序状态</li>
<li>识别异常和中断并转到相应的处理程序（软件识别和硬件识别）</li>
</ul>
<p>软件识别：CPU设置一个异常状态寄存器，用于记录异常原因，操作系统使用一个统一的异常和中断查询程序，按优先级顺序查询异常状态寄存器，以检查异常和中断类型，先查询到的先处理，然后转到内核中相应的处理程序</p>
<p>硬件识别（向量中断）：异常或中断处理程序的首地址称为中断向量，所有中断向量都存放于中断向量表中，每个异常或中断都被指定一个中断类型号，在中断向量表内，类型号和中断向量一一对应</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>从两方面提高处理机的并行性：  </p>
<ul>
<li>时间并行：流水线技术</li>
<li>空间并行：超标量处理机</li>
</ul>
<h3 id="指令流水的定义"><a href="#指令流水的定义" class="headerlink" title="指令流水的定义"></a>指令流水的定义</h3><p>一条指令的执行过程分解为几个阶段，每个阶段由相应的功能部件完成</p>
<ul>
<li>取指IF</li>
<li>译码&#x2F;读寄存器ID</li>
<li>执行&#x2F;计算地址EX</li>
<li>访存MEM</li>
<li>写回WB</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/" data-id="clyoz625e000fgadqchcz4vae" data-title="计算机组成原理中央处理器" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理数据表示与运算" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T04:01:51.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/">计算机组成原理数据表示与运算</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据表示和运算"><a href="#数据表示和运算" class="headerlink" title="数据表示和运算"></a>数据表示和运算</h1><h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><ul>
<li><strong>r进制</strong><br> $K_{n} K_{n-1} K_{n-2} \dots K_{0} K_{-1} \dots K_{-m}$<br>数值表示 $K_{n} r^{n} + K_{n-1} r^{n-1} + \dots + K_{0} r^{0} + K_{-1} r^{-1} + \dots + K_{-m} r^{-m} &#x3D; \sum_{i&#x3D;n}^{-m} K_{i} r^{i}$</li>
<li>二进制<br>$01 \space r&#x3D;2$</li>
<li>八进制<br>$01234567 \space r&#x3D;8&#x3D;2^3$</li>
<li>十六进制<br>$0123456789ABCDEF \space r&#x3D;16&#x3D;2^4$</li>
</ul>
<h2 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h2><p>4位二进制数码与1位十六进制数码相对应<br>3位二进制数码与1位八进制数码相对应  </p>
<h2 id="原反补移"><a href="#原反补移" class="headerlink" title="原反补移"></a>原反补移</h2><ul>
<li><p>原码</p>
</li>
<li><p>反码</p>
</li>
<li><p>补码</p>
</li>
<li><p>移码</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E4%B8%8E%E8%BF%90%E7%AE%97/" data-id="clyoz625l000ggadqbxvzg5xl" data-title="计算机组成原理数据表示与运算" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-计算机组成原理虚拟存储器页式段式和段页式" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/" class="article-date">
  <time class="dt-published" datetime="2019-10-06T04:01:51.000Z" itemprop="datePublished">2019-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/">计算机组成原理虚拟存储器页式段式和段页式</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="虚拟存储器·页式·段式·段页式"><a href="#虚拟存储器·页式·段式·段页式" class="headerlink" title="虚拟存储器·页式·段式·段页式"></a>虚拟存储器·页式·段式·段页式</h1><p>主存和辅存共同构成了虚拟存储器，在硬件和系统软件的共同管理下工作。对于程序员而言，虚拟存储器是透明的，将主存和辅存的地址空间统一编址<br>用户编程允许涉及的地址称为虚地址或逻辑地址，虚拟地址对应的是存储空间称为虚拟空间<br>实际的主存单元地址称为实地址或物理地址，实地址对应的存储空间称为主存地址空间或实地址空间</p>
<ul>
<li>实地址 &#x3D; 主存页号 + 页内字地址</li>
<li>虚地址 &#x3D; 虚存页号 + 页内字地址</li>
<li>辅存地址 &#x3D; 磁盘号 + 盘面号 + 磁道号 + 扇区号</li>
</ul>
<p>CPU使用虚地址访存，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元是否已装入内存</p>
<ul>
<li>在内存，通过地址变换，CPU可直接访问主存指示的数据单元</li>
<li>不在内存，则把包含这个 字的一页或一段调入主存后，在通过虚实地址变换访问</li>
</ul>
<h2 id="页式虚拟存储器"><a href="#页式虚拟存储器" class="headerlink" title="页式虚拟存储器"></a>页式虚拟存储器</h2><p>以页为基本单位，虚拟空间与主存空间划分为同样大小的页，主存的页称为<strong>实页</strong>、<strong>页框</strong>，虚存的页称为<strong>虚页</strong>  </p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表是一张存储在主存中的虚页号和实页号对照表，记录程序的虚页调入主存时被安排在主存中的位置，页表一般长期存在于主存内</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>有效位</td>
<td>脏位</td>
<td>引用位</td>
<td>物理页</td>
</tr>
</tbody></table>
<ul>
<li>有效位（装入位）：表示对应页是否在主存</li>
<li>脏位（修改位）：表示页面是否被修改过，配合回写策略，判断是否需要写回磁盘</li>
<li>引用位（使用位）：配合替换算法进行设置</li>
</ul>
<p>CPU运行指令时，虚地址转实地址：</p>
<ul>
<li>页表基址寄存器存放进程的页表首地址</li>
<li>根据虚拟地址高位部分的虚拟页号找到相应的页表项</li>
<li>装入位为1，则取出物理页号和虚拟地址地位进行拼接，形成实际物理地址</li>
<li>装入位为0，说明缺页，需要操作系统进行缺页处理</li>
</ul>
<h3 id="快表-TLB"><a href="#快表-TLB" class="headerlink" title="快表(TLB)"></a>快表(TLB)</h3><p>高速缓存器制成，依据程序的局部性原理，内存中的页表称之为慢表，地址转换时，先查快表，命中无需访问主存中的页表<br>快表通常采用组相联或全相联方式</p>
<table>
<thead>
<tr>
<th>t</th>
<th>r</th>
<th>p</th>
</tr>
</thead>
<tbody><tr>
<td>标记</td>
<td>有效位</td>
<td>实页号</td>
</tr>
</tbody></table>
<h3 id="具有TLB和Cache的多级存储系统"><a href="#具有TLB和Cache的多级存储系统" class="headerlink" title="具有TLB和Cache的多级存储系统"></a>具有TLB和Cache的多级存储系统</h3><p>三种缺失的情况  </p>
<table>
<thead>
<tr>
<th></th>
<th>TLB</th>
<th>Page</th>
<th>Cache</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>命中</td>
<td>命中</td>
<td>命中</td>
<td>TLB命中则Page一定命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>2</td>
<td>命中</td>
<td>命中</td>
<td>缺失</td>
<td>TLB命中则Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>3</td>
<td>缺失</td>
<td>命中</td>
<td>命中</td>
<td>TLB缺失但Page可能命中，信息在主存，就可能在Cache</td>
</tr>
<tr>
<td>4</td>
<td>缺失</td>
<td>命中</td>
<td>缺失</td>
<td>TLB缺失但Page一定命中，信息在主存，也可能不在Cache</td>
</tr>
<tr>
<td>5</td>
<td>缺失</td>
<td>缺失</td>
<td>缺失</td>
<td>TLB缺失则Page也可能缺失，信息不在主存，也一定不在Cache</td>
</tr>
</tbody></table>
<h2 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h2><p>按照程序的逻辑结构划分，将逻辑地址分为段号和段内地址，虚实地址转换是由段表来是实现的，段表是程序的逻辑段和在主存中存放位置的对照表</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>段首地址</td>
<td>装入位</td>
<td>段长</td>
</tr>
</tbody></table>
<p>CPU访存时：</p>
<ul>
<li>根据段号与段表基地址拼接成对应的段表行</li>
<li>根据段表行的装入位判断是否调入内存</li>
<li>调入内存，则从段表读出该段在主存的起始地址，与段内地址相加，得到对应的主存实地址</li>
</ul>
<h2 id="段页式虚拟存储器"><a href="#段页式虚拟存储器" class="headerlink" title="段页式虚拟存储器"></a>段页式虚拟存储器</h2><p>根据程序的逻辑结构，将每段划分为固定的大小页，主存空间也划分为大小相等的页，程序对主存调入、调出仍以页为基本传送单位<br>每个程序对应一个段表，每个段表对应一个页表，段的长度必须是页长的整数倍  </p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>段号</td>
<td>段内页号</td>
<td>页内地址</td>
</tr>
</tbody></table>
<p>CPU访存：</p>
<ul>
<li>根据段号得到段表地址</li>
<li>从段表中取出该段的页表起始地址，与虚地址段页号合成，得到页表地址</li>
<li>从页表中取出实页号，与页内地址拼接形成实地址</li>
</ul>
<h2 id="虚拟存储器与Cache的比较"><a href="#虚拟存储器与Cache的比较" class="headerlink" title="虚拟存储器与Cache的比较"></a>虚拟存储器与Cache的比较</h2><table>
<thead>
<tr>
<th>相同</th>
<th>不同</th>
</tr>
</thead>
<tbody><tr>
<td>目的均为提供系统性能</td>
<td>Cache主要解决系统速度，虚拟存储器解决主存容量</td>
</tr>
<tr>
<td>均把数据划分为小的信息块作为基本传递单位，虚存系统的信息块更大</td>
<td>Cache由硬件实现，对程序员透明，虚拟存储器由OS和硬件实现，是逻辑上的存储器，对系统程序员不透明，对应用程序员透明</td>
</tr>
<tr>
<td>都有地址的映射、替换算法、更新策略</td>
<td></td>
</tr>
<tr>
<td>均依据程序的局部性原理</td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2019/10/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E9%A1%B5%E5%BC%8F%E6%AE%B5%E5%BC%8F%E5%92%8C%E6%AE%B5%E9%A1%B5%E5%BC%8F/" data-id="clyoz625n000igadq3ogdasdx" data-title="计算机组成原理虚拟存储器页式段式和段页式" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构查找算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/">数据结构查找算法</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h2><h3 id="一般表"><a href="#一般表" class="headerlink" title="一般表"></a>一般表</h3><p>（1）代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="type">int</span> tableLen;</span><br><span class="line">&#125;SSTable;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">searchSeq</span><span class="params">(SSTable ST, ElemType key)</span></span>&#123;</span><br><span class="line">    ST.elem[e] = key;   <span class="comment">//设置哨兵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;ST.tableLen; i++)</span><br><span class="line">        <span class="keyword">return</span> i;   <span class="comment">//存在返回, 不存在返回1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）设置哨兵：可以不必判断是否越界，注意数据下表从1开始<br>（3）ASL<br>$$<br>如果不能知道查找概率，可先对记录的查找概率进行排序，是表中的记录按查找概率从小到大\<br>ASL_{success} &#x3D; \sum_{i&#x3D;1}^{n} P_i(n-i+1) &#x3D; \frac{n+1}{2}\<br>ASL_{unsuccess} &#x3D; n+1\<br>$$<br>（4）优缺点<br>优点：对数据的存储无要求，顺序存储或者链式存储皆可<br>缺点：当n较大，平均查找长度较大，效率低</p>
<h3 id="有序表"><a href="#有序表" class="headerlink" title="有序表"></a>有序表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id1((10))--id2((20))</span><br><span class="line">id1((10)).--infinity,10</span><br><span class="line">id2((20))--id3((30))</span><br><span class="line">id2((20)).--infinity,20</span><br><span class="line">id3((30))--id4((40))</span><br><span class="line">id3((30)).--infinity,30</span><br><span class="line">id4((40))--id5((50))</span><br><span class="line">id4((40)).--infinity,40</span><br><span class="line">id5((50))--id6((60))</span><br><span class="line">id5((50)).--infinity,50</span><br><span class="line">id6((60))--60,=</span><br><span class="line">id6((60)).--infinity,60</span><br></pre></td></tr></table></figure>
<p>（1）一旦查到某个元素大于该元素便停止查找<br>（2）方框是虚构的节点，查找长度&#x3D;方框上的圆环<br>（3)ASL<br>$$<br>ASL_{success} &#x3D; \sum_{i&#x3D;1}^{n} P_i(n-i+1) &#x3D; \frac{n+1}{2}\<br>ASL_{unsuccess} &#x3D; \sum_{j&#x3D;1}^{n} Q_j(l_j-1) &#x3D;  \frac{1+2+…+n+n}{n+1} &#x3D; \frac{n}{2} +  \frac{n}{n+1}\<br>$$</p>
<h3 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">id29((29))--id37((37))--id41((41))--id43((43))</span><br><span class="line">id43((43))--43,+infinity</span><br><span class="line">id43((43))--37,43</span><br><span class="line">id37((37))--id32((32))--id33((33))</span><br><span class="line">id32((32))--29,32</span><br><span class="line">id33((33))--33,37</span><br><span class="line">id33((33))--32,33</span><br><span class="line">id13((13))--id16((16))--id19((19))--19,29</span><br><span class="line">id19((19))--16,19</span><br><span class="line">id29((29))--id13((13))--id7((7))--id10((10))--10,13</span><br><span class="line">id10((10))--7,10</span><br><span class="line">id7((7))---infinity,7</span><br></pre></td></tr></table></figure>
<p>（1）仅适用于顺序表<br>（2）代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(SeqList L, ElemType key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid = <span class="number">0</span>, L.tableLen, <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(L.elem[mid] == key)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L.elem[mid]  key)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）ASL<br>$$<br>ASL &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^{n} l_i &#x3D; \frac{1}{n}(1<em>1+2</em>2+…+h*2^{h-1}) &#x3D; \frac{n+1}{n} log_2(n+1)-1 &#x3D; log_2(n+1)-1\<br>h&#x3D;[log_2(n+1)]（向上取整）<br>$$</p>
<h4 id="查找11"><a href="#查找11" class="headerlink" title="查找11"></a>查找11</h4><h5 id="low-7-high-43-mid-29"><a href="#low-7-high-43-mid-29" class="headerlink" title="low&#x3D;7, high&#x3D;43, mid&#x3D;29"></a>low&#x3D;7, high&#x3D;43, mid&#x3D;29</h5><h5 id="11"><a href="#11" class="headerlink" title="11&lt;29"></a>11&lt;29</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29--mid</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43--high</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-7-high-mid-1-19-mid-13"><a href="#low-7-high-mid-1-19-mid-13" class="headerlink" title="low&#x3D;7, high&#x3D;mid-1&#x3D;19, mid&#x3D;13"></a>low&#x3D;7, high&#x3D;mid-1&#x3D;19, mid&#x3D;13</h5><h5 id="11-1"><a href="#11-1" class="headerlink" title="11&lt;13"></a>11&lt;13</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low</span><br><span class="line">10</span><br><span class="line">13--mid</span><br><span class="line">16</span><br><span class="line">19--high</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="low-7-high-mid-1-7-mid-10"><a href="#low-7-high-mid-1-7-mid-10" class="headerlink" title="low&#x3D;7, high&#x3D;mid-1&#x3D;7, mid&#x3D;10"></a>low&#x3D;7, high&#x3D;mid-1&#x3D;7, mid&#x3D;10</h5><h5 id="117"><a href="#117" class="headerlink" title="117"></a>117</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7--low--mid</span><br><span class="line">10--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="low-mid-1-10-high-10-mid-10"><a href="#low-mid-1-10-high-10-mid-10" class="headerlink" title="low&#x3D;mid+1&#x3D;10, high&#x3D;10, mid&#x3D;10"></a>low&#x3D;mid+1&#x3D;10, high&#x3D;10, mid&#x3D;10</h5><h5 id="1010-×"><a href="#1010-×" class="headerlink" title="1010 ×"></a>1010 ×</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">7</span><br><span class="line">10--low--mid--high</span><br><span class="line">13</span><br><span class="line">16</span><br><span class="line">19</span><br><span class="line">29</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">37</span><br><span class="line">41</span><br><span class="line">43</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="没找到，停在low"><a href="#没找到，停在low" class="headerlink" title="没找到，停在low"></a>没找到，停在low</h5><h3 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h3><p>（1）将查找表分为若干子块，块内可以无序，但块之间有序的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">id24((24))--id((索引块24,54,78,88))</span><br><span class="line">id21((21))</span><br><span class="line">id6((6))</span><br><span class="line">id11((11))</span><br><span class="line">id8((8))</span><br><span class="line">id22((22))</span><br><span class="line">id32((32))--id((索引块24,54,78,88))</span><br><span class="line">id31((31))</span><br><span class="line">id54((54))</span><br><span class="line">id72((72))--id((索引块24,54,78,88))</span><br><span class="line">id61((61))</span><br><span class="line">id78((78))</span><br><span class="line">id88((88))--id((索引块24,54,78,88))</span><br><span class="line">id83((83))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）ASL<br>$$<br>n:长度\<br>b:分块个数\<br>s:每块s个记录\<br>P:等概率\<br>ASL &#x3D; L_I+L_S &#x3D; \frac{b+1}{2}+\frac{s+1}{2}&#x3D;\frac{s^2+2s+n}{2s}\<br>s&#x3D;\sqrt{n},ASL&#x3D;\sqrt{n}+1\<br>采用折半查找：ASL&#x3D;L_I+L_S&#x3D;[log_2(b+1)]+\frac{s+1}{2}（向上取整）<br>$$</p>
<p>###B树（多路平衡查找树）<br>$$<br>m阶B树或空树\<br>每棵子树至多m棵子树，最多包含m-1个关键字\<br>若根节点不是终端节点，至少两棵子树\<br>除根结点外所有非叶节点至少[\frac{m}{2}]（向上取整）棵子树（关键字）\<br>$$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph </span><br><span class="line">id[22]--id0[5,11]</span><br><span class="line">id[22]--id1[36,45]</span><br><span class="line">id0[5,11]--id00[1,3]</span><br><span class="line">id0[5,11]--id01[6,8,9]</span><br><span class="line">id0[5,11]--id02[13,15]</span><br><span class="line">id1[36,45]--id10[30,35]</span><br><span class="line">id1[36,45]--id11[40,42]</span><br><span class="line">id1[36,45]--id12[47,48,50,56]</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" data-id="clyoz62560005gadq9hurejtb" data-title="数据结构查找算法" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构基本概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">数据结构基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p> 数据结构的基本概念</p>
<p>  1.数据</p>
<p>  2.数据元素：</p>
<p>   数据的基本单位，一个数据元素可有若干个数据项构成，数据项是不可分割的最小单位</p>
<p>  3.数据类型</p>
<p>  4.抽象数据类型(ADT[Abstract Data Type]):</p>
<p>  数学模型在计算机的一种实现，包括数据对象、数据关系、基本操作，如建立一个有限状态机模型</p>
<p>  5.数据结构：数据元素之间的关系称之为结构，数据结构包括三方面：逻辑结构、存储结构、数据运算(程序&#x3D;算法+数据结构)</p>
<p>  6.逻辑结构：数据间的逻辑关系，与数据存储独立，分为线性结构和非线性结构</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">逻辑结构--线性结构</span><br><span class="line">逻辑结构--非线性结构</span><br><span class="line">线性结构--一般线性表</span><br><span class="line">线性结构--受限线性表</span><br><span class="line">线性结构--线性表推广</span><br><span class="line">受限线性表--栈和队列</span><br><span class="line">受限线性表--串</span><br><span class="line">线性表推广--数组</span><br><span class="line">线性表推广--广义表</span><br><span class="line">非线性结构--非线性表</span><br><span class="line">非线性表--集合</span><br><span class="line">非线性表--树形结构</span><br><span class="line">非线性表--图形结构</span><br><span class="line">树形结构--一般树</span><br><span class="line">树形结构--二叉树</span><br><span class="line">图形结构--有向图</span><br><span class="line">图形结构--无向图</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  7.物理结构：数据元素的表示以及关系的表示，主要有：顺序存储、链式存储、索引存储、散列存储</p>
<p>  8.算法评估</p>
<p>  （1）特性：有穷、确定、可行、输入、输出</p>
<p>  （2）时间复杂度：衡量算法随问题规模的增大，算法执行的时间增长的快慢</p>
<p>   T(n)&#x3D;O(f(n))，f(n)为算法运算频度，一般采用最坏情况下的时间复杂度</p>
<p>   计算方法：取算法时间增长最快的函数项，忽略其系数</p>
<p>   a加法规则：</p>
<pre><code>$$
T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(max(f(n),g(n)))
$$

多项式相加，只保留最高阶的项，且系数变为1
</code></pre>
<p>   b乘法规则：</p>
<pre><code>$$
T(n)=T_1(n)*T_2(n)=O(f(n))*O(g(n))=O(f(n)*g(n))
$$

多项式相乘，都保留
</code></pre>
<p>   从左到右性能依次降低：</p>
<pre><code>$$
O(1)&lt;O(log_2n)&lt;O(n)&lt;O(nlog_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)
$$
</code></pre>
<p>   单循环体型：</p>
<pre><code>例题1：计算下列程序的时间复杂度

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,sum	<span class="comment">//执行1次</span></span><br><span class="line">sum=<span class="number">0</span>	<span class="comment">//执行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)<span class="comment">//int i=0执行1次，i&lt;=n执行n+2次，i++执行n+1次</span></span><br><span class="line">	sum+=i;	<span class="comment">//执行n+1次</span></span><br></pre></td></tr></table></figure>

时间分析： 该算法执行了3n+6个语句。 假设每个语句执行时间一致，均为常数t。则总时间 
$$
T=(3n+6)*t
$$
随着问题规模n的增大，总时间的增长率与n的增长率一致，所以复杂度为
$$
O(n)
$$


结论： 

 复杂度是关于增长率的，所以可以直接忽视常数项

  一般可以直接关注循环段基本操作语句

  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum+=i;</span><br></pre></td></tr></table></figure>
 
  

 的执行次数
</code></pre>
<p>   例题2：</p>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum,i;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>;i &lt;= n;i=<span class="number">2</span>*i)&#123;</span><br><span class="line">	sum=sum+i;</span><br></pre></td></tr></table></figure>
<p>   时间分析：</p>
<p>   i 取值：1,2,4,8…<br>   满足条件：2^𝑘 ≤ n<br>   K𝑙𝑜𝑔_2𝑛时， 跳出循环<br>   所以循环体执行次数：⌈𝑙𝑜𝑔_2𝑛⌉ 故时间复杂度为O(logn).i 取值：1,2,4,8</p>
<p>  多循环体型</p>
<p>  两个运算法则：乘法规则（嵌套循环）、加法规则（若干循环）</p>
<p>  例题3：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x,y,i,j;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	x++;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">		y++;</span><br></pre></td></tr></table></figure>
<p>  两个循环体是独立的，采用加法规则：<br>  $$<br>  T(n)&#x3D;T_1(n)+T_2(n)<br>  $$</p>
<p>  $$<br>  &#x3D;max(T_1(n),T_2(n)) &#x3D;O(n^2)<br>  $$</p>
<p>  例题4：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i,j,sum;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j=<span class="number">2</span>*j)</span><br><span class="line">		sum=sum+j;</span><br></pre></td></tr></table></figure>
<p>  两个循环体是嵌套的，采用乘法规则：</p>
<p>  $$<br>  T(n)&#x3D;T_1(n)*T_2(n)<br>  $$</p>
<p>  $$<br>  &#x3D;O(nlogn)<br>  $$</p>
<p>  （3）空间复杂度：衡量算法随问题规模的增大，算法所需空间的快慢</p>
<p>   S(n)&#x3D;O(g(n))，算法所需空间的增长率和g(n)的增长率相同</p>
<p>   空间复杂度S(n)指算法运行过程中所使用的辅助空间的大小</p>
<p>线性表</p>
<p> 1.定义：线性表是具有相同数据类型的n个数据类型的有限序列，n为表长</p>
<p> 线性表中第一个元素称为表头元素，最后一个元素称为表位元素</p>
<p> 除第一个元素外，每个元素仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继</p>
<p>顺序存储</p>
<p>线性表的顺序存储又称顺序表</p>
<p>使用一组地址连续的存储单元(数组等)依次存储线性表的数据元素，从而使得逻辑相邻的两个元素在物理位置上也相邻</p>
<p>三个属性：</p>
<p> 1.存储空间的起始位置</p>
<p> 2.顺序表最大存储容量</p>
<p> 3.顺序表当前的长度</p>
<p>宏定义</p>
<p>静态分配大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Elemtype elem[MaxSize];</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>动态分配大小(这里动态指空间大小运行时决定，但分配大小后，空间大小被固定)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Elemtype</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">Elemtype *elem;</span><br><span class="line"><span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>

<p>优点：访问效率高、存储密度高</p>
<p>缺点：插入删除操作复杂</p>
<p>顺序存储线性表操作</p>
<p>1.初始化顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">initLinklist</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">	L.elem=<span class="keyword">new</span> Elemtype[MaxSize];</span><br><span class="line"><span class="keyword">if</span>(!L.elem)</span><br><span class="line">   <span class="built_in">exit</span>(OVERFLOWS);</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（1）创建一个顺序存储表后，需要初始化，首先根据数组大小通过new在堆空间开辟一段连续的空间赋值于先前创建的顺序存储表的elem空间</p>
<p>（2）检查elem是否存在，不存在溢出退出程序</p>
<p>（3）将length元素赋值为0，即设置顺序存储线性表长度为0</p>
<p>2.销毁顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroyList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.elem)</span><br><span class="line">   <span class="built_in">delete</span>(L.elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果线性表存在，删除线性表elem开辟的空间</p>
<p>3.清空顺序存储线性表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearList</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line">L.length=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将线性表的长度置为0</p>
<p>4.判断顺序存储线性表是否为空</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(SqList &amp;L)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(L.length==<span class="number">0</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断线性表长度是否为0，并返回相应bool值</p>
<p>5.引用类型按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i,type&amp;e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> e=L.elem[i<span class="number">-1</span>];</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）通过访问elem内数据存入引用类型变量内</p>
<p>6.按下表获取顺序存储线性表元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Elemtype <span class="title">getElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> <span class="keyword">return</span> L.elem[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）通过访问elem内数据并返回</p>
<p>7.引用类型按值查询顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e,<span class="type">int</span> &amp;i)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量赋值于引用类型下标变量</p>
<p>8.按值获取顺序存储线性表元素下标</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList L,Elemtype e)</span></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">     <span class="keyword">if</span>(L.elem[i]==e)</span><br><span class="line">         <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 按照elem开辟空间进行迭代，当迭代元素与目标元素值相等时，将迭代量返回</p>
<p>9.按下标插入元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listInsert</span><span class="params">(SqList &amp;L,type e,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(i&lt;<span class="number">1</span>||iL.length)</span><br><span class="line">     <span class="keyword">return</span> ERROR;</span><br><span class="line"> ++L.length;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=L.length<span class="number">-1</span>;j=i<span class="number">-1</span>;j--)</span><br><span class="line">     L.elem[j+<span class="number">1</span>]=L.elem[j];</span><br><span class="line"> L.elem[i<span class="number">-1</span>]=e;</span><br><span class="line"> <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）增加线性表长度</p>
<p> （3）按照目标元素位置，将其尾部元素后移1偏移量</p>
<p> （4）将目标元素存入下标位置</p>
<p> <strong>时间复杂度分析:</strong></p>
<p>  （1）<br>  $$<br>  最好情况：在表尾插入(即i&#x3D;n+1)<br>  $$</p>
<p>  $$<br>  元素后移语句执行的时间复杂度为O(1)<br>  $$</p>
<p>  （2）<br>  $$<br>  最坏情况：在表头插入(即i&#x3D;1)<br>  $$</p>
<p>  $$<br>  元素后移语句执行n次，时间复杂度为O(n)<br>  $$</p>
<p>  （3）<br>  $$<br>  平均情况：假设p_i(p_i&#x3D;1&#x2F;(n+1))<br>  $$</p>
<p>  $$<br>  是第i个位置上插入一个结点的概率<br>  $$</p>
<p>  $$<br>  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  f &#x3D; \sum_{i&#x3D;1}^{n+1}p_i(n-i-1)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\sum_{i&#x3D;1}^{n+1}{\frac{n+1}{n-i+1}}</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\frac{1}{n+1} \sum_{i&#x3D;1}^{n+1}(n-i-1)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  &#x3D;\frac{1}{n+1}\frac{n(n+2)}{2}&#x3D;\frac{n}{2}<br>  $$</p>
<p>  $$<br>  因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>  $$</p>
<p>10.按下标删除元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i  L.length))</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; i &lt;= L.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">		--L.length;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> （1）先检查传递参数下标量是否正确</p>
<p> （2）按照目标元素位置，将其头部元素前移1偏移量</p>
<p> （3）减少线性表长度</p>
<p> <strong>时间复杂度分析:</strong></p>
<p>  （1）<br>  $$<br>  最好情况：在表尾插入(即i&#x3D;n)<br>  $$</p>
<p>  $$<br>  无需移动元素，时间复杂度为O(1)<br>  $$</p>
<p>  （2）<br>  $$<br>  最坏情况：在表头插入(即i&#x3D;1)<br>  $$</p>
<p>  $$<br>  需移动除第一个元素外的所有元素，时间复杂度为O(n)<br>  $$</p>
<p>  （3）<br>  $$<br>  平均情况：假设p_i(p_i&#x3D;1&#x2F;(n+1))<br>  $$</p>
<p>  $$<br>  是第i个位置上插入一个结点的概率<br>  $$</p>
<p>  $$<br>  则在长度为n的线性表中插入一个节点是需要移动结点的平均次数为<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  f &#x3D; \sum_{i&#x3D;1}^{n}p_i(n-i)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\sum_{i&#x3D;1}^{n}{\frac{n}{n-i}}</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  \begin{equation*}</p>
<p>  &#x3D;\frac{1}{n} \sum_{i&#x3D;1}^{n}(n-i)</p>
<p>  \end{equation*}<br>  $$</p>
<p>  $$<br>  &#x3D;\frac{1}{n}\frac{n(n-1)}{2}&#x3D;\frac{n-1}{2}<br>  $$</p>
<p>  $$<br>  因此顺序存储线性表的插入算法平均时间复杂度为O(n)<br>  $$</p>
<p>11.创建顺序存储线性表</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	type e;</span><br><span class="line">	L.length = n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Please in put an element:&quot;</span>;</span><br><span class="line">		cin  e;</span><br><span class="line">		L.elem[i] = e;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.打印顺序存储线性表内元素</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(SqList L)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\nList&#x27;s element：\n&quot;</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;elem[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] =&quot;</span> &lt;&lt; L.elem[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" data-id="clyoz62570006gadq2lsp8w6y" data-title="数据结构基本概念" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构栈和队列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">数据结构栈和队列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><ul>
<li>栈(Stack)：只允许在一端插入或删除的线性表</li>
<li>栈顶：线性表允许进行插入或删除的那一端</li>
<li>栈底：固定的，不允许进行插入和删除的另一端</li>
<li>特点：是受限的线性表，拥有线性关系；后进先出<strong>LIFO</strong></li>
</ul>
<h1 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h1><ul>
<li>使用顺序存储，自底向上存储数据元素，指针指向栈顶元素的位置</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.top = <span class="number">-1</span>;             <span class="comment">//判空</span></span><br><span class="line">s.data[++s.top] = x;    <span class="comment">//进栈</span></span><br><span class="line">x = s.data[s.top--];    <span class="comment">//出栈</span></span><br><span class="line">x = s.data[s.top];      <span class="comment">//读取栈顶元素</span></span><br></pre></td></tr></table></figure>

<h1 id="共享栈"><a href="#共享栈" class="headerlink" title="共享栈"></a>共享栈</h1><ul>
<li>两个栈共享一个一维数组空间</li>
<li>两个栈分别设置在共享空间两端</li>
<li>栈顶指向中间延伸位置</li>
<li>有利于空间使用</li>
</ul>
<h1 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h1><ul>
<li>采用链式存储</li>
<li>便于多个栈共享存储空间</li>
<li>效率高</li>
</ul>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><ul>
<li>允许在一端插入，另一端删除的线性表</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>先进先出<strong>FIFO</strong></li>
</ul>
<h1 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h1><ul>
<li>连续的存储单元</li>
<li>头指针指向队头元素</li>
<li>尾指针指向队尾元素</li>
</ul>
<h1 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h1><ul>
<li>首尾相连的顺序存储的队列</li>
<li>操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q.rear = Q.front = <span class="number">0</span>;                           <span class="comment">// 初始化</span></span><br><span class="line">rear = (rear + <span class="number">1</span>) % MaxSize;                    <span class="comment">// 入队</span></span><br><span class="line">front = (front + <span class="number">1</span>) % MaxSize;                  <span class="comment">// 出队</span></span><br><span class="line">queueLen = (rear + MaxSize - front) % MaxSize;  <span class="comment">// 队列长度</span></span><br></pre></td></tr></table></figure>

<ul>
<li>判断空队列或满队列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用一个单元区分队空或队满</span></span><br><span class="line">(Q.rear + <span class="number">1</span>) % MaxSize = Q.front;   <span class="comment">//</span></span><br><span class="line">Q.front = Q.rear;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 类型中增加表示个数的数据成员</span></span><br><span class="line">Q.size = <span class="number">0</span>;                         <span class="comment">//</span></span><br><span class="line">Q.size = MaxSize;                   <span class="comment">//</span></span><br><span class="line"><span class="comment">// 增加tag成员</span></span><br><span class="line">tag = <span class="number">0</span>;                            <span class="comment">//</span></span><br><span class="line">tag = <span class="number">1</span>;                            <span class="comment">//</span></span><br></pre></td></tr></table></figure>

<h1 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h1><h1 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h1><ul>
<li>允许两端可以入队和出队</li>
<li>输出受限的双端队列：允许一端进行插入和删除，另一端只允许插入的双端队列</li>
<li>输入受限的双端队列：允许一端进行插入和删除，另一端只允许删除的双端队列</li>
</ul>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="栈在括号匹配的应用"><a href="#栈在括号匹配的应用" class="headerlink" title="栈在括号匹配的应用"></a>栈在括号匹配的应用</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ul>
<li>空栈，一次读入一个符号</li>
<li>右括号：使栈顶元素消解，或不合法（序列不匹配，退出程序）</li>
<li>左括号：放入栈顶，作为更高优先级的一个元素，栈为空，否则括号序列不匹配</li>
</ul>
<h3 id="栈在表达式中的应用"><a href="#栈在表达式中的应用" class="headerlink" title="栈在表达式中的应用"></a>栈在表达式中的应用</h3><ul>
<li>中缀表达式转换后缀表达式</li>
</ul>
<h3 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h3><ul>
<li>原理：将原始问题转换为相同属性的小规模问题</li>
<li>求出递归表达式</li>
<li>边界条件（递归出口）</li>
</ul>
<h2 id="队列-1"><a href="#队列-1" class="headerlink" title="队列"></a>队列</h2><h3 id="队列在层次遍历的应用"><a href="#队列在层次遍历的应用" class="headerlink" title="队列在层次遍历的应用"></a>队列在层次遍历的应用</h3><h3 id="队列在计算机系统中的应用"><a href="#队列在计算机系统中的应用" class="headerlink" title="队列在计算机系统中的应用"></a>队列在计算机系统中的应用</h3><ul>
<li>解决主机与外设之间速度不匹配的问题</li>
<li>解决多用户引起的资源竞争问题</li>
</ul>
<h1 id="特殊矩阵压缩存储"><a href="#特殊矩阵压缩存储" class="headerlink" title="特殊矩阵压缩存储"></a>特殊矩阵压缩存储</h1><h2 id="数组的存储结构"><a href="#数组的存储结构" class="headerlink" title="数组的存储结构"></a>数组的存储结构</h2><ul>
<li>行优先：先存储行号较小的元素，行号相等先存储列号小的元素</li>
<li>列优先：先存储列好较小的元素，列号相等先存储行号小的元素</li>
</ul>
<h2 id="n阶对称矩阵"><a href="#n阶对称矩阵" class="headerlink" title="n阶对称矩阵"></a>n阶对称矩阵</h2><ul>
<li>上三角、主对角线、下三角，其中上下三角元素相同</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k$</li>
<li>元素下标之间的对于关系<br>$i \ge j , k &#x3D; \frac{i*(i-1)}{2+j}-1(下三角区和主对角线元素)$<br>$i &lt; j , k &#x3D; \frac{j*(j-1)}{2+i}-1(上三角区元素)$</li>
</ul>
<h2 id="n阶三角矩阵"><a href="#n阶三角矩阵" class="headerlink" title="n阶三角矩阵"></a>n阶三角矩阵</h2><ul>
<li>下三角矩阵（上三角区元素为常量）和上三角矩阵（下三角矩阵元素为常量）</li>
<li>通常不使用二维数组存储，使用一维数组存储，元素$a_{ij}$在数组中下标为$k</li>
<li>下三角矩阵的的元素下表之间的对应关系</li>
<li></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" data-id="clyoz62580007gadq6kdd9dx8" data-title="数据结构栈和队列" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构简述" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/">数据结构简述</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h1><h2 id="一、数据结构：相互存在一种或多种特定关系的集合"><a href="#一、数据结构：相互存在一种或多种特定关系的集合" class="headerlink" title="一、数据结构：相互存在一种或多种特定关系的集合"></a>一、数据结构：相互存在一种或多种特定关系的集合</h2><ul>
<li>结构：任何问题，数据元素不孤立存在，之间存在关系  </li>
<li>逻辑结构</li>
<li>存储结构（物理结构）</li>
<li>数据的运算</li>
<li>逻辑结构和存储结构密不可分</li>
<li>算法设计取决于逻辑结构，实现依赖存储结构</li>
</ul>
<h2 id="二、逻辑结构：数据元素之间的逻辑关系"><a href="#二、逻辑结构：数据元素之间的逻辑关系" class="headerlink" title="二、逻辑结构：数据元素之间的逻辑关系"></a>二、逻辑结构：数据元素之间的逻辑关系</h2><ul>
<li>与存储无关，独立于计算机</li>
<li>分为线性结构和非线性结构<br>线性结构：线性表、栈、队列、串、数组、广义表<br>非线性结构：树、二叉树、有向图、无向图</li>
</ul>
<h2 id="三、存储结构（物理结构）：数据结构在计算机中的映像"><a href="#三、存储结构（物理结构）：数据结构在计算机中的映像" class="headerlink" title="三、存储结构（物理结构）：数据结构在计算机中的映像"></a>三、存储结构（物理结构）：数据结构在计算机中的映像</h2><ul>
<li>数据结构的表示</li>
<li>关系的表示</li>
<li>依赖于计算机语言</li>
<li>分为顺序存储、链式存储、索引存储、散列存储</li>
</ul>
<h3 id="1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻"><a href="#1-顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻" class="headerlink" title="1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻"></a>1. 顺序存储：存储的物理位置相邻，逻辑上相邻的元素物理位置也相邻</h3><ul>
<li>优：实现随机存取、每个元素占用的内存少</li>
<li>缺：只能使用相邻的一块存储单元，产生较多的外部碎片</li>
</ul>
<h3 id="2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素"><a href="#2-链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素" class="headerlink" title="2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素"></a>2.链式存储：存储的物理位置未必相邻，逻辑上的相邻的元素在物理位置上未必相邻，通过记录相邻元素的物理位置来找到相邻元素</h3><ul>
<li>优：无碎片产生、充分利用存储单元</li>
<li>缺：只能顺序存储</li>
</ul>
<h3 id="3-索引存储：类似目录"><a href="#3-索引存储：类似目录" class="headerlink" title="3. 索引存储：类似目录"></a>3. 索引存储：类似目录</h3><h3 id="4-散列存储：通过关键字直接计算出元素的物理地址"><a href="#4-散列存储：通过关键字直接计算出元素的物理地址" class="headerlink" title="4. 散列存储：通过关键字直接计算出元素的物理地址"></a>4. 散列存储：通过关键字直接计算出元素的物理地址</h3><h2 id="四、数据运算"><a href="#四、数据运算" class="headerlink" title="四、数据运算"></a>四、数据运算</h2><h2 id="五、算法的五个特征"><a href="#五、算法的五个特征" class="headerlink" title="五、算法的五个特征"></a>五、算法的五个特征</h2><ul>
<li>有穷性：执行有限步后结束</li>
<li>确定性：每条指令都有确定的含义，相同输入得到相同的输出</li>
<li>可行性：通过实现的基本运算执行有限次得到确定的结果</li>
<li>输入：有零或多个输入</li>
<li>输出：一个或多个程序输出结果</li>
</ul>
<h2 id="六、算法的复杂度"><a href="#六、算法的复杂度" class="headerlink" title="六、算法的复杂度"></a>六、算法的复杂度</h2><h3 id="1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢"><a href="#1-时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢" class="headerlink" title="1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢"></a>1. 时间复杂度：衡量算法随问题规模增大，算法执行时间增加的快慢</h3><h3 id="2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢"><a href="#2-空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢" class="headerlink" title="2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢"></a>2. 空间复杂度：衡量算法随问题规模增大，算法占用空间增加的快慢</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/" data-id="clyoz62590008gadqe8i350p2" data-title="数据结构简述" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据结构线性表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2018-10-06T04:01:51.000Z" itemprop="datePublished">2018-10-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/">数据结构线性表</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、逻辑结构和基本操作"><a href="#一、逻辑结构和基本操作" class="headerlink" title="一、逻辑结构和基本操作"></a>一、逻辑结构和基本操作</h2><h3 id="1-逻辑结构"><a href="#1-逻辑结构" class="headerlink" title="1. 逻辑结构"></a>1. 逻辑结构</h3><ul>
<li>具有相同数据类型的n个数据元素的有限序列，表长n，n&#x3D;0为空表</li>
<li>表头：第一个元素</li>
<li>表尾：最后一个元素</li>
<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>
<li>除最后一个元素外，每个元素有且仅有一个直接后继</li>
</ul>
<h3 id="2-基本操作"><a href="#2-基本操作" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">initList</span>(&amp;L);</span><br><span class="line"><span class="built_in">len</span>(L);</span><br><span class="line"><span class="built_in">locateElem</span>(L, i);</span><br><span class="line"><span class="built_in">getElem</span>(L, i);</span><br><span class="line"><span class="built_in">listInsert</span>(&amp;L, i, e);</span><br><span class="line"><span class="built_in">listDelete</span>(&amp;L, i, &amp;e);</span><br><span class="line"><span class="built_in">printList</span>(L);</span><br><span class="line"><span class="built_in">isEmptyList</span>(L);</span><br><span class="line"><span class="built_in">destroyList</span>(&amp;L);</span><br></pre></td></tr></table></figure>

<h2 id="二、顺序存储结构"><a href="#二、顺序存储结构" class="headerlink" title="二、顺序存储结构"></a>二、顺序存储结构</h2><h3 id="1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻"><a href="#1-定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻" class="headerlink" title="1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻"></a>1. 定义：又称顺序表，使用一组地址连续的存储单元，依次存储线性表的数据元素，使逻辑上相邻的两个元素物理位置也相邻</h3><ul>
<li>存储空间的起始位置data[ ]</li>
<li>顺序表最大存储容量MaxSize</li>
<li>顺序表当前最大长度len<br>特点</li>
<li>随机访存，O(1)时间复杂度访问</li>
<li>存储密度高，每个结点只存储数据元素</li>
<li>无需花费空间建立数据之间的逻辑关系，由物理位置相邻特性决定</li>
<li>逻辑上物理上均相邻，插入删除操作需要移动大量元素</li>
</ul>
<h3 id="2-基本操作-1"><a href="#2-基本操作-1" class="headerlink" title="2. 基本操作"></a>2. 基本操作</h3><p>（1）插入元素</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span>(L.len = MaxSize)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = L.len; j  i; j--)</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	L.data[i - <span class="number">1</span>] = e;</span><br><span class="line">	L.len++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析</p>
<ul>
<li>最好情况：在表尾插入 **(i&#x3D;n+1)**，不需要移动元素，时间复杂度为O(1)  </li>
<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>
<li>平均情况：假设$P_i$ **($P_i &#x3D; \frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n}{2}$，其时间复杂度为O(n)<br>（2）删除元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">boolean <span class="title">listDelete</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i &lt; <span class="number">1</span> || i  L.len + <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	e = L.data[i<span class="number">-1</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; L.len; j++)</span><br><span class="line">		L.data[j<span class="number">-1</span>] = L.data[j];</span><br><span class="line">	L.len--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
分析</li>
<li>最好情况：在表尾插入 **(i&#x3D;n)**，不需要移动元素，时间复杂度为O(1)  </li>
<li>最坏情况：在表头插入 **(i&#x3D;1)**，元素后移n次，时间复杂度O(n)  </li>
<li>平均情况：假设$P_i$ **($P_i &#x3D; \frac{1}{n+1}$)**，是在第i个位置上插入一个结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n-1}{2}$，其时间复杂度为O(n)<br>（3）查找元素<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">locateElem</span><span class="params">(SqList &amp;L, Elemtype e)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; L.len; i++)</span><br><span class="line">		<span class="keyword">if</span>(e == L.data[i])</span><br><span class="line">			<span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
分析</li>
<li>最好情况：查找的元素在表头，仅需比较1次，时间复杂度O(1)</li>
<li>最坏情况：查找的元素在表尾或不存在，需要比较n次，时间复杂度O(n)  </li>
<li>平均情况：假设$P_i$ **($P_i &#x3D; \frac{1}{n}$)**是在第i个位置上结点的概率，则在长度为n的线性表中插入一个结点所需移动的平均次数为$\frac{n+1}{2}$，其时间复杂度为O(n)</li>
</ul>
<h1 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h1><h2 id="1-创建单链表"><a href="#1-创建单链表" class="headerlink" title="1.创建单链表"></a>1.创建单链表</h2><h3 id="（1）头插法"><a href="#（1）头插法" class="headerlink" title="（1）头插法"></a>（1）头插法</h3><ul>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表头(头结点位置)</li>
<li>链表结点的次序与输入的顺序相反</li>
</ul>
<h3 id="（2）尾插法"><a href="#（2）尾插法" class="headerlink" title="（2）尾插法"></a>（2）尾插法</h3><ul>
<li>为新插入的结点分配内存空间</li>
<li>每次都是把插入的新结点放入表尾(尾结点位置)</li>
<li>链表中的结点顺序与输入顺序一致</li>
</ul>
<h2 id="2-按值查找结点"><a href="#2-按值查找结点" class="headerlink" title="2.按值查找结点"></a>2.按值查找结点</h2><ul>
<li>在链表中从第一个结点出发，顺指针next逐个向下搜索，直到找到第i个结点，否则返回最后一个结点的指针域NULL</li>
</ul>
<h2 id="3-按序号查找结点"><a href="#3-按序号查找结点" class="headerlink" title="3.按序号查找结点"></a>3.按序号查找结点</h2><ul>
<li>从链表第一个结点开始，由前往后按照序号递增定位到相应结点的位置，返回该值，需检查序号是否越界</li>
</ul>
<h2 id="4-插入"><a href="#4-插入" class="headerlink" title="4.插入"></a>4.插入</h2><ul>
<li>插入操作是将值为x的新结点插入到单链表的第i个位置</li>
<li>先检查插入位置是否合法</li>
<li>找到待插入位置的前驱结点</li>
<li>在其后将结点插入<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">s-next = p-next;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="5-删除"><a href="#5-删除" class="headerlink" title="5.删除"></a>5.删除</h2><ul>
<li>将单链表的第i个结点删除</li>
<li>先检查插入位置是否合法</li>
<li>找到待删除位置的前驱结点</li>
<li>删除其后结点<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="built_in">getElem</span>(L, i<span class="number">-1</span>)</span><br><span class="line">q = p-next;</span><br><span class="line">q-next = p-next;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h1><ul>
<li>双链表有两个指针prior和next，分别指向前驱和后继结点</li>
<li>插入操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-next = p-next;</span><br><span class="line">p-next-prior = s;</span><br><span class="line">s-prior = p;</span><br><span class="line">p-next = s;</span><br></pre></td></tr></table></figure></li>
<li>删除操作<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-next = q-next;</span><br><span class="line">q-next-prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h1><ul>
<li>循环双链表和循环单链表</li>
<li>静态链表使用数组来描述线性表的链式存储结构</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/10/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BA%BF%E6%80%A7%E8%A1%A8/" data-id="clyoz625a0009gadqfqnfdy4m" data-title="数据结构线性表" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-高等数学不定积分与定积分与反常积分" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/" class="article-date">
  <time class="dt-published" datetime="2018-09-06T04:01:51.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/">高等数学不定积分与定积分与反常积分</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="不定积分、定积分与反常积分"><a href="#不定积分、定积分与反常积分" class="headerlink" title="不定积分、定积分与反常积分"></a>不定积分、定积分与反常积分</h1><h2 id="不定积分"><a href="#不定积分" class="headerlink" title="不定积分"></a>不定积分</h2><h3 id="一、不定积分概念"><a href="#一、不定积分概念" class="headerlink" title="一、不定积分概念"></a>一、不定积分概念</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><p>$$<br>\begin{align}<br>&amp;原函数：设对于区间I上的任意一点x均有F’(x)&#x3D;f(x),则称F(x)为f(x)在区间I上的一个原函数\<br>&amp;不定积分：设函数f(x)于区间I上有原函数,则其余原函数的全体称为f(x)于区间I上的不定积分,记为\int{f(x)dx}\<br>&amp;线性：\int[\alpha f(x)+\beta g(x)]dx&#x3D;\alpha\int f(x)dx+\beta\int g(x)dx\<br>\end{align}<br>$$</p>
<h4 id="2-计算"><a href="#2-计算" class="headerlink" title="2.计算"></a>2.计算</h4><p>$$<br>\begin{align}<br>&amp;计算方法\begin{cases}&amp;1.基本公式\&amp;2.线性\&amp;3.积分法\begin{cases}&amp;1.换元法\&amp;2.分部积分法\\end{cases}\\end{cases}\<br>\end{align}<br>$$</p>
<h5 id="1-第一换元法-凑微分"><a href="#1-第一换元法-凑微分" class="headerlink" title="(1)第一换元法(凑微分)"></a>(1)第一换元法(凑微分)</h5><p>$$<br>\begin{align}<br>&amp;设F’(u)&#x3D;f(u),则\int{f(\Phi(x))\Phi’(x)}dx&#x3D;\int{f(\Phi(x))d(\Phi(x))}&#x3D;F(\Phi(x))+C\<br>&amp;注解：找到合适的凑微分\Phi’(x)dx&#x3D;d(\Phi(x))<br>\end{align}<br>$$</p>
<p>常见凑微分：<br>$$<br>\begin{align}<br>&amp;1.\int{f(ax+b)dx&#x3D;\frac{1}{a}\int{f(ax+b)d(ax+b)}}(a\neq0)\<br>&amp;eg1.\int{\sin (2x+3)}dx&#x3D;\frac{1}{2}\int\sin (2x+3)d(2x+3)&#x3D;\frac{1}{2}\cos{(2x+3)}+C\<br>&amp;2.\int{f(ax^n+b)x^{n-1}dx}&#x3D;\frac{1}{na}\int{f(ax^n+b)d(ax^n+b)}\<br>&amp;eg2.\int{\cos(2x^4+3)x^3dx}&#x3D;\frac{1}{4*2}\int{\cos(2x^4+3)d(2x^4+3)}&#x3D;\frac{1}{8}\cos{(2x^4+3)}+C\<br>&amp;3.\int{f(a^x+c)a^xdx}&#x3D;\frac{1}{\ln{a}}\int{f(a^x+c)}d(a^x+c)\<br>&amp;eg3.\int{\sin(2^x+3)2^xdx}&#x3D;\frac{1}{\ln2}\int{\sin{(2^x+3)}d(2^x+3)}&#x3D;\frac{1}{\ln 2}\cos{(2^x+3)}\<br>&amp;4.\int{f(\frac{1}{x})\frac{1}{x^2}}dx&#x3D;-\int{f(\frac{1}{x})}d(\frac{1}{x})\<br>&amp;eg4.\int{\ln(\frac{1}{x})}\frac{1}{x^2}dx&#x3D;-\int\ln (\frac{1}{x})d({\frac{1}{x}})+C\<br>&amp;5.\int{f(\ln |x|})\frac{1}{x}d(x)&#x3D;\int{f(\ln{|x|)}}{d(\ln|x|)}\<br>&amp;eg5.\int{\sin ({\ln{|x|}}})\frac{1}{x}dx&#x3D;\int{\sin(\ln(|x|)d(\ln{|x|})}&#x3D;\cos(\ln x)+C\<br>&amp;6.\int{f(\sqrt x)\frac{1}{\sqrt x}}dx&#x3D;2\int{f(\sqrt x)}d(\sqrt x)\<br>&amp;7.\int f(\sin x)\cos xdx&#x3D;-\int{(\sin x)}d(\sin x)\<br>&amp;8.\int{f(\cos x)\sin dx}&#x3D;\int{f(\cos x)d(\cos x)}\<br>&amp;9.\int{f(\tan x)\sec^2 xdx}&#x3D;\int{f(\tan x)d(\tan x)}\<br>&amp;10.\int{f(\cot x)\csc^2xdx}&#x3D;-\int{f(\cot x)d{(\cot x)}}\<br>&amp;11.\int{f{(\arcsin x)\frac{1}{\sqrt{1-x^2}}}}dx&#x3D;\int{f(\arcsin x)d({\arcsin x})}\<br>&amp;12.\int{f(\arccos x)(-\frac{1}{\sqrt{1-x^2}}})dx&#x3D;\int{f(\arccos x)d(\arccos x)}\<br>&amp;13.\int{f(\arctan x)\frac{1}{1+x^2}dx}&#x3D;\int{f(\arctan x)d(\arctan x)}\<br>&amp;14.\int{f(\sqrt{x^2+a})}\frac{x}{\sqrt{x^2+a}}dx&#x3D;\int{f(\sqrt{x^2+a})}d(\sqrt{x^2+a})\<br>&amp;注解：(\sqrt{x^2\pm a})’&#x3D;\frac{x}{\sqrt{x^2+a}},(\sqrt{a^2-x^2})’&#x3D;\frac{-x}{\sqrt{a^2-x^2}}\<br>\end{align}<br>$$</p>
<h5 id="2-第二换元法"><a href="#2-第二换元法" class="headerlink" title="(2)第二换元法"></a>(2)第二换元法</h5><p>$$<br>\begin{align}<br>&amp;设F’(u)&#x3D;f(\Phi(u))\Phi’(u),则\<br>&amp;\int{f(x)dx}\overset{x&#x3D;\Phi(u)}{&#x3D;}\int{f(\Phi(u))\Phi’(u)du}&#x3D;F(u)+C&#x3D;F(\Phi^{-1}(x))+C\<br>&amp;注解：找到合适的x&#x3D;\Phi(u)\<br>\end{align}<br>$$</p>
<p>1)三角换元<br>$$<br>\begin{align}<br>&amp;x&#x3D;a\sin u,x&#x3D;a\tan u,x&#x3D;a \sec u\<br>&amp;\sqrt{a^2-x^2}\overset{x&#x3D;a\sin u}{&#x3D;}a\cos u,u\in[-\frac{\pi}{2},\frac{\pi}{2}],x\in[-a,a]\<br>&amp;\sqrt{a^2+x^2}\overset{x&#x3D;a\tan u}{&#x3D;}a\sec u,u\in{(-\frac{\pi}{2},\frac{\pi}{2})},x\in{(-\infty,\infty)}\<br>&amp;\sqrt{x^2-a^2}\overset{x&#x3D;a\sec u}{&#x3D;}a\tan u,u\in(\frac{\pi}{2},\pi]\cup(0,\frac{\pi}{2}]\<br>\end{align}<br>$$<br>2)倒变换<br>$$<br>\begin{align}<br>&amp;x&#x3D;\frac{1}{u}常用于含\frac{1}{x}的函数\<br>\end{align}<br>$$<br>3）指数(或对数)变换<br>$$<br>\begin{align}<br>&amp;a^x&#x3D;u或x&#x3D;\frac{\ln u}{\ln a}常用于含a^x的函数\<br>\end{align}<br>$$<br>4）用于有理化的变换<br>$$<br>\begin{align}<br>&amp;\frac{1}{\sqrt{x}+\sqrt[3]{x}}用x&#x3D;u^6\<br>&amp;\sqrt[n]{\frac{ax+b}{cx+d}}用u&#x3D;\sqrt[n]{\frac{ax+b}{cx+d}}或x&#x3D;-\frac{du^n-b}{cu^n-a}\<br>\end{align}<br>$$</p>
<h5 id="3-分部积分法"><a href="#3-分部积分法" class="headerlink" title="(3)分部积分法"></a>(3)分部积分法</h5><p>$$<br>\begin{align}<br>&amp;\int{u(x)v’(x)dx}&#x3D;\int{u(x)d(v(x))}&#x3D;u(x)v(x)-\int{v(x)u’(x)dx}\<br>&amp;注解：找到合适的u(x),v(x)\<br>\end{align}<br>$$</p>
<p>1)降幂法<br>$$<br>\begin{align}<br>&amp;\int{x^ne^{ax}dx},\int{x^n\sin axdx},\int{x^n\cos ax dx}\<br>&amp;取u(x)&#x3D;x^n\<br>\end{align}<br>$$<br>2)升幂法<br>$$<br>\begin{align}<br>&amp;\int{x^a\ln xdx},\int{x^a\arcsin xdx},\int{x^a\arccos x dx},\int{x^a\arctan x dx}\<br>&amp;取u(x)&#x3D;\ln x\<br>\end{align}<br>$$<br>3)循环法<br>$$<br>\begin{align}<br>&amp;\int{e^{ax}\sin ax dx},\int{e^{ax}\cos {ax} dx}\<br>&amp;取u(x)&#x3D;e^{ax}或\sin{ax}<br>\end{align}<br>$$<br>4)递推公式法<br>$$<br>\begin{align}<br>&amp;与n有关的结果I_n，建立递推关系I_n&#x3D;f(I_{n-1})或f(I_{n-2})\<br>\end{align}<br>$$</p>
<h2 id="定积分"><a href="#定积分" class="headerlink" title="定积分"></a>定积分</h2><h3 id="一、定积分概念"><a href="#一、定积分概念" class="headerlink" title="一、定积分概念"></a>一、定积分概念</h3><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h4><p>$$<br>\begin{align}<br>&amp;定义:设函数f(x)在区间[a,b]上有定义且有界\<br>&amp;(1)分割：将[a,b]分成n个[x_{i-1},x_{i}]小区间\<br>&amp;(2)求和：[x_{i-1},x_{i}]上取一点\xi_{i},\sum_{i&#x3D;1}^{n}{f(\xi_{i})\Delta x_i},\lambda&#x3D;\max{\Delta x_{1},\Delta x_{2},…,\Delta x_{n}}\<br>&amp;(3)取极限：若\lim_{\lambda \rightarrow 0}{\sum_{i&#x3D;1}^{n}f(\xi_{i})\Delta x}\exist,且极值不依赖区间[a,b]分发以及点\xi_{i}的取法,则称f(x)在区间[a,b]上可积,\<br>&amp;\int^{b}<em>{a}{f(x)dx}&#x3D;\lim</em>{\lambda \rightarrow 0}{f(\xi)\Delta x_{i}}<br>&amp;\<br>&amp;注解：\<br>&amp;(1)\lambda \rightarrow0 \rightarrow \nleftarrow n\rightarrow \infty\<br>&amp;(2)定积分表示一个值,与积分区间[a,b]有关,与积分变化量x无关\<br>&amp;\int_{a}^{b}{f(x)dx}&#x3D;\int_{a}^{b}{f(t)dt}\<br>&amp;(3)如果积分\int_{0}^{1}{f(x)dx}\exist,将[0,1]n等分，此时\Delta{x_{i}}&#x3D;\frac{1}{n},取\xi_{i}&#x3D;\frac{i}{n},\<br>&amp;\int_{0}^{1}f(x)dx&#x3D;\lim_{\lambda \rightarrow 0}{\sum_{i&#x3D;1}{n}{f(\xi_{i})\Delta x_{i}}}&#x3D;\lim_{n\rightarrow \infty}\sum_{i&#x3D;1}^{n}f(\frac{i}{n})\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;\int^{b}<em>{a}{f(x)dx}&#x3D;\lim</em>{\lambda \rightarrow 0}\sum^{n}<em>{i&#x3D;1}f(\xi_i)\Delta_i&#x3D;\begin{cases}&amp;\lim</em>{n\rightarrow \infty}{\sum_{i&#x3D;1}^{n}{f(a+(i-1)\frac{b-a}{n})\frac{b-a}{n}}},左侧\&amp;\lim_{n\rightarrow \infty}{\sum_{i&#x3D;1}^{n}{f(a+i\frac{b-a}{n})\frac{b-a}{n}}},右侧\\end{cases}\<br>&amp;中点：\Phi_i&#x3D;a+(i-1)\frac{b-a}{n}+\frac{b-a}{2n}\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210613172601984.jpg" alt="image-20210613172601984"></p>
<p>定理：(线性)<br>$$<br>\begin{align}<br>&amp;\int[\alpha f(x)+\beta g(x)]dx&#x3D;\alpha\int f(x)dx+\beta\int g(x)dx\<br>\end{align}<br>$$<br>注解：积分无小事<br>$$<br>\begin{align}<br>&amp;\int{e^{\pm x^2}dx,\int{\frac{\sin x}{x}}}积不出来\<br>&amp;F’(x)&#x3D;f(x),x\in I,连续函数一定存在原函数，无穷多个\<br>&amp;[F(x)+C]’&#x3D;f(x)<br>\end{align}<br>$$</p>
<h4 id="2-定积分存在的充分条件"><a href="#2-定积分存在的充分条件" class="headerlink" title="2.定积分存在的充分条件"></a>2.定积分存在的充分条件</h4><p>$$<br>\begin{align}<br>&amp;若f(x)在[a,b]上连续,则\int^{b}<em>{a}{f(x)dx}必定存在\<br>&amp;若f(x)在[a,b]上有上界,且只有有限个间断点,则\int^{b}</em>{a}{f(x)dx}必定存在\<br>&amp;若f(x)在[a,b]上只有有限个第一类间断点,则\int^{b}_{a}{f(x)dx}必定存在\<br>\end{align}<br>$$</p>
<h4 id="3-定积分的几何意义"><a href="#3-定积分的几何意义" class="headerlink" title="3.定积分的几何意义"></a>3.定积分的几何意义</h4><p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405155729433.jpg" alt="image-20210405155729433"><br>$$<br>\begin{align}<br>&amp;(1)f(x)\geqslant{0},\int_{a}^{b}{f(x)dx}&#x3D;S\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405155859329.jpg" alt="image-20210405155859329"><br>$$<br>\begin{align}<br>&amp;(2)f(x)\leqslant{0},\int_{a}^{b}{f(x)dx}&#x3D;-S\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405155556537.jpg" alt="image-20210405155556537"><br>$$<br>\begin{align}<br>&amp;(3)f(x)\geqslant{0}\cup f(x)\leqslant{0},\int_{a}^{b}{f(x)dx}&#x3D;S_1+S_3-S_2\</p>
<p>\end{align}<br>$$</p>
<p>注解：<br>$$<br>\begin{align}<br>&amp;（1）当f(x)\geq0时,定积分的几何意义是,以区间[a,b]为底,y&#x3D;f(x)为曲边的曲边梯形面积\<br>&amp;（2）定积分是一个常数，只与f和区间[a,b]有关,与积分变量用什么字母无关\<br>&amp;\int_a^b{f(x)}dx&#x3D;\int_a^b{f(t)dt}\<br>&amp;（3）\int_a^bdx&#x3D;b-a\<br>&amp;（4）\int_{a}^{a}f(x)&#x3D;0,\int_a^bf(x)dx&#x3D;-\int_b^a{f(t)}dt<br>\end{align}<br>$$</p>
<h3 id="二、定积分的性质"><a href="#二、定积分的性质" class="headerlink" title="二、定积分的性质"></a>二、定积分的性质</h3><h4 id="1-不等式性质"><a href="#1-不等式性质" class="headerlink" title="1.不等式性质"></a>1.不等式性质</h4><p>$$<br>\begin{align}<br>&amp;(1)保序性：若在区间[a,b]上f(x)\leqslant{g(x)},则\int_a^{b}{f(x)dx}\leqslant{\int_a^{b}{g(x)dx}}\<br>&amp;推论：\<br>&amp;(1)f(x)\geq0,\forall x\in[a,b],则\int_a^b{f(x)dx}\geq0\<br>&amp;(2)f(x)\geq0,\forall x\in[a,b],且[c,d]\subset[a,b],则\int_a^b{f(x)dx}\geq\int_c^d{f(x)dx}\<br>&amp;(3)|\int_a^bf(x)dx|\leq\int_a^b{|f(x)|dx}\<br>&amp;-|f|\leq f\leq |f|\Rightarrow \int_a^b-|f|\leq \int_a^bf\leq \int_a^b|f|\Rightarrow |\int_a^bf|\leq\int_a^b|f|\<br>&amp;如：x^2\leq x^3,x\in[0,1],则\int_0^1{x^3dx}\leq\int_0^1{x^2dx}\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;(4)(估值不等式)若M及m分别是f(x)在[a,b]上的最大值和最小值,\<br>&amp;则m(b-a)\leqslant{\int_a^{b}{f(x)dx}\leqslant{M(b-a)}}\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/geogebra-export.jpg" alt="geogebra-export"><br>$$<br>\begin{align}<br>&amp;证明：M(b-a)&#x3D;S_{AFDC}&#x3D;S_1+S_2+S_3\<br>&amp;m(b-a)&#x3D;S_{EBDC}&#x3D;S_3\<br>&amp;\int_a^{b}{f(x)dx}&#x3D;S_{ADBC}&#x3D;S_2+S_3\<br>&amp;S_3\leqslant{S_2+S_3\leqslant{S_1+S_2+S_3}}\<br>&amp;\Leftrightarrow{m(b-a)\leqslant{\int_a^{b}{f(x)dx}\leqslant{M(b-a)}}}\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;(3)|\int_a^{b}{f(x)dx}|\leqslant{\int_a^{b}{|f(x)|dx}}\<br>\end{align}<br>$$</p>
<h4 id="2-中值定理"><a href="#2-中值定理" class="headerlink" title="2.中值定理"></a>2.中值定理</h4><p>$$<br>\begin{align}<br>&amp;(1)若f(x)在[a,b]上连续,则\int_a^{b}{f(x)dx}&#x3D;f(\xi)(b-a),(a&lt;\xi&lt;b)\<br>&amp;称\frac{1}{b-a}{\int_{a}^{b}{f(x)dx}为函数y&#x3D;f(x)在区间[a,b]上的平均值}\<br>&amp;注解：F’(x)&#x3D;f(x),F(b)-F(a)&#x3D;\int_a^b{f(x)dx},f(\xi)(b-a)&#x3D;F’(\xi)(b-a)\<br>&amp;(2)若f(x),g(x)在[a,b]上连续，g(x)不变号,则\int_{a}^{b}{f(x)g(x)dx}&#x3D;f(\xi)\int_a^b{g(x)dx}\<br>\end{align}<br>$$</p>
<p>注解：<br>$$<br>\begin{align}<br>&amp;\int_0^1{\frac{x}{\sin x}}dx\<br>&amp;f(x)&#x3D;\begin{cases}&amp;\frac{x}{\sin x},x\in[0,1]\&amp;1,x&#x3D;0\\end{cases}\<br>&amp;结论：有限处点的函数不影响定积分\<br>&amp;f(x)&#x3D;{\begin{cases}&amp;x+1,[1,2]\&amp;x,[0,1]\\end{cases}}\<br>&amp;\int_0^2{f(x)dx}&#x3D;\int_0^1{xdx}+\int_1^2{(x+1)dx}\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;证明：\frac{1}{2}\leq\int_0^{\frac{1}{2}}\frac{1}{\sqrt{1-x^n}}dx\leq\frac{\pi}{6}\<br>&amp;估值积分：x\in[0,\frac{1}{2}]\<br>&amp;\<br>\end{align}<br>$$</p>
<p>例题：<br>$$<br>\begin{align}<br>&amp;1.求极限\lim_{n\rightarrow \infty}\int_0^1{\frac{x^ne^x}{1+e^x}dx}\<br>&amp;根据积分容易知道0\leq\frac{x^ne^x}{1+e^x}\leq x^n,x\in[0,1],n\in N^*\<br>&amp;用积分的保号性\<br>&amp;0\leq\int_0^1{\frac{x^ne^x}{1+e^x}dx}\leq \int_0^1{x^n}dx&#x3D;\frac{1}{n+1}\<br>&amp;用夹逼定理\<br>&amp;\lim_{n\rightarrow\infty}\frac{1}{n+1}&#x3D;0\<br>&amp;\lim_{n\rightarrow \infty}\int_0^1{\frac{x^ne^x}{1+e^x}dx}&#x3D;0\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;2.设I_1&#x3D;\int_0^{\frac{4}{\pi}}\frac{\tan x}{x}dx,I_2&#x3D;\int_0^{\frac{4}{\pi}}\frac{x}{\tan x}dx则\<br>&amp;(A)I_1I_21(B)1I_1I_2(C)I_2I_11(D)1I_2I_1\<br>&amp;解：用保序性a&lt;b,f(x)\leq g(x),\int_a^b f(x)\leq \int_a^b g(x)\<br>&amp;\tan xx,x\in[0,\frac{\pi}{2}]\<br>&amp;\frac{\tan x}{x}1\frac{x}{\tan x},x\in[0,\frac{\pi}{4}]\<br>&amp;根据保序性\<br>&amp;\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}dx\int_0^{\frac{\pi}{4}}1dx&#x3D;\frac{\pi}{4}\int_0^{\frac{\pi}{4}}\frac{x}{\tan x},x\in[0,\frac{\pi}{4}]\<br>&amp;证：\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}与1的关系\<br>&amp;积分中值定理\<br>&amp;\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}&#x3D;f(\xi)(\frac{\pi}{4}-0)&#x3D;\frac{\tan \xi}{\xi}*\frac{\pi}{4},\xi\in{[0,\frac{\pi}{4}]}\<br>&amp;根据\frac{\tan x}{x}在x\in[0,\frac{\pi}{4}]上单调递增\<br>&amp;0&lt;f(\xi)&lt;\frac{4}{\pi},0&lt;\int_0^{\frac{\pi}{4}}\frac{\tan x}{x}&lt;1\<br>&amp;选(B)\<br>\end{align}<br>$$</p>
<h3 id="三、积分上限函数"><a href="#三、积分上限函数" class="headerlink" title="三、积分上限函数"></a>三、积分上限函数</h3><p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210405152647772.jpg" alt="image-20210405152647772"><br>$$<br>\begin{align}<br>&amp;如果f(x)在区间[a,b]上连续,则\Phi(x)&#x3D;\int_a^b{f(t)dt}在[a,b]上可导,且\int_a^b{f(t)dt})\<br>&amp;(\int_a^xf(t)dt)’&#x3D;f(x),(\int_a^{x^2}f(t)dt)’&#x3D;f(x^2)*2x\<br>&amp;如果f(x)在区间[a,b]上连续,\phi_1(x),\phi_2(x)为可导函数,则\Phi(x)&#x3D;\int_a^b{f(t)dt}在[a,b]上可导,且(\int_{\phi_1(x)}^{\phi_2(x)}{f(t)dt})’\<br>&amp;&#x3D;f[\phi_2(x)]*\phi_2’(x)-f[\phi_1(x)]*\phi_1’(x)&#x3D;(\int_{\phi_1(x)}^0{f(t)dt}+\int_{\phi_2(x)}^0{f(t)dt})’\<br>&amp;设函数f(x)在[-l,l]上连续,则\<br>&amp;如果f(x)为奇函数,那么\int_0^xf(t)dt必为偶函数\<br>&amp;如果f(x)为偶函数,那么\int_0^xf(t)dt必为奇函数\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;任取x\in[a,b),取\Delta x0,使x+\Delta x\in[a,b)\<br>&amp;\frac{\Delta F}{\Delta x}&#x3D;\frac{F(x+\Delta x)-F(x)}{\Delta x}&#x3D;\frac{1}{\Delta x}[\int_a^{x+\Delta x}f(t)dt-\int_a^xf(t)dt]&#x3D;\frac{1}{\Delta x}\int_x^{x+\Delta x}f(t)dt&#x3D;f(x+\sigma\Delta x)\rightarrow f(x)(\Delta x\rightarrow 0^+)\<br>\end{align}<br>$$<br>推论：<br>$$<br>\begin{align}<br>&amp;若f(x)、\phi’(x)、\psi(x)于[a,b]上连续,则\<br>&amp;(1)(\int_a^{\phi(x)}f(t)dt)’&#x3D;f(\phi(x))\phi’(x)\<br>&amp;(2)(\int_b^{\psi(x)}f(t)dt)’&#x3D;-f(\psi(x))\psi’(x)\<br>&amp;(3)(\int_{\psi(x)}^{\phi(x)}f(t)dt)’&#x3D;f(\phi(x))\phi’(x)-f(\psi(x))\psi’(x)\<br>\end{align}<br>$$<br>例题<br>$$<br>\begin{align}<br>&amp;1.设函数f(x)在R上连续,且是奇函数,则其原函数均是偶函数.当f(x)是偶函数时？是周期函数？\<br>&amp;证：\<br>&amp;令F_0(x)\int_0^xf(t)dt,x\in R\<br>&amp;F_0(-x)&#x3D;\int_0^{-x}f(t)dt\overset{t&#x3D;-u}{&#x3D;}\int_0^xf(-u)d(u)&#x3D;\int_0^xf(u)du&#x3D;F_0(x)\Rightarrow F_0(x)为偶函数\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;求变现积分导数\<br>&amp;(1)F(x)&#x3D;\int_x^{e^{-x}}f(t)dt\<br>&amp;(2)F(x)&#x3D;\int_0^{x^2}(x^2-t)f(t)dt\<br>&amp;(3)F(x)&#x3D;\int_0^{x}f(x^2-t)dt\<br>&amp;(4)设函数y&#x3D;y(x)由参数方程\begin{cases}&amp;x&#x3D;1+2t^2\&amp;y&#x3D;\int_1^{1+2\ln t}\frac{e^u}{u}du\\end{cases}(t1),求\frac{d^2y}{dx^2}|_{x&#x3D;9}\<br>&amp;解:\<br>&amp;(1)F(x)’&#x3D;(\int_x^{e^{-x}}f(t)dt)’&#x3D;f(e^{-x})(-e^{-x})-f(x)\<br>&amp;(2)F(x)’&#x3D;(\int_0^{x^2}(x^2-t)f(t)dt)’&#x3D;(\int_0^{x^2}x^2f(t)dt-\int_0^{x^2}tf(t)dt)’\<br>&amp;&#x3D;2x\int_0^{x^2}f(t)dt+x^2f(x^2)2x-x^2f(x^2)2x&#x3D;2x\int_0^{x^2}f(t)dt\<br>&amp;(3)F(x)&#x3D;\int_0^{x}f(x^2-t)dt&#x3D;-\frac{1}{2}\int_0^xf(x^2-t^2)d(x^2-t^2)\overset{u&#x3D;x^2-t^2}{&#x3D;}-\frac{1}{2}\int_0^xf(u)du\<br>&amp;F(x)’&#x3D;\frac{1}{2}f(x^2)2x&#x3D;xf(x^2)\<br>&amp;(4)\frac{dy}{dx}&#x3D;\frac{\frac{e^{1+2\ln t}}{1+2\ln t}\frac{2}{t}}{4t^2}&#x3D;\frac{e}{2(1+2\ln t)}\<br>&amp;\frac{d^2y}{dx^2}&#x3D;\frac{d(\frac{dy}{dx})}{dx}&#x3D;\frac{e}{2}(-\frac{\frac{2}{t}}{(1+2\ln t)^2})\frac{1}{4t}\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;2.求变现积分的积分:\<br>&amp;(1)设f(x)&#x3D;\int_0^x{\frac{\sin t}{\pi -t}dt},求\int_0^\pi{f(x)}dx\<br>&amp;解:\<br>&amp;\int_0^\pi{f(x)}dx&#x3D;\int_0^{\pi}\int_0^x\frac{\sin t}{\pi -t}dt\space dx\<br>&amp;&#x3D;x\int_0^x\frac{\sin t}{\pi t}|<em>0^{\pi}-\int_0^{\pi}x\frac{\sin x}{\pi -x}dx\<br>&amp;&#x3D;\pi\int_0^{\pi}\frac{\sin x}{\pi t}+\int_0^{\pi}\frac{[(\pi-x)-\pi]\sin x}{\pi-x}dx&#x3D;\int_0^{\pi}\sin xdx&#x3D;2\<br>&amp;(2)\lim</em>{x\rightarrow\infty}{\frac{(\int_0^x{e^{t^2}}dt)^2}{\int_0^xe^{2t^2}dt}}&#x3D;\lim_{x\rightarrow\infty}{\frac{(2\int_0^{x}e^{t^2}dt)e^{x^2}}{e^{2x^2}}}&#x3D;\lim_{x\rightarrow\infty}\frac{2\int_0^{x}e^{t^2}}{e^{x^2}}&#x3D;\lim_{x\rightarrow\infty}\frac{1}{2x}&#x3D;0\<br>\end{align}<br>$$ { }</p>
<p>$$<br>\begin{align}<br>&amp;(3)设f(x)连续,\phi(x)&#x3D;\int_0^1{f(tx)dt},且\lim_{x\rightarrow0}\frac{f(x)}{x}&#x3D;A(常数),求\phi’(x)并讨论\phi’(x)在x&#x3D;0处的连续性\<br>&amp;当x\neq0时\<br>&amp;令u&#x3D;tx,t\in[0,1],u&#x3D;tx\in[0,x],\phi(x)&#x3D;\int_0^1f(tx)dt\overset{tx&#x3D;u}{&#x3D;}\int_0^x{f(u)d(\frac{u}{x})}&#x3D;\frac{\int_0^xf(u)du}{x}\<br>&amp;\phi’(x)&#x3D;\frac{xf(x)-\int_0^xf(u)du}{x^2}\<br>&amp;当x&#x3D;0时,f(0)&#x3D;0,\phi(0)&#x3D;f(0)&#x3D;0,\phi’(0)&#x3D;\lim_{x\rightarrow0}\frac{\phi(x)\phi(0)}{x-0}&#x3D;\lim_{x\rightarrow0}\frac{\int_0^xf(u)du}{x^2}&#x3D;\lim_{x\rightarrow 0}\frac{f(x)}{2x}&#x3D;\frac{1}{2}A\<br>&amp;\lim_{x\rightarrow0}\phi’(x)&#x3D;\lim_{x\rightarrow 0}{\frac{xf(x)-\int_0^xf(u)du}{x^2}}&#x3D;A-\frac{1}{2}A&#x3D;\frac{1}{2}A&#x3D;\phi’(0)\Leftrightarrow\phi’(x)在x&#x3D;0处连续\<br>\end{align}<br>$$</p>
<p>注解：<br>$$<br>\begin{align}<br>&amp;注意变限积分进行正逆运算时上下限的映射\<br>&amp;例如F(x)&#x3D;\int_0^x{f(t)dt}\overset{t&#x3D;-u}{&#x3D;}\int_{-a}^{x}f(-u)d(-u)\<br>\end{align}<br>$$</p>
<h3 id="四、定积分的计算"><a href="#四、定积分的计算" class="headerlink" title="四、定积分的计算"></a>四、定积分的计算</h3><h4 id="1-牛顿莱布尼茨公式"><a href="#1-牛顿莱布尼茨公式" class="headerlink" title="1.牛顿莱布尼茨公式"></a>1.牛顿莱布尼茨公式</h4><p>$$<br>\int_a^bf(x)dx&#x3D;F(x)|_a^b&#x3D;F(b)-F(a)<br>$$</p>
<h4 id="2-换元积分法"><a href="#2-换元积分法" class="headerlink" title="2.换元积分法"></a>2.换元积分法</h4><p>$$<br>\int_a^bf(x)dx&#x3D;\int_\alpha^\beta{f(\Phi(t))\Phi’(t)dt}<br>$$</p>
<h4 id="3-分部积分法-1"><a href="#3-分部积分法-1" class="headerlink" title="3.分部积分法"></a>3.分部积分法</h4><p>$$<br>\int_a^budv&#x3D;uv|_a^b-\int_a^bvdu<br>$$</p>
<h4 id="4-奇偶性和周期性"><a href="#4-奇偶性和周期性" class="headerlink" title="4.奇偶性和周期性"></a>4.奇偶性和周期性</h4><p>$$<br>\begin{align}<br>&amp;直接使用奇偶性周期性定义证明\<br>&amp;(1)设f(x)为[-a,a]上的连续函数(a0),则\<br>&amp;\int_{-a}{a}f(x)dx&#x3D;\begin{cases}0,&amp;f(x)奇函数\2\int_0^af(x)dx,&amp;f(x)偶函数\end{cases}\<br>&amp;证：\int_{-a}^0{f(x)dx}\overset{x&#x3D;-t}{&#x3D;}\int_0^a{f(-t)d(-t)}&#x3D;-\int_{0}^{a}f(t)d(t)&#x3D;-\int_0^a{f(x)dx}\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;(2)设f(x)是以T为周期的连续函数,则对\forall A，有\int_a^{a+T}f(x)&#x3D;\int_0^T{f(x)dx}\<br>&amp;\int_a^{a+T}f(x)dx\overset{x&#x3D;a+t}{&#x3D;}\int_0^T{f(a+t)d(a+t)}&#x3D;\int_0^{a+t}f(a+t)dt\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;\Phi:x\in[a,b]\rightarrow y\in[c,d],令\frac{x-a}{b-a}&#x3D;\frac{y-c}{d-c},y&#x3D;c+\frac{d-c}{b-a}(x-a)\<br>\end{align}\<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210617160041903.jpg" alt="image-20210617160041903"></p>
<h4 id="5-奇偶函数积分后的奇偶性-奇偶函数求导后的奇偶性"><a href="#5-奇偶函数积分后的奇偶性-奇偶函数求导后的奇偶性" class="headerlink" title="5.奇偶函数积分后的奇偶性(奇偶函数求导后的奇偶性)"></a>5.奇偶函数积分后的奇偶性(奇偶函数求导后的奇偶性)</h4><h5 id="1-奇偶函数求导后的奇偶性"><a href="#1-奇偶函数求导后的奇偶性" class="headerlink" title="1.奇偶函数求导后的奇偶性"></a>1.奇偶函数求导后的奇偶性</h5><p>$$<br>\begin{align}<br>&amp;(1)f(x)为奇函数:\<br>&amp;f(-x)&#x3D;-f(x)\<br>&amp;\Leftrightarrow f’(-x)(-1)&#x3D;-f’(x)\<br>&amp;\Leftrightarrow f’(-x)&#x3D;f’(x)\<br>&amp;\Leftrightarrow f’(x)为偶函数\<br>&amp;(2)f(x)为偶函数:\<br>&amp;f(-x)&#x3D;f(x)\<br>&amp;\Leftrightarrow f’(-x)&#x3D;f’(x)\<br>&amp;\Leftrightarrow f’(-x)(-1)&#x3D;f’(x)\<br>&amp;\Leftrightarrow f’(-x)&#x3D;-f’(x)\<br>&amp;\Leftrightarrow f’(x)为奇函数\<br>\end{align}<br>$$</p>
<h5 id="2-奇偶函数求积分后的奇偶性"><a href="#2-奇偶函数求积分后的奇偶性" class="headerlink" title="2.奇偶函数求积分后的奇偶性"></a>2.奇偶函数求积分后的奇偶性</h5><p>$$<br>\begin{align}<br>&amp;设F(x)为f(x)的原函数\<br>&amp;(1)f(x)为奇函数:\<br>&amp;f(-x)&#x3D;-f(x)\<br>&amp;\Leftrightarrow \int f(-x)dx&#x3D;-\int f(x)dx\<br>&amp;\Leftrightarrow -\int f(-x)d(-x)&#x3D;-\int f(x)dx\<br>&amp;\Leftrightarrow F(-x)&#x3D;F(x)\<br>&amp;\Leftrightarrow F(x)为偶函数\<br>&amp;(2)f(x)为偶函数:\<br>&amp;f(-x)&#x3D;f(x)\<br>&amp;\Leftrightarrow \int f(-x)dx&#x3D;\int f(x)dx\<br>&amp;\Leftrightarrow -\int f(-x)d(-x)&#x3D;\int f(x)dx\<br>&amp;\Leftrightarrow F(-x)&#x3D;-F(x)\<br>&amp;\Leftrightarrow F(x)为奇函数\<br>\end{align}<br>$$</p>
<h5 id="3-奇偶函数复合后的奇偶性"><a href="#3-奇偶函数复合后的奇偶性" class="headerlink" title="3.奇偶函数复合后的奇偶性"></a>3.奇偶函数复合后的奇偶性</h5><p>$$<br>\begin{align}<br>&amp;\exist f(x),g(x),F(x)&#x3D;f(g(x))\<br>&amp;设f(x)为奇函数\<br>&amp;(1)g(x)为偶函数\<br>&amp;F(-x)&#x3D;f(g(-x))&#x3D;f(g(x))&#x3D;F(x),F(x)为偶函数\<br>&amp;(2)g(x)为奇函数\<br>&amp;F(-x)&#x3D;f(g(-x))&#x3D;f(-g(x))&#x3D;-f(g(x))&#x3D;-F(x),F(x)为奇函数\<br>&amp;设f(x)为偶函数\<br>&amp;(1)g(x)为奇函数\<br>&amp;F(-x)&#x3D;f(g(-x))&#x3D;f(g(x))&#x3D;F(x),F(x)为偶函数\<br>&amp;(2)g(x)为偶函数\<br>&amp;F(-x)&#x3D;f(g(-x))&#x3D;f(g(x))&#x3D;F(x),F(x)为偶函数\<br>&amp;注解:外偶全偶,外奇奇偶\<br>\end{align}<br>$$</p>
<p>例题：<br>$$<br>\begin{align}<br>&amp;1.设M&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}{\frac{\sin x}{1+x^2}\cos^4xdx},N&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}{(\sin x^3+\cos^4x)dx},P&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(x^2\sin^3x-\cos^4x)dx,则\<br>&amp;(A)N&lt;P&lt;M(B)M&lt;P&lt;N(C)N&lt;M&lt;P(D)P&lt;M&lt;N\<br>&amp;根据对称性判断\<br>&amp;M:f_M(x)为奇函数，F_M(x)为偶函数\<br>&amp;N:N&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}{(\sin x^3+\cos^4x)dx}&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\sin ^3xdx+\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos ^4xdx\<br>&amp;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\sin ^3xdx&#x3D;0,\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos ^4xdx\geq 0,\Rightarrow N\geq 0\<br>&amp;P:P&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}(x^2\sin^3x-\cos^4x)dx&#x3D;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}x^2\sin^3xdx-\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos^4xdx\<br>&amp;\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}x^2\sin^3xdx&#x3D;0,\int_{-\frac{\pi}{2}}^{\frac{\pi}{2}}\cos^4xdx\geq0,\Rightarrow P\leq0\<br>&amp;\Leftrightarrow P&lt;M&lt;N,\space\space选(D)\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;2.设f(x)&#x3D;\begin{cases}&amp;kx,0\leq x\leq \frac{1}{2}a\&amp;c,\frac{1}{2}a&lt;x\leq a\\end{cases},求F(x)&#x3D;\int_0^xf(t)dt,x\in[0,a]\<br>&amp;F(x)&#x3D;\begin{cases}&amp;\int_0^xktdt&#x3D;\frac{1}{2}kt^2|<em>0^x&#x3D;\frac{1}{2}kx^2,0\leq x\leq \frac{1}{2}a\&amp;\int_0^{\frac{1}{2}a}ktdt+\int</em>{\frac{1}{2}a}^c cdt&#x3D;\frac{1}{8}ka^2+c^2-\frac{1}{2}ac,\frac{1}{2}a&lt;x\leq a\\end{cases}\<br>\end{align}<br>$$</p>
<p>$$<br>\begin{align}<br>&amp;3.证明：\int_0^{2\pi}f(|\cos x|)dx&#x3D;4\int_0^{\frac{\pi}{2}}f(|\cos x|)dx\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/e0e1f27ff16b0cf00a8f3d155bfc3423.jpg" alt="1111"></p>
<h4 id="6-已有公式"><a href="#6-已有公式" class="headerlink" title="6.已有公式"></a>6.已有公式</h4><p>$$<br>\begin{align}<br>&amp;(1)\int_0^{\frac{\pi}{2}}{\sin^nxdx&#x3D;\int_0^{\frac{\pi}{2}}\cos^n xdx&#x3D;\begin{cases}\frac{n-1}{n}<em>\frac{n-3}{n-2}</em>…*\frac{1}{2}*\frac{\pi}{2},&amp;n为偶数\\frac{n-1}{n}<em>\frac{n-3}{n-2}</em>…*\frac{2}{3},&amp;n为大于1的奇数\\end{cases}}\<br>&amp;(2)\int_0^{\pi}xf(\sin x)dx&#x3D;\frac{\pi}{2}\int_0^{\pi}f(\sin x)dx(f(x)为连续函数)\<br>\end{align}<br>$$</p>
<h4 id="7-与定积分有关的证明"><a href="#7-与定积分有关的证明" class="headerlink" title="7.与定积分有关的证明"></a>7.与定积分有关的证明</h4><h4 id="8-经典例题："><a href="#8-经典例题：" class="headerlink" title="8.经典例题："></a>8.经典例题：</h4><h5 id="例题1"><a href="#例题1" class="headerlink" title="例题1:"></a>例题1:</h5><p>$$<br>\begin{align}<br>&amp;\lim_{n\rightarrow \infty}{(\frac{1}{n+1}+\frac{1}{n+2}+…+\frac{1}{n+n})}\<br>&amp;法1：夹逼定理+基本不等式\<br>&amp;\frac{1}{1+x}&lt;\ln(x+1)&lt;x\<br>&amp;令x&#x3D;\frac{1}{n}\<br>&amp;得\frac{1}{n+1}&#x3D;\frac{\frac{1}{n}}{\frac{1}{n}+1}&lt;\ln(\frac{1}{n}+1)&#x3D;\ln(n+1)-\ln(n)&lt;\frac{1}{n}\<br>&amp;得\frac{1}{n+2}&lt;ln(n+2)-ln(n+1)&lt;\frac{1}{n+1}\<br>&amp;得\frac{1}{n+n}&lt;\ln(n+n)-\ln(n+n-1)&lt;\frac{1}{n+n-1}\<br>&amp;得\frac{1}{n+1}+\frac{1}{n+2}+…+\frac{1}{n+n}&lt;ln(2n)-ln(n)&#x3D;ln2\<br>&amp;法2：\lim_{n\rightarrow \infty}{(\frac{1}{n+1}+\frac{1}{n+2}+…+\frac{1}{n+n})}中\<br>&amp;\frac{1}{n+1}中n为主体，1为变体\<br>&amp;\frac{变体}{主体}\rightarrow^{n \rightarrow{\infty}}\begin{cases}0,次(夹逼定理)\A\neq 0,同(定积分)\end{cases}\<br>&amp;\lim_{\lambda \rightarrow 0}{\sum_{i&#x3D;1}^{n}{f(\xi_i)\Delta x_i}&#x3D;\lim_{n\rightarrow \infty}\frac{1}{n}\sum_{i&#x3D;1}^{n}f(\xi_i)(b-a)}&#x3D;\int_0^1\frac{1}{1+x}&#x3D;\ln(1+x)|_{0}^{1}&#x3D;\ln2\<br>\end{align}<br>$$</p>
<h5 id="例题2"><a href="#例题2" class="headerlink" title="例题2"></a>例题2</h5><p>$$<br>\begin{align}<br>&amp;设f(x)&#x3D;\int_0^{\pi}{\frac{\sin x}{\pi-t}dt},计算\int_0^{\pi}f(x)dx.\<br>&amp;法1：分部积分+换元法\<br>&amp;原式&#x3D;xf(x)|_0^{\pi}-\int_0^{\pi}{\frac{x\sin x}{\pi-x}dx}\<br>&amp;&#x3D;\pi{\int_0^{\pi}{\frac{\sin{t}}{\pi-t}dt}-\int_0^{\pi}{\frac{x\sin x}{\pi-x}}dx}\<br>&amp;&#x3D;\int_0^{\pi}{\frac{(\pi-x)\sin x}{\pi-x}dx}&#x3D;2\<br>&amp;法2：\<br>&amp;原式&#x3D;\int_0^\pi{f(x)d(x-{\pi})}&#x3D;(x-\pi)f(x)|_0^{\pi}-\int_0^{\pi}{\frac{(x-\pi)\sin x}{\pi-x}dx}&#x3D;2\<br>&amp;法3：二重积分转化为累次积分\<br>&amp;原式&#x3D;\int_0^{\pi}{\int_0^{\pi}\frac{x\sin t}{\pi-t}dt}dx\<br>\end{align}<br>$$</p>
<h5 id="例题3"><a href="#例题3" class="headerlink" title="例题3"></a>例题3</h5><p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/AN%L6IJ6TF[%1UB3OUWMRCR.jpg" alt="img"></p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/123.jpg" alt="123"><br>$$<br>\begin{align}<br>&amp;法1：构造辅助函数\<br>&amp;根据题意f(1)&#x3D;f(-1)&#x3D;1,f(0)&#x3D;-1\Rightarrow f(x)为偶函数,f最低点函数值为-1\<br>&amp;可以构造符合题意的辅助函数f(x)&#x3D;2x^2-1\<br>&amp;法2：根据函数的性质直接判断<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210408160543049.jpg" alt="image-20210408160543049"></p>
<h5 id="例题4"><a href="#例题4" class="headerlink" title="例题4"></a>例题4</h5><p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/Q8%7DOT_25(HC79%5BS_21)AZZK.jpg" alt="img"></p>
<p>$$<br>\begin{align}<br>&amp;因为\lim_{x\rightarrow 0}{\frac{ax-\sin x}{\int_b^x{\frac{\ln{1+t^3}}{t}dt}}}&#x3D;c(c\neq 0)\<br>&amp;所以\lim_{x\rightarrow 0}{ax-\sin x}&#x3D;0并且\lim_{x \rightarrow 0}{\int_b^x{\frac{\ln{1+t^3}}{t}dt}}&#x3D;0\<br>&amp;化简,使用洛必达法则上下求导\<br>&amp;\lim_{x\rightarrow 0}{\frac{ax-\sin x}{\int_b^x{\frac{\ln{1+t^3}}{t}dt}}}&#x3D;\lim_{x\rightarrow 0}{\frac{a-\cos x}{\frac{\ln{1+x^3}}{x}}}&#x3D;\lim_{x\rightarrow 0}{\frac{a-\cos x}{x^2}}\<br>&amp;\Rightarrow a&#x3D;1,c&#x3D;\frac{1}{2},b&#x3D;0\<br>\end{align}<br>$$</p>
<h2 id="反常积分"><a href="#反常积分" class="headerlink" title="反常积分"></a>反常积分</h2><h3 id="一、无穷区间上的反常积分"><a href="#一、无穷区间上的反常积分" class="headerlink" title="一、无穷区间上的反常积分"></a>一、无穷区间上的反常积分</h3><p>$$<br>\begin{align}<br>&amp;(1)\int_a^{+\infty}{f(x)}dx&#x3D;\lim_{t\rightarrow +\infty}{\int_{a}^{t}f(x)dx}\<br>&amp;(2)\int_{-\infty}^{b}{f(x)}dx&#x3D;\lim_{t\rightarrow -\infty}{\int_{t}^{b}f(x)dx}\<br>&amp;(3)\int_{-\infty}^{0}{f(x)}dx和{\int_{0}^{+\infty}f(x)dx}都收敛,则{\int_{-\infty}^{+\infty}f(x)dx}收敛\<br>&amp;且{\int_{-\infty}^{+\infty}f(x)dx}&#x3D;\int_{-\infty}^{0}{f(x)}dx+{\int_{0}^{+\infty}f(x)dx}\<br>&amp;如果其中一个发散,结果也发散\<br>&amp;常用结论：\int_a^{+\infty}{\frac{1}{x^p}dx}\begin{cases}&amp;p1,收敛\&amp;p\leq1 ,发散\\end{cases},(a0)\<br>\end{align}<br>$$</p>
<h3 id="二、无界函数的反常积分"><a href="#二、无界函数的反常积分" class="headerlink" title="二、无界函数的反常积分"></a>二、无界函数的反常积分</h3><p>$$<br>\begin{align}<br>&amp;如果函数f(x)在点a的任一领域内都无界,那么点a为函数f(x)的瑕点(也称为无界点).无界函数的反常积分也成为瑕积分\<br>&amp;(1)设函数f(x)在(a,b]上连续,点a为f(x)的瑕点.如果极限\lim_{t\rightarrow a^+}{\int_{t}^{b}{f(x)dx}}\exist,\<br>&amp;则称此极限为函数f(x)在区间[a,b]上的反常区间,记作\int_{a}^{b}f(x)dx,即\int_{a}^{b}f(x)dx&#x3D;\lim_{t\rightarrow a^+}{\int_{t}^{b}{f(x)dx}}\<br>&amp;这时也称反常积分\int_a^b{f(x)dx}收敛,如果上述极限不存在，则反常积分\int_a^b{f(x)dx}发散\<br>&amp;(2)设函数f(x)在[a,b)上连续,点b为函数f(x)的瑕点,则可以类似定义函数f(x)在区间[a,b]上的反常积分\int_a^bf(x)dx&#x3D;\lim_{t\rightarrow b^-}{\int_a^tf(x)dx}\<br>&amp;设函数f(x)在[a,b]上除点c(a&lt;c&lt;b)外连续,点c为函数f(x)的瑕点,如果反常积分\int_a^c{f(x)dx}和\int_c^b{f(x)dx}都收敛\<br>&amp;则称反常积分\int_a^b{f(x)dx}收敛,且\int_a^b{f(x)dx}&#x3D;\int_a^c{f(x)dx}+\int_c^b{f(x)dx}\<br>&amp;如果至少一个发散,则称\int_a^b{f(x)dx}发散\<br>&amp;常用结论：\<br>&amp;\int_a^b{\frac{1}{(x-a)^p}}\begin{cases}&amp;p&lt;1,收敛\&amp;p\geq 1,发散\\end{cases}\<br>&amp;\int_a^b{\frac{1}{(x-a)^p}}\begin{cases}&amp;p&lt;1,收敛\&amp;p\geq 1,发散\\end{cases}\<br>\end{align}<br>$$</p>
<h3 id="三、例题"><a href="#三、例题" class="headerlink" title="三、例题"></a>三、例题</h3><h5 id="例题1-1"><a href="#例题1-1" class="headerlink" title="例题1"></a>例题1</h5><p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/12edsadada.jpg" alt="12edsadada"><br>$$<br>\begin{align}<br>&amp;\int\frac{1}{\ln^{\alpha}x}d(\ln x)\rightarrow^{\ln x&#x3D;u}\int{\frac{du}{u^{\alpha+1}}}\begin{cases}&amp;{\alpha-1&lt; 1}\&amp;{\alpha+11}\\end{cases}\Rightarrow 0&lt;\alpha&lt;2\<br>\end{align}<br>$$</p>
<h2 id="定积分的应用"><a href="#定积分的应用" class="headerlink" title="定积分的应用"></a>定积分的应用</h2><h4 id="微元法"><a href="#微元法" class="headerlink" title="微元法"></a>微元法</h4><p>$$<br>\begin{align}<br>&amp;\<br>\end{align}<br>$$</p>
<h3 id="一、几何应用"><a href="#一、几何应用" class="headerlink" title="一、几何应用"></a>一、几何应用</h3><h4 id="1-平面图形的面积"><a href="#1-平面图形的面积" class="headerlink" title="1.平面图形的面积"></a>1.平面图形的面积</h4><p>$$<br>\begin{align}<br>&amp;(1)若平面域D由曲线y&#x3D;f(x),y&#x3D;g(x)(f(x)\geq g(x)),x&#x3D;a,x&#x3D;b(a&lt;b)所围成,则平面域D的面积为\<br>&amp;S&#x3D;\int_a^b{[f(x)-g(x)]dx}\<br>&amp;(2)若平面域D由曲线由\rho&#x3D;\rho(\theta),\theta&#x3D;\alpha,\theta&#x3D;\beta(\alpha&lt;\beta)所围成,则其面积为S&#x3D;\frac{1}{2}\int_{\alpha}^{\beta}{\rho^2(\theta)d\theta}<br>\end{align}<br>$$</p>
<h4 id="2-旋转体的体积"><a href="#2-旋转体的体积" class="headerlink" title="2.旋转体的体积"></a>2.旋转体的体积</h4><p>$$<br>\begin{align}<br>&amp;若区域D由曲线y&#x3D;f(x)(f(x)\geq 0)和直线x&#x3D;a,x&#x3D;b(0\leq a&lt;b)及x轴所围成,则\<br>&amp;(1)区域D绕x轴旋转一周所得到的旋转体体积为V_x&#x3D;\pi\int_a^b{f^2(x)dx}\<br>&amp;(2)区域D绕y轴旋转一周所得到的旋转体体积为V_y&#x3D;2\pi\int_a^b{xf(x)dx}\<br>&amp;(3)区域D绕y&#x3D;kx+b轴旋转一周所得到的旋转体体积为V&#x3D;2\pi\int_D\int{r(x,y)d\sigma}\<br>&amp;例如：求y&#x3D;x,y&#x3D;x^2在第一象限的封闭图形绕转轴的体积\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/U1%7D97(ZE)HIN4FCVUKI$%5DZB.jpg" alt="img"><br>$$<br>\begin{align}<br>&amp;V_x&#x3D;2\pi\int_D\int yd\sigma&#x3D;2\pi\int_0^1{dx}\int_{x^2}^{x}ydy\<br>&amp;V_y&#x3D;2\pi\int_D\int xd\sigma&#x3D;2\pi\int_0^1{dx}\int_{x^2}^{x}xdy\<br>&amp;V_{x&#x3D;1}&#x3D;2\pi\int_D\int (1-x)d\sigma\<br>&amp;V_{y&#x3D;2}&#x3D;2\pi\int_D\int (2-y)d\sigma\<br>\end{align}<br>$$</p>
<h4 id="3-曲线弧长"><a href="#3-曲线弧长" class="headerlink" title="3.曲线弧长"></a>3.曲线弧长</h4><p>$$<br>\begin{align}<br>&amp;(1)C:y&#x3D;y(x),a\leq x\leq b,s&#x3D;\int_a^b{\sqrt{1+y’^2}dx}\<br>&amp;(2)C:\begin{cases}&amp;x&#x3D;x(t)\&amp;y&#x3D;y(t)\\end{cases},\alpha \leq t\leq  \beta,s&#x3D;\int_{\alpha}^{\beta}{\sqrt{x’^2+y’^2}dx}\<br>&amp;(3)C:\rho&#x3D;\rho(\theta),\alpha \leq \theta\leq  \beta,s&#x3D;\int_{\alpha}^{\beta}{\sqrt{\rho^2+\rho’^2}dx}\<br>\end{align}<br>$$</p>
<h4 id="4-旋转体侧面积"><a href="#4-旋转体侧面积" class="headerlink" title="4.旋转体侧面积"></a>4.旋转体侧面积</h4><p>$$<br>\begin{align}<br>&amp;曲线y&#x3D;f(x)(f(x)\geq 0)和直线x&#x3D;a,x&#x3D;b(0\leq a&lt;b)及x轴所围成的区域绕x轴旋转所得到的旋转体的侧面积为\<br>&amp;S&#x3D;2\pi\int_a^b{f(x)\sqrt{1+f’^2(x)}dx}\<br>\end{align}<br>$$</p>
<h3 id="二、物理应用"><a href="#二、物理应用" class="headerlink" title="二、物理应用"></a>二、物理应用</h3><h4 id="1-压力"><a href="#1-压力" class="headerlink" title="1.压力"></a>1.压力</h4><h4 id="2-变力做功"><a href="#2-变力做功" class="headerlink" title="2.变力做功"></a>2.变力做功</h4><h4 id="3-引力（较少考）"><a href="#3-引力（较少考）" class="headerlink" title="3.引力（较少考）"></a>3.引力（较少考）</h4><h4 id="例题1-2"><a href="#例题1-2" class="headerlink" title="例题1"></a>例题1<img src="https://raw.githubusercontent.com/blueflylabor/images/main/X2PPU~%@L@NM4Y%7DW6GZTT_R.jpg" alt="img"></h4><p>$$<br>\begin{align}<br>&amp;分析题意可知,该容器由x^2+y^2&#x3D;1的圆和x^2+(y-1)^2&#x3D;1的偏心圆组成\<br>&amp;根据图像的对称性可以避免不同表达式带来的困难\<br>&amp;对圆的小带子进行积分，带子长度为x，积分区间为-1到\frac{1}{2}，\int_{-1}^{\frac{1}{2}}{\pi x^2dy}\<br>&amp;由于图像的对称性，将积分结果乘二\<br>&amp;(1)V&#x3D;2\pi\int_{-1}^{\frac{1}{2}}{x^2}dy&#x3D;2\pi\int_{-1}^{\frac{1}{2}}{(1-y^2)dy}&#x3D;\frac{9\pi}{4}\<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-19%20203327.jpg" alt="屏幕截图 2021-04-19 203327"><br>$$<br>\begin{align}<br>&amp;(2)W&#x3D;F<em>S&#x3D;G</em>S&#x3D;mg<em>S&#x3D;\rho VSg\<br>&amp;上部为W_1&#x3D;\int_{\frac{1}{2}}^{2}(2y-y^2)(2-y)dy</em>\rho g\<br>&amp;下部为W_2&#x3D;\int^{\frac{1}{2}}_{-1}(1-y^2)(2-y)dy*\rho g\<br>&amp;W&#x3D;W_1+W_2\<br>\end{align}<br>$$<br><img src="https://raw.githubusercontent.com/blueflylabor/images/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202021-04-19%20204534.jpg" alt="屏幕截图 2021-04-19 204534"></p>
<h4 id="例题2-1"><a href="#例题2-1" class="headerlink" title="例题2"></a>例题2</h4><p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/image-20210419211039410.jpg" alt="image-20210419211039410"><br>$$<br>\begin{align}<br>&amp;F_p&#x3D;P<em>A&#x3D;\rho gh</em>A\<br>&amp;将图像分为上部和下部，上部为矩形区域和下部的抛物线围成的面积区域，对其进行依次求解\<br>&amp;P_1&#x3D;2\rho gh\int_1^{h+1}{h+1-y}dy&#x3D;\rho gh^2\<br>&amp;P_2&#x3D;2\rho gh\int_0^1{(h+1-y)\sqrt{y}dy&#x3D;4\rho g(\frac{1}{3}h+\frac{2}{15})}\<br>&amp;\frac{P_1}{P_2}&#x3D;\frac{4}{5}\Rightarrow h&#x3D;2,h&#x3D;-\frac{1}{3}(舍去)<br>\end{align}<br>$$</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/1618837868(1).jpg" alt="1618837868(1)"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%B8%8D%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%AE%9A%E7%A7%AF%E5%88%86%E4%B8%8E%E5%8F%8D%E5%B8%B8%E7%A7%AF%E5%88%86/" data-id="clyoz625p000lgadqb97f0oz6" data-title="高等数学不定积分与定积分与反常积分" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-高等数学二元函数可微与偏导的联系​" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%81%8F%E5%AF%BC%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%8B/" class="article-date">
  <time class="dt-published" datetime="2018-09-06T04:01:51.000Z" itemprop="datePublished">2018-09-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%81%8F%E5%AF%BC%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%8B/">高等数学二元函数的可偏导</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>1.二元函数的可偏导</strong></p>
<p>在二元函数中，一元函数的可导的概念变为可偏导，导函数的概念变为偏导函数，具体看下例：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/9d82d158ccbf6c818200af6499c37c3132fa400c.jpeg" alt="img"></p>
<p>二元函数f(x,y)对x、y的偏导函数分别为：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/728da9773912b31b5d52d2cda3e5fb7edbb4e11e.jpeg" alt="img"></p>
<p>在求二元函数的偏导函数时，都是假设另外一个变量为常量，然后对余下那个变量求导数。例如，f(x,y)对x的偏导函数，就是假设y为常量，然后f(x,y)对变量x求导数即得。</p>
<p>对于某一点，函数f(x, y)在该点的两个偏导数可能都存在、可能只存在一个、也可能都不存在。</p>
<p>在点(0, 0)的两个偏导数只存在一个的函数例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/2cf5e0fe9925bc31f7e7c860782240b5c9137096.jpeg" alt="img"></p>
<p>在点(0, 0)的两个偏导数都不存在的函数例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/023b5bb5c9ea15ce6c2fde3c90fdf7f73887b2c7.jpeg" alt="img"></p>
<p>在点(0, 0)的两个偏导数都存在的函数例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/0824ab18972bd407221931d55d7453550eb30939.jpeg" alt="img"></p>
<p>对于上面三个例子，小编建议大家亲手去算算偏导数，这样能加深对二元函数偏导数的理解。</p>
<p><strong>2.二元函数的可微</strong></p>
<p>某一点可微描述的是函数增量与自变量增量之间的线性关系。在一元函数中，若线性主部的系数只与该点有关，则可微。以此类推，在二元函数中，若多个自变量的线性主部的系数都只与该点有关，则可微。下面分别列出一元函数、二元函数函数增量与自变量增量之间的关系式：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/d439b6003af33a877c62e124e1a1dd3c5243b587.jpeg" alt="img"></p>
<p>对于一特定点，当A、B为常数时，即A、B与自变量增量无关，则函数在该点可微，且A、B分别为函数在该点对x、y求偏导后的偏导数。</p>
<p><strong>3.可微、可偏导、连续、导函数连续之间的关系</strong></p>
<p>为了方便比较一元函数，小编先给出一元函数在某点C上关于可微、可导、连续、导函数连续的关系图。在图1中，函数f(x)可微与可导等价，因此可微与可导之间是双向箭头；在点C可微、可导必能得出函数f(x)在点C连续，但连续不能推出f(x)在点C可导、可微。因此可微、可导与连续之间是单向箭头。而导函数在点C连续，很明显就能推出函数在点C可导、可微、连续，但反过来，无法推出导函数在点C连续。</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/7acb0a46f21fbe09fc1d4d2f4d9dc1378644ad48.jpeg" alt="img">图1.一元函数可微、可导关系示意图</p>
<p>小编提醒大家，一定要经常记忆上图，而且是要理解性地记忆，比如说一元函数可微，要能明白可微是什么，关系式如何写！</p>
<p>相比于一元函数，二元函数就复杂多了，下面先给出二元函数可微、可偏导、连续、导函数连续的关系图。</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/3c6d55fbb2fb43165d025ae105598b2708f7d309.jpeg" alt="img">图2.多元函数可微、可偏导关系示意图</p>
<p>当然在记忆这些关系时，我们通常要花时间记忆的是那些不容易理解的关系，而这些不容易理解的关系是与一元函数相比较后的那些不同之处。</p>
<p><strong>3.1可微与可偏导不等价</strong></p>
<p>在阐述二元函数可微与可偏导不等价前，不妨先回顾下，为什么一元函数中可微与可导是等价的？</p>
<p>在一元函数中，如果函数f(x)在x&#x3D;x0处可导，则有如下关系式：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/242dd42a2834349b8a998272ec17d8ca34d3bea8.jpeg" alt="img"></p>
<p>假设在一元函数中，函数增量与自变量存在如下关系：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/6a600c338744ebf8019d6c0aff041a2e6159a71c.jpeg" alt="img"></p>
<p>上式两边同除以△x，然后两边对△x取极限，可知A&#x3D;m，则根据一元函数可微的定义，A只与x&#x3D;x0有关，与△x无关，所以f(x)在x&#x3D;x0可微。同理，不难得出在一元函数中，可微亦可推出可导。</p>
<p>那么在二元函数中，如何论证可微必可推导呢？</p>
<p>假设二元函数在点C(x0, y0)可微，则由可微的定义，必存在(x0, y0)的某邻域，使得下式成立：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/203fb80e7bec54e7797010c09cc556544dc26a55.jpeg" alt="img"></p>
<p>不妨分别令△x&#x3D;0、△y&#x3D;0，根据①式可得：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/f703738da977391283a65691dde44b1c347ae244.jpeg" alt="img"></p>
<p>之所以可以令△x&#x3D;0、△y&#x3D;0，是因为点(x0, y0+△y)和(x0+△x, y0)都在点(x0, y0)的可微邻域内。</p>
<p>对②中两式求极限，可得:</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/e850352ac65c103845d7a20797ec5e17b27e894f.jpeg" alt="img"></p>
<p>结合偏导数的定义和③中的两个极限，可知可微情况下，函数在点C的两个偏导数都存在，因此可微必可偏导。</p>
<p>尽管可微必可偏导，但反过来不成立，请看下面这个例子：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/08f790529822720ef5a584c15d36c742f31faba0.jpeg" alt="img"></p>
<p>函数F在(0, 0)的两个偏导数都存在且为0，现在用反证法证明函数F在点(0, 0)不可微。假设函数F在原点可微，则根据可微定义，下列极限必存在，但是下列极限可以通过列举两条路径很容易验证不存在，原假设错误，所以可偏导不一定可微。</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/c8177f3e6709c93d685e88a4b9c035d8d0005432.jpeg" alt="img"></p>
<p><strong>3.2 可偏导不一定连续</strong></p>
<p>在二元函数关系图中，另外一个很让人费解的地方，是二元函数在某点的两个偏导数都存在，但是函数在这一点却不一定连续。为了说明这一点，请看下面这个函数：</p>
<p><img src="https://raw.githubusercontent.com/blueflylabor/images/main/0b46f21fbe096b6339eceea129ce4a40e9f8ac48.jpeg" alt="img"></p>
<p>相信大家都能很熟练地计算出函数F在原点对x、y的偏导数均为0，但是当曲线沿着y&#x3D;x的路径趋于原点时，函数值会趋于1，不等于0，因此函数F在原点不连续。</p>
<p>从抽象的角度看，二元函数在某一点的两个偏导数都存在，只能说明二元函数沿x方向、沿y方向趋于该点的值等于函数在该点的定义值，但无法保证沿其它方向趋于该点的值也等于函数值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://blueflylabor.github.io/2018/09/06/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6%E4%BA%8C%E5%85%83%E5%87%BD%E6%95%B0%E5%8F%AF%E5%BE%AE%E4%B8%8E%E5%81%8F%E5%AF%BC%E7%9A%84%E8%81%94%E7%B3%BB%E2%80%8B/" data-id="clyoz625q000mgadq4csbf7dy" data-title="高等数学二元函数的可偏导" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">五月 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/10/">十月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/09/">九月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">二月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">十月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">九月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/05/14/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AEUbuntu22.04%E5%AE%89%E8%A3%85Nodejs/">环境配置Ubuntu22.04安装Nodejs</a>
          </li>
        
          <li>
            <a href="/2023/10/06/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E4%BD%9C%E6%96%87%E6%A8%A1%E6%9D%BF/">考研英语作文模板</a>
          </li>
        
          <li>
            <a href="/2023/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%B1%82/">计算机网络传输层</a>
          </li>
        
          <li>
            <a href="/2023/09/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BD%91%E7%BB%9C%E5%B1%82/">计算机网络网络层</a>
          </li>
        
          <li>
            <a href="/2021/04/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/">操作系统同步问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 蓝翔技工<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>