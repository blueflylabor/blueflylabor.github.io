---
layout: post
title: "some knowledge about go routine and channel"
categories:
  - go
  - routines
  - channel
---

### 一、通道缓冲区的基本概念
通道的缓冲区是一块用于临时存储数据的内存区域，在创建通道时通过 `make(chan Type, capacity)` 指定容量（`capacity` 为缓冲区大小）。

- **无缓冲通道**：`make(chan Type)` 或 `make(chan Type, 0)`，缓冲区容量为 0。
- **带缓冲通道**：`make(chan Type, N)`（`N > 0`），缓冲区最多可存储 `N` 个元素。


### 二、无缓冲通道 vs 带缓冲通道的核心区别
| 特性                | 无缓冲通道（容量 0）                          | 带缓冲通道（容量 N > 0）                      |
|---------------------|---------------------------------------------|---------------------------------------------|
| **发送操作**         | 必须等待接收方准备好，否则阻塞（同步操作）         | 缓冲区未满时可直接发送，满了则阻塞（异步操作，直到缓冲区有空间） |
| **接收操作**         | 必须等待发送方准备好，否则阻塞（同步操作）         | 缓冲区非空时可直接接收，空了则阻塞（直到缓冲区有数据）       |
| **同步性**           | 强同步：发送和接收必须“握手”才能完成              | 弱同步：依赖缓冲区状态，可暂时存储数据              |
| **适用场景**         | 用于 goroutine 间严格同步（如传递信号、确保顺序）    | 用于平衡生产方和消费方速度差异（如任务队列、流量削峰）      |


### 三、缓冲区操作示例
#### 1. 无缓冲通道（死锁与正确用法）
```go
package main

import "fmt"

func main() {
    // 无缓冲通道
    ch := make(chan int)

    // 错误：主 goroutine 发送后无接收方，死锁
    // ch <- 10 

    // 正确：启动接收 goroutine 后再发送
    go func() {
        fmt.Println("接收:", <-ch) // 等待发送方
    }()
    ch <- 10 // 发送后等待接收方完成（同步）
    fmt.Println("发送完成")
}
```
**输出**：
```
接收: 10
发送完成
```


#### 2. 带缓冲通道（缓冲区未满/满的情况）
```go
package main

import "fmt"

func main() {
    // 容量为 2 的带缓冲通道
    ch := make(chan int, 2)

    // 缓冲区未满，发送不阻塞
    ch <- 10
    ch <- 20

    // 查看缓冲区状态（长度和容量）
    fmt.Println("长度:", len(ch), "容量:", cap(ch)) // 长度: 2 容量: 2

    // 缓冲区已满，再发送会阻塞（注释掉避免死锁）
    // ch <- 30

    // 接收数据，缓冲区腾出空间
    fmt.Println("接收:", <-ch) // 接收: 10
    fmt.Println("长度:", len(ch)) // 长度: 1

    // 此时可再发送一个数据（缓冲区有空间）
    ch <- 30
    fmt.Println("长度:", len(ch)) // 长度: 2
}
```


### 四、缓冲区的关键注意事项
1. **死锁风险**：
   - 无缓冲通道：若发送后无接收方（或接收前无发送方），会导致死锁。
   - 带缓冲通道：若缓冲区满时仍发送，或空时仍接收，也会导致死锁。

2. **长度与容量**：
   - `len(ch)`：返回当前缓冲区中的元素个数。
   - `cap(ch)`：返回缓冲区的最大容量（创建时指定）。

3. **关闭通道的影响**：
   - 关闭后可继续接收缓冲区中的数据，接收完后返回零值和 `false`。
   - 关闭后不能再发送数据（会触发 panic）。

4. **性能考量**：
   - 带缓冲通道可减少 goroutine 切换开销（通过缓冲区暂存数据），但需合理设置容量（过大浪费内存，过小仍可能频繁阻塞）。


### 五、适用场景总结
- **无缓冲通道**：适合需要严格同步的场景（如“接力”任务、信号通知），确保发送方和接收方步调一致。
- **带缓冲通道**：适合“生产者-消费者”模型，当生产速度与消费速度不匹配时，通过缓冲区平衡两者（如日志收集、任务调度）。